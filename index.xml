<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on 📦 Caesar&#39;s Paperbox</title>
    <link>https://caesaryangs.github.io/</link>
    <description>Recent content in Introduction on 📦 Caesar&#39;s Paperbox</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://caesaryangs.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>雅思备考指北-v2023</title>
      <link>https://caesaryangs.github.io/blogs/IELTS_2023/</link>
      <pubDate>Fri, 09 Jun 2023 10:40:58 +0800</pubDate>
      <guid>https://caesaryangs.github.io/blogs/IELTS_2023/</guid>
      <description>雅思备考指北-v2023 # Prologue # 大四下学期出现了一些规划上的危机，而且我这种情况算是特殊中的特殊，可借鉴的例子比较少。在调整好心态以后决定还是先行动起来，把一些达到目标的必须要求准备好，比如IELTS/GRE这种标化成绩。&#xA;还好最后三十多天调整了心态，在大学的最后把毕设和雅思一起搞定了。&#xA;阅读 # 我在备考前一年一直在有意保持自己的英语水平，所以阅读这块对我来说不是特别大的问题。&#xA;当时用的方法就是在少数派英语学习指南中看到的一种辅助精度法，但是根据我的情况进行了一点改进。我通常是找上一周的一些杂志，比如The Economists这样的，专门将其中的最精华部分，也就是每本开始的Leaders部分，大概有个5-6篇文章。然后把这些排好版打印出来，每篇文章一般是读3遍：第一遍主要浏览大意，基本搞懂70%左右的文章内容，并且顺手把一些不认识的单词标出来；第二遍进一步把之前没有搞懂的地方精读完成，把一些写的很好的句子和段落标记出来；第三遍就是更高层次的阅读，尽量用自己的话把每一段的大意写在边上，从头到尾顺下来。最后再从头到尾整理一下文章结构，脑子里根据刚才写的每段大意和理解的意思自动生成这篇文章的行文结构。这样一篇基本上就读透了。然后下一天继续。&#xA;非常巧妙的是，这个方法跟我后来对雅思阅读的整体理解非常类似。在做完了大量的雅思阅读训练以后，发现了每篇阅读当中的一些更深层次的套路。一些普通的套路我就不再赘述，可以直接去《阅读真经总纲》里面找。&#xA;我总结一般的阅读有三种题型：&#xA;细节题 概括题 结构题 细节题就是常见的T/F/NG，还有选择题。这种题100%能在文中找出来，读就完了。主要就看阅读量和速度能不能跟上。&#xA;概括题一般是每段的大意选择题，概括题目等。这种目标也比较明确，针对某一个段或者整篇文章的开头结尾中间这种看就可以。&#xA;结构题我认为是最难的，还有很多结构题是跟概括题结合在一起的，比如一些转写的填空题（直接把全篇概括让你填空），还有那种在表格里的大意选择题，这是我错误率最高的一种题。这种题需要大量的阅读，以及很好的定位能力，因为很难按照从头到尾的顺序去处理了。我认为的一个最主要方法就是多练，然后就是我上面提到的要对每篇文章有框架思维。经过一遍阅读后要尽量形成这篇文章的整体组织结构，这样就能在出现问你这个内容的同时快速定位，肯定不能精确定位，但也能够定位个大概，在附近2-3段里面选择。这样要比在全篇找容易的多。&#xA;不要大量做题。没有必要把剑雅的题都刷完再上考场。你做题的过程本质上是一个训练的过程，真正提升的部分是在你做题后发现错题，并想办法改进的过程。一直盲目做题只能让你巩固当前的分数水平，并且让自己很累，给自己一种努力的错觉。&#xA;每次做题尽量刷完一套。尤其是机考，在网站上练习的时候尽量一口气做完，因为一共也才整整一小时，这个时间肯定是能挤出来的。碎片做题很难整体把握阅读的节奏。&#xA;放一张当时做题的记录，感觉整体上剑雅的难度跟真题相比还是非常准确的。所以如果自己做的时候出现了问题，一定不要想考试的时候能发挥好，基本上差不多的。赶紧找方法，再练习，找自己的正反馈。&#xA;听力 # 听力在最后的考试里面感觉要比练习的时候难，不知道跟我的发挥状态有没有关系。到最后也就只有8，算是整个练习过程中分数比较低的水平了。&#xA;我在做听力的时候发现不要专注在题目本身，因为雅思是个很科学的考试，它考你听力主要还是要考你在以后国外的真实场景中能不能听到，能不能听懂，而不是做这几个破题。千万别用老钟那套备考思维往里面带。我感觉可以放70%以上的注意力在听文本，30%以下的注意力在题目上。在真正开始放声音前把题目都看完，标记完。在开始放以后，切换大部分的注意力在听这件事本身上，只需要同时关注当前到哪题了，catch up进度就行。这样即使你立刻没有选出答案，大脑里也会有之前听这段对话的印象，等到这个section录音放完，还有很多时间可以思考正确答案选哪个。同时也能达到听到哪看到哪，不在某一个题上浪费大量时间。&#xA;口语 # 所有的备考相关的中文资源or中国老师or中国人讲的视频都不要看了。 考的时候根本没时间想，所以切记一定不要背题！！！！！！考官一眼就能看出来。 口语有四个评分项，其中发音，词汇，语法是三个能短期内提升不少的，流利程度可能得看平时的积累和语感，但影响不大，这三个练好也能提0.5-1分了。 平时可以试着做一下自己的积累，就跟我附上的那个一样，这是我当时积累词和搭配用的表格。看别人说或者剧里面的好词好句都摘下来。目的不是都把他们背下来，目的是为了能在你说的过程中想起来然后插进去这么一两个高级搭配，整体能改善不少。 不要过多看题库。因为视频连线一开始就很容易大脑放空，我之前准备的时候主要是自己把本季的题都过一遍，主要是聊天能力，看自己有没有的可说。然后再想怎么丰富回答的层次，尤其是Part2和Part3. Part1:&#xA;这一部分100%属于聊天内容，每一问回答3句左右就行，再长的话遇到poker-face考官就直接打断你，我就这样了。这一Part主要就是看你回答的流畅度，因为都是简单的问题，不用在意回答的深度，就是聊天。&#xA;我准备的方式就是打开一个mock视频，看他问啥我就自己blabla说一堆，然后放视频，看看人家怎么回答的，最后还会有一个考官的点评和意见，这个时候可以想想自己说的问题，然后把他提到的好词好句积累下来。然后把回答的不好的问题也记下来。&#xA;Part2:&#xA;这块其实就是我说的自言自语的能力。我就属于自己话唠那种，最后2min直接都超时被打断。这块我建议考前可以不用练太多，积累自己想说话的那种感觉很重要，就算是编也得给它编到2min。&#xA;可以设定几个特殊的场景。比如我当时准备的就是学校的瑞幸，如果他问最近发生的一件有意义的事，你就说这个事是在我买咖啡的时候遇到了同学，我们俩聊天喝咖啡blabla就能续下去了；如果他问一个你努力实现的目标，你就说为了学习一个东西，早上很早学校其他地方都没开，自己来到了咖啡馆，很早就开始学习，然后很有氛围blabla。&#xA;虽然题你不能准备，也不能背，但是这些预设的场景能帮你快速开始说话，而且关键的是有细节，他们着重会听你讲故事里面的细节。我感觉可以设3个这样的场景，比如一个瑞，一个麦麦再来一个图书馆。可以提前积累一些你准备的场景里的高级词，比如你说跟同学在一起吃麦乐鸡（Chicken McNuggets）很开心，或者自己迷茫的时候去吃这个麦乐鸡。这些词就让考官觉得你很强。&#xA;Part3:&#xA;其实就是雅思大作文Part2。这部分前期不用单独准备，按照Simon的那个构思的流程学习完，然后让自己能更快地想到观点，想到接下来的论点，然后在脑子里串起来，这样就可以了。不需要很高级的词，主要是说的连贯，逻辑通顺，而且对错甚至也没关系，他们其实不关心你这个题答的是否正确，只要不跑题怎么说都行。但你一定要自己敢说，说的自洽就完全ok了。&#xA;Tips：&#xA;看剧！提前沉浸到这个英语环境里，尽量考前每天都要看，不用管别的，就是看的开心就行。我考试当天吃早饭还在看生活大爆炸。&#xA;建议多积累一些口语化的词，比如you know，about that这种，能给自己思考的缓冲时间，同时考官不会觉得你卡壳了。&#xA;定期自己模考。方法就是打开一个视频，他问一个问题你就回答同时用手机录音，然后自己听。就会慢慢发现问题在哪，然后去进步。&#xA;一定要根据Band Description评分标准去准备和提高，其他所有的解读其实都没有下面这个表有用。&#xA;考前可以找一些真人聊聊天，你得亲自感受一下这个语境。因为考试的时候真的问的飞快，脑子和嘴都得跟得上才行。&#xA;一些资源： Mock口语测试视频： https://www.youtube.com/@IELTSDaily 我当时基本上都是看的这个，非常非常非常帮助。就是说的太慢了+考官太温柔，考试的时候完全相反 英国佬的细节教学： https://www.youtube.com/@EnglishSpeakingSuccess 很多词汇积累，考试注意事项等等都有，也是非常有帮助 Pronunciation专项练习： https://www.youtube.com/@rachelsenglish/search?query=pronunciation 一些非常难的发音都在这里练，每天坚持十分钟能有很大提高。比如th这种音，练好了对以后去国外也一直会有帮助。 写作 # 优先看Simon的书！！！！！ 这个书里面写的都是非常精华的内容，上了考场根本来不及细想，只能提前把里面的很多方法提前训练好。还有一个第二版，现在还没有电子版，非常推荐去买个纸质版，基本上有这一本纸质材料就足够了。 把两个大小作文的范文pdf打印出来，然后每天去看看这些范文咋写的，尽量下次考试前看完一遍。培养一下它要求的写作高分的感觉，这样写起来语感和节奏会越来越好，时间分配也会提高。 针对Simon书里面提到的几个点专项练习，我感觉如果目标是我这种6.5或7其实没必要积累很多的大词，主要还是整体的逻辑、衔接和流畅度。所以我比较推荐的是这个书里面的观点练习，有一个section是专门让你自己想观点，然后分段，最后照着他给出的范文想法去纠正自己的思路，大小作文都这样。我当时就是训练了一段时间这个然后能很快很准的想到论点，且跑题几率会大大降低。 最后是看写作真经总纲。我觉得这里面写的没有Simon这个英国佬写的有针对性，方法可以直接用Simon的，但这个书里有很多搭配和句型。比如小作文的很多数字上升下降的描写，很有参考价值。考前一天背一背都管用。 大作文平时主要是在练的时候尽量总结一下自己思考的方法，比如大作文我想的就是要找更大面的几个视角更容易下笔（环境保护、经济发展blabla），而且错也错不到哪去；每个段有不同的论证方法：比如中间两个主要论证的段，一段用平行论证，另一段用递进论证，这样写起来很容易有逻辑性和语言丰富度；一定要举例子，而且至少每个段要有一个，他们还是很看重这样的论证方法的，不要总是车轱辘话解释观点。</description>
    </item>
    <item>
      <title>YOLOv5_HNet</title>
      <link>https://caesaryangs.github.io/blogs/YOLOv5_HNet/</link>
      <pubDate>Tue, 30 May 2023 10:40:58 +0800</pubDate>
      <guid>https://caesaryangs.github.io/blogs/YOLOv5_HNet/</guid>
      <description>YOLOv5_HNet # A YOLOv5 modification net for key objects on private helmet dataset CaesarYangs/YOLOv5_HNet&#xA;中文 | EN&#xA;本项目的主要目标是利用一些已有的论文方案，结合我自己的一些思考和改动，实现对于私人数据集上的安全帽检测的效果提升。&#xA;效果提升的标准定义：&#xA;准确率 速度（检测速度） 模型大小（所需算力） 本项目所基于的数据集种类、数量都极其复杂，涉及多场景的情况处理。也在这些珍贵的数据集上进行了大量的实验及必须的消融实验。&#xA;tips：本项目适合完全了解YOLOv5及以上版本源码的同学阅读及使用。建议可以先通过 GitHub - HuKai97/yolov5-5.x-annotations: 一个基于yolov5-5.0的中文注释版本！ HuKai大神之前做过的这个非常详尽的标注版本进行整体源码和必要细节阅读理解。也非常感谢这个项目让我在早期能够快速吃透并上手修改工作。&#xA;Solution1: 改变Anchor，添加小目标检测层 # 思路：&#xA;根据对数据集的分析，发现更多的情况是监控拍摄到的图片，结果就是目标的距离很远，物体较小。自然想到的第一个方向就是针对这些小目标着重优化。&#xA;改进要点：&#xA;添加一层新的小目标Anchor。 [5, 6, 8, 14, 15, 11] #new_anchor 修改FPN结构，增加层数。&#xA;在原来5层FPN的基础上增加两层：分别是对dim=512及dim=256维度特征的再次提取，经过再次上采样提取过的最后一层连接到检测头，替换原来的单层提取/上采。&#xA;利用kmeans，针对特定数据集情况做anchor重新聚类&#xA;本质上是针对后期YOLOv5模型自带的anchor回归预测的一个手动验证，看经过我解耦后的单独anchor重聚类算法能否对基础的YOLO模型有所提升，以验证这个方法对于安全帽检测这个特定领域的有效性。&#xA;训练结果：&#xA;type model parameters FLOPs pt_size mAP@0.5 mAP@0.5~0.95 FPS Power Plant YOLOv5s_baseline 7.06M 16.5G 14.3MB 0.75 0.484 30.5 Power Plant little_obj_anchor_fpn 50.9M 192.</description>
    </item>
    <item>
      <title>RegEx101 正则入门笔记</title>
      <link>https://caesaryangs.github.io/blogs/regex101/</link>
      <pubDate>Thu, 10 Nov 2022 17:40:58 +0800</pubDate>
      <guid>https://caesaryangs.github.io/blogs/regex101/</guid>
      <description>RegEx101 正则入门笔记 # 正则表达式的两种基本用途：搜索和替换。给定一个正则表达式，它要么匹配一些文本（进行一次搜索)，要么匹配并替换一些文本（进行一次替换)。&#xA;非常好的在线正则表达式匹配检测工具： regex101: build, test, and debug regex 学习与工作上都非常好用 匹配单个字符 # 正则表达式，也被称为模式，其实是一些由字符构成的字符串。这些字符可以是字面字符（普通文本)或元字符（有特殊含义的字符)。&#xA;普通文本&#xA;正则表达式是区分大小写的。 任意字符&#xA;注意正则表达式使用字符串内容来匹配模式。匹配到的未必总是整个字符串，也可能是与某个模式相匹配的子串。在上面的例子里，我们使用的正则表达式并不能匹配完整的文件名， 而是只匹配了其中一部分。如果你需要把某个正则表达式的匹配结果传递到其他代码或应用程序里做进一步处理，就必须记住这种差异。&#xA;特殊字符&#xA;. 表示匹配任意单个字符。 \ 是一个元字符（metacharacter，表示这个字符有特殊含义，代表的不是字符本身）。 .a.\. 结果：na1.xls 第一个.匹配a前面的单个字符；第二个.匹配a后面的单个字符；\.作为转义匹配真正的.符号 匹配一组字符 # 在正则表达式里，我们可以使用元字符 [ 和 ] 来定义一个字符集合。在使用 [ 和 ] 定义的字符集合里，出现在 [ 和 ] 之间的所有字符都是该集合的组成部分，必须匹配其中某个成员（但并非全部)。&#xA;此处的 [ 和 ] 代表着强制匹配其中的元素。只有存在才能够匹配成功。 [ 和 ] 不匹配任何字符，它们只负责定义一个字符集合。接下来，再由真正的 regex 匹配部分参与匹配操作。 使用 [ 和 ] 的字符集合在不需要区分字母大小写（或是只需要匹配某个特定部分）的搜索操作里比较常见。 利用字符集合区间&#xA;- 连字符，一种特殊的元字符。可以用这种连字符来定义字符区间。 一些合法的字符区间：&#xA;[a-z]：匹配 a 到 z 所有小写字母 [A-Z]：匹配 A 到 Z 所有大写字母 [A-z]：匹配从 ASCⅡ字符 A 到 ASCIⅡ字符 z 的所有字母。这个模式一般不常用，因为它还包含 [ 和 ^ 等在 ASCⅡ字符表里排列在 Z 和 a 之间的字符。 字符区间的首、尾字符可以是 ASCⅡ字符表里的任意字符。但在实际工作中，最常用的字符区间还是数字字符区间和字母字符区间。</description>
    </item>
    <item>
      <title>在 Apple Silicon 上配置 PyQt5 以及 LabelImg</title>
      <link>https://caesaryangs.github.io/blogs/PyQT5_in_ARM_mac/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/blogs/PyQT5_in_ARM_mac/</guid>
      <description>在 Apple Silicon 上配置 PyQt5 以及 LabelImg # Mac M1 芯片安装 labelImg - 简书&#xA;最近突然需要继续做一些数据标注的任务，下载好了之前经常用的 Labelme 后发现输出的标记文件是 json 格式的，不符合项目规范。发现 labelImg 这款标注软件刚好是输出 xml 作为标记文件的，十分合适。&#xA;但是由于最近刚刚换了电脑，时隔一年的试用后终于把我的主力机换到了 Apple Silicon 平台上来，随之而来的就是这一系列的配置问题。&#xA;GitHub - heartexlabs/labelImg&#xA;Q-问题 # 官方的安装文档向来是非常重要的部分。主要是在执行 pip3 install pyqt5 lxml # Install qt and lxml by pip 的时候报错，直接 error。&#xA;在这一部分可能会有很多的人会遇到与我相似的问题，故将整个问题的出现与操作列出。&#xA;一般到这里复制错误信息到 Google 会发现有一部分用户也遇到了这类问题，主要的原因就是 arm64 架构和此处的 PyQt5 不兼容所导致的。&#xA;此时可以尝试利用 homebrew 中更新的命令：brew install pyqt@5 进行安装。&#xA;并且可以看到这个命令安装的 PyQt5 已经是适配 arm64 架构的版本了。&#xA;但此时如果继续按照官方文档走下去安装，会发现在安装labelimg的时候依旧会报错。并且所报的错误与之前几乎完全相同。&#xA;此时就可以发现，整个的错误原因都是来源于PyQt5没有正确导入造成的。虽然已经在本地安装好相应的包了，但是并没有导入到对应的Python环境当中，导致无法正确使用。如果在此时尝试直接下载GitHub的源码编译安装的话，会非常直接的发现报错内容为：PyQt5 import error</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/blogs/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/blogs/test/</guid>
      <description> HHHHHH # </description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/1-Linux-UNIX%E6%A6%82%E8%AE%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/1-Linux-UNIX%E6%A6%82%E8%AE%BA/</guid>
      <description>操作系统相关概念 # 什么是操作系统&#xA;最基础的系统软件&#xA;计算机软硬件资源的管理与控制 软件涵盖程序、文档、数据 硬件涵盖处理器、内存、外存及各类设备 硬件资源及管理操作抽象示例&#xA;磁盘操作：把数据处理结果写到磁盘，也就是从内存拷贝信息到磁盘 分解动作： 内存数据块拷贝到设备缓冲区 load(addrBlock, length, bufDev); 磁盘设备执行寻道操作 seek(dev, trackNo); 设备缓冲区写出到指定扇区 out(bufDev, sectorNo); void write(char *addrBlock, int length, int dev, int trackNo, int sectorNo){ load(addrBlock, length, bufDev); seek(dev, trackNo); out(bufDev, sectorNo)； } write(addrBlock, 8, dev, 21532); fprintf(fd, &amp;#34;%d&amp;#34;, data); + fseek(fd, offset, whence); 什么是操作系统&#xA;最基础的系统软件 计算机软硬件资源的管理与控制 软件涵盖程序、文档、数据 硬件涵盖处理器、内存、外存及各类设备 用户使用计算机的基本操作环境 命令接口、图形化用户接口 各类程序运行的基础环境 程序接口：系统调用接口、函数库 操作系统内核&#xA;实现操作系统的核心功能 计算机系统的启动初始化及电源管控 处理器、内存、外设等硬件的管理与控制 文件系统的支持 操作系统的基本特征及支撑机制&#xA;并发 注意与并行概念的区别 进程、线程、同步互斥及通信机制 共享 硬件共享：处理器、内存、外设 软件共享：程序、数据 共享与保护机制结伴而行 虚拟与异步 操作系统发展历程 # 单道批处理系统 监督程序（FMS Fortran Monitor System 、IBSYS） 多道批处理系统 多道程序设计技术 分时操作系统 CTSS（Compatible Time Sharing System） 麻省理工学院（1962 年） 时钟中断、时间片轮转调度、交换技术 实时操作系统 实时调度算法、可靠性 嵌入式操作系统 软硬件合体、微型化、专业化 网络操作系统 网络传输功能支持 分布式操作系统、网格操作系统 云操作系统、集群操作系统 UNIX/Linux 操作命令入门 # UNIX/Linux 系统启动及配置</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/2-Linux-Shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/2-Linux-Shell/</guid>
      <description>最简单 Shell 程序解析及运行 # #!/bin/sh 是指此脚本使用/bin/sh 来解释执行，#!是特殊的表示符，其后面跟的是此解释此脚本的 shell 的路径。&#xA;Shell 程序第一行规范建议&#xA;建议写法 #! /bin/sh 强烈不建议写法—— #!型注释 #! 其它注释内容 两种运行方式 ./ sh Shell 程序调试方式 # 命令 选项 功能说明 sh -n 程序名 纯粹性 解释分析 解释但不执行命令（用于检查程序语法错误） sh -x 程序名 显示替换结果程序并执行 在变量替换之后、执行命令之前，显示程序的每一有效行（非空且非注释行） sh -v 程序名 显示原始程序并执行 在执行之前，按输入的原样显示输出程序中所有各行（包括空行、注释行） set -x 打开（命令）回显 跟踪程序的执行（主要用于 Shell 程序中） set +x 关闭（命令）回显 关闭跟踪功能（主要用于 Shell 程序中） 局部变量应用编程 # Shell 变量赋值与引用&#xA;Shell 变量赋值 &amp;lt;变量名&amp;gt;=&amp;lt;初始值&amp;gt; 譬如：fileName=&amp;ldquo;zgsFile.txt&amp;rdquo; 注意等号两边不能有空格！！！ Shell 变量引用 $&amp;lt;变量名&amp;gt; &amp;quot;$fileName&amp;quot;、“$fileName”、‘$fileName’ 或任何引号外 $fileName 有效 &#39;$fileName&#39; 无效（$ 亦按普通字符处理） $fileName 比较特殊（按命令串处理） 清理变量 unset varName 空格在linux中时作为一个很典型的分隔符，比如string1=this is astring，这样执行就会报错。为了避免这个问题，因此就产生了单引号和双引号。他们的区别在于，单引号将剥夺其中的所有字符的特殊含义，而双引号中的&amp;#39;$&amp;#39;（参数替换）和&amp;#39;`&amp;#39;（命令替换）是例外。所以，两者基本上没有什么区别，除非在内容中遇到了参数替换符$和命令替换符`。 Shell 变量分类</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/3-Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/3-Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <description>Linux 内核编程及编译 # Linux 内核所用编程语言&#xA;C 语言 汇编语言 Linux 内核代码已超 2 千万行、接近 3 千万行&#xA;Linux 内核编译常用工具&#xA;GCC（GNU Compiler Collection） GCC 不仅支持 C 语言，还扩展支持了 C++、Java、Go 等语言 GCC 支持多种不同的硬件平台，如 x86、ARM、MIPS、LoongArch 等体系结构 GCC 编译流程 Linux 内核编程技巧 # 语句表达式 # 语句表达式（即括号内的复合语句）&#xA;宏构造利器：语句表达式 - Linux内核中语句表达式的使用 - 嵌入式C语言自我修养 | 宅学部落&#xA;旨在使宏定义变得更加安全 #define max(x,y) ((x)&amp;gt;(y)?(x):(y)) #基于整型数据的改进 #define max(x,y) \ ({ int _x=(x), _y=(y); _x &amp;gt; _y ? _x : _y; }) # 基于未知数据类型的改进 #define max(x, y) ({&#x9;\ typeof(x) _x = (x);&#x9;\ typeof(y) _y = (y);&#x9;\ (void) (&amp;amp;_x == &amp;amp;_y);&#x9;\ _x &amp;gt; _y ?</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/4-Linux%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/4-Linux%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>Linux 进程/线程管理控制 # 进程与线程 # 为什么要引入进程？&#xA;单道环境 =&amp;gt; 多道环境 单道环境及计算机系统各类资源的利用率 多道环境及计算机系统资源利用率的提高 计算机不同部件成本与运行速度的差异性、计算机处理任务本身所需操作部件的差异性以及由此导致的计算机不同部件即资源利用的不平衡性 通过多道程序的并发执行（支持） 实现计算机系统资源利用效率的最大化 引入进程概念（由特定的程序及相关联的进程控制块所组成）来描述并发执行程序的动态运行过程，解决由此引发的资源共享问题 进程及其与程序之间的区别与联系?&#xA;程序的动态执行过程 系统资源分配的独立单位 进程标识符、进程控制块 与程序之间的区别（动态/静态性、生命周期、是否支持并发、组成） 进程控制块中的内容？&#xA;标识符 调度信息、控制信息 资源信息 为什么要引入线程？&#xA;进程并发执行基础（资源拥有 + 调度分派） 进程创建、切换和撤销等操作时空开销较大 进程并发执行程度及进程间通信效率受限 事务处理软件、数据库处理软件、窗口系统及操作系统自身对系统并发程度进一步提高的客观需求，而且有关需求呈现出多项任务处理同组数据（存储资源）的特征 解决方案：（非处理器）资源拥有与（处理器）调度分派两类特性的分离 线程与进程间的区别与联系？&#xA;轻型实体及共享进程资源 独立调度和分派的基本单位 创建、撤销、切换等系统开销 地址空间共享及通信效率 系统并发执行程度大大提高 UNIX/Linux 进程 # UNIX 进程&#xA;进程映像的概念 处理器映像 + 内存映像 + 进程控制块 + 程序（用户程序 内核程序） 数据段（静态/全局数据）+ 代码段 + 工作区（栈 + 堆） proc 结构 user 结构 共享代码段 proc 结构体数组&#xA;struct proc { char p_stat;&#x9;/*进程状态*/ char p_flag;&#x9;/*进程特征，含SLOAD标志位*/ char p_pri;&#x9;/*进程优先数*/ char p_uid;&#x9;/*用户标识符*/ char p_time;&#x9;/*驻留时间*/ char p_cpu;&#x9;/*占用CPU时间*/ char p_nice;&#x9;/*计算优先数时用，[-20,19]*/ int p_pid;&#x9;/*进程标识符*/ int p_ppid;&#x9;/*父进程标识符*/ int p_addr;&#x9;/*进程映像数据分部地址，由此可以找到user结构*/ int p_size;&#x9;/*进程映像数据分部大小*/ int p_wchan;&#x9;/*等待原因*/ int p_textp;&#x9;/*代码段所在的共享段表项text的地址*/ char p_sig;&#x9;/*软中断号*/ int p_ttyp;&#x9;/*控制终端tty结构的地址*/ }proc[NPROC]; UNIX 进程 user 结构体</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/5-Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/5-Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description>文件及文件系统的引入 # 信息存储问题及要求&#xA;进程运行时内存空间有相应一定量的信息 进程终止时，有关信息将随之消失 一方面有关信息受到内存空间大小的限制 另一方面部分信息需要长久甚至永久保存 常常会有多个进程需要存取同样的信息 信息应当独立于进程而存在 信息存储要求 能够存储大量信息 使用信息的进程终止时，有关信息仍旧存在 支持多个进程并发存取有关信息 信息存储解决方案&#xA;把信息以某种单元即文件的形式存储在磁盘或其他外部介质上 文件是一个具有名字的存储在磁盘上的一组相关信息的集合体，是磁盘的最小逻辑分配单位 文件系统是操作系统中负责管理和存取文件信息的软件机构 管理文件所需的数据结构 实现文件管理的系统程序 文件操作相关系统调用 ls 命令及文件类型&#xA;ls -l hello.c -rw-rw-r-- 1 zgs zgs 561 Aug 24 07:31 hello.c d 目录 l 符号链接文件 s 套接字文件 b 块设备文件 c 字符设备文件 p 命名管道文件 - 普通文件 硬链接和软链接文件共享&#xA;建立 DataFile.txt 的硬链接文件 ln DataFile.txt DataFileYLJw 建立 DataFile.txt 的软链接文件 ln -s DataFile.txt DataFileRLJ 删除原数据文件 DataFile.txt 硬连接依旧可行 软连接无法继续输出文件内容 lrwxrwxrwx 1 zhaigaoshou2018 zhaigaoshou2018 12 Nov 6 05:49 DataFileRLJ -&amp;gt; DataFile.</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/6-Linux%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/6-Linux%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</guid>
      <description>设备管理概述 # 最复杂、最多样化的操作系统资源管理模块&#xA;设备并行操作是提高设备利用率关键所在&#xA;依赖于通道和中断机制、设备物理特性的支持 功能范畴&#xA;对计算机系统中（除处理器和内存之外的）外部设备的管理（选择与分配输入输出设备） 实现多任务、多进程对多种设备的共享 对设备相关数据传输过程的控制 实现数据的高效传输（设备与处理器/设备并行） 设备分类&#xA;存储设备（块设备） 计算机用来存储文件信息的设备，如磁/光盘/带 输入输出设备（字符设备） 输入设备，如键盘、鼠标、扫描仪 输出设备，如显示器、打印机、绘图仪 输入输出设备，如电传打字机 网络设备（通过套接字进行数据交换） 在 TCP/IP 协议网络通信中，套接字使用 IP 地址（32 位）和端口号（16 位）共计 48 位来唯一标识具有某个 IP 地址的计算机及其某个端口 设备管理模块功能&#xA;提供进程使用设备的接口 一般为文件系统及文件操作相关系统调用 实施设备的分配与回收 实现设备与设备、设备与处理器之间的并行 依赖于硬件提供的输入输出控制方式 采取有效措施解决处理器与设备的速度差异矛盾、平衡计算机系统的输入输出负荷、提高设备的输入输出效率 缓冲技术、提前读、延迟写、异步写 设备独立性&#xA;指用户在程序中所使用的设备与实际使用的设备无关 操作系统为同类设备设置一个逻辑设备名 当用户以逻辑设备名提出设备请求时，由操作系统的设备管理模块将逻辑设备名转化为具体的物理设备、实现物理设备的分配 优点 方便了用户 提高了系统效率 缓冲管理 # 缓冲及目的&#xA;缓冲是在不同速度的部件之间传输信息时常用来平滑传输过程的技术手段 通常为内存缓冲区，用于暂存输入/输出数据 目的 解决设备与处理器之间以及设备与设备之间的速度不匹配的问题 解决系统中输入输出负荷的不均衡问题 有效减少输入输出（中断）次数，从而提高输入输出速度 分为单缓冲、双缓冲、循环缓冲和缓冲池 缓冲池&#xA;三类缓冲区队列：空缓冲区队列、输入缓冲区队列、输出缓冲区队列 四类工作缓冲区：【收容/提取】【输入/输出】的工作缓冲区 缓冲池管理要旨 空缓冲区的分配与回收 输入/输出设备的输入/输出缓冲区队列管理 缓冲区与进程数据块之间的信息交换 采用内存块拷贝实现机制 缓冲区与设备（内存数据块与设备物理块）之间的信息交换（即设备输入输出） 基于中断的实现方式 中断服务程序实现设备的输入请求处理 对于设备输入过程而言，若还有数据输入请求，则申请空闲缓冲区、启动设备执行输入操作并将所输入的数据暂存到空闲缓冲区中，然后把该装满输入数据的缓冲区挂到设备的输入缓冲区队列上供用户进程拷贝和访问读取；若没有数据输入请求则通知设备结束输入操作，并将该设备重新分配给其他进程 中断服务程序实现设备的输出请求处理 对于设备输出过程而言，循环：若还有数据输出请求，则申请空闲缓冲区把所输出的数据拷贝和暂存其中并挂到设备的输出缓冲区队列上 待设备空闲时，系统从输出缓冲区队列队首缓冲区提取数据输出到设备上，然后把该缓冲区放回空缓冲区队列，循环执行这一过程直到输出缓冲区队列为空 设备分配 # 计算机系统中进程数总是多于设备数及由此导致的设备竞争的客观现实 设备分配须方便用户并有效规避死锁问题 设备分配方式 独占式分配及独占式设备（譬如打印机、绘图仪） 共享式分配及共享式设备（譬如磁盘） 虚拟式分配及假脱机技术（在共享式设备上实现独占式设备的虚拟和共享使用），可以提高输入输出速度、改善设备利用率和系统吞吐量，提高了进程的并发执行程度和执行效率 假脱机技术</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/7-Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Advanced-OS/class-notes/7-Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>计算机系统性能优化理论 # 描述了实际项目中性能优化的五个方面&#xA;Profile——针对优化目标进行性能测试摸底&#xA;不同应用场景不同的采样工具（perf、VTurn） Analyze——分析性能的瓶颈和焦点&#xA;Root——刨根问底，找出问题的根本原因&#xA;Optimize——设法突破瓶颈和优化性能&#xA;Test——测试验证性能优化成效&#xA;上述过程是一个迭代循环过程&#xA;printk——简单强大调试工具 # 内核提供的格式化显示输出函数 [环形缓冲机制]&#xA;输出级别——在终端或串口输出的判断依据&#xA;输出级别不低于控制台输出级别的消息将会在控制台显示输出 系统运行时输出级别的查看与修改&#xA;cat /proc/sys/kernel/printk 15&#x9;4&#x9;1&#x9;7 分别对应控制台输出级别、消息默认输出级别、控制台输出级别最小取值和控制台默认输出级别 #echo 7 &amp;gt; /proc/sys/kernel/printk $ cat /proc/sys/kernel/printk 7&#x9;4&#x9;1&#x9;7 函数名及代码行号的显示输出 printk(&amp;quot;FunctionName[%s] LineNo[%d]\n&amp;quot;, __func__, __LINE__); debugfs 文件系统及动态输出 # 动态输出（Dynamic printk）&#xA;由系统维护者动态选择打开内核输出 动态输出对应于内核代码中有关函数 pr_debug() 和 dev_debug() 的输出信息 可指定内核子系统或内核模块 要求在内核编译配置时打开宏 CONFIG_DYNAMIC_DEBUG 需要系统挂载 debugfs 文件系统，并在其 control 节点加以查看，具体记录了系统中所有使用动态输入输出技术的文件名路径、输出所在行号、模块名字以及要打印的信息描述 cat/more + grep 查看方式 proc 文件系统（系统及进程信息） # 内核和内核模块向用户空间发送消息的机制&#xA;方便用户或用户进程访问内核数据结构以获取进程或系统的有关信息 本质上并非真正意义的文件系统，存在于内存，而不占用磁盘空间</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/0-Asymptopic-Analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/0-Asymptopic-Analysis/</guid>
      <description>算法复杂度 ─ 直观定义&#xA;算法复杂度是算法运行所需要的计算机资源的量，需要时间资源的量称为时 间复杂性，需要的空间资源的量称为 空间复杂性&#xA;时间复杂度和空间复杂度是只依赖于算法求解的问题规模和算法输入的函数 𝑁、𝐼 分别表示算法求解的问题规模和算法输入，则算法的时间复杂度𝑇和空 间复杂度𝑆可以分别表示为: 𝑇 = 𝑇(𝑁, 𝐼) 𝑆 = 𝑆(𝑁, 𝐼) 算法复杂度分析 ─ 指令抽象&#xA;T(N, I) 表示特定算法在一台抽象的计算机上运行所需要的时间&#xA;K 个元运算，O1, O2, &amp;hellip;, Ok, 运行一次所需时间为 t1, t2, &amp;hellip;, tk; 统计 Oi 的调用次数为 ei，ei = ei(N, I); 因此，T(N, I) = ∑tiei(N, I)。 归纳逻辑: 从个别到一般 T(N) 的表达式比较复杂，需合理的简化!&#xA;对于算法 A 的复杂度函数𝑇(𝑁)，如果存在𝑇′(𝑁) ，使得当𝑁 → ∞时有 (𝑇𝑁 −𝑇′(𝑁))⁄𝑇(𝑁)→0，那么就称𝑇′(𝑁) 为算法 A 当𝑁→∞的渐近复杂性&#xA;𝑇′(𝑁) 是𝑇(𝑁) 略去低阶项所留下的主项，表达简单 如果两个算法的渐近复杂性的阶不相同，那么只要确定出各自的阶就可以判断哪一个算法效率高 阶跟𝑇′(𝑁) 中的常数因子没有关系，𝑇′(𝑁) 可进一步简化，省略常数因子 时间复杂度的记号包括:O Ω Θ</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/1-E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/1-E/</guid>
      <description>Theory&amp;amp;Thinkings # 为什么要用枚举？ 解准确且全面 实现简单，通过循环或递归实现 执行效率提升空间通常较大 具体方法：&#xA;枚举对象 枚举过程 验证解 不是所有问题都有巧妙的解决方案，没有想到就要进一步做优化，对于枚举来说：压缩枚举空间。&#xA;枚举算法&#xA;也称之为穷举算法，就是按照问题本身的性质，一 一列举出该问题所有可能的解， 并在列举的过程中，逐一检验每个可能解是否是问题的真正解。若是则采纳这个解; 否则抛弃它。&#xA;不能遗漏，否则可能导致结果不正确 不要重复，否则可能导致效率比较低 枚举算法设计步骤&#xA;确定枚举对象 枚举对象也可以理解为是问题解的表达形式，一般需要 用若干参数 (p1, p2, &amp;hellip;&amp;hellip;, pk) 来描述 参数之间需要相互独立，而且参数数目越少，问题解搜索空间的维度也相应地小 每个参数的取值范围越小，问题解的搜索空间也越小 优化模型 针对问题特征，优化对象模型 逐一列举可能解 根据枚举对象的参数构造循环 (也可以递归)，一一 列举其表达式的每一种取值情况。 优化过程 针对对象特征，优化列举和验证过程 逐一验证可能解 根据问题解的要求，一一验证枚举对象表达式的每一 个取值，如果满足条件，则采纳它; 否则，抛弃之。 e.g.s # 数组配对 # 给你一个长度为n的数组A和一个正整数k，问从数组中任选两个数使其和是k的倍数，有多少种选法？对于数组 a1=1 , a2=2 , a3=2 而言： (a1,a2) 和 (a2,a1)被认为是同一种选法； (a1,a2) 和 (a1,a3)被认为是不同的选法。 朴素方法 枚举对象：𝑂𝑏𝑗(𝑎𝑖,𝑎𝑗),1≤ 𝑖 &amp;lt; 𝑗≤ 𝑛 逐一列举 逐一验证 存在问题：时间复杂度较高：𝑂(𝑛2) 如果问题规模较大，求解问题需要的时间也呈指数级别增长 尝试改进：如何减少问题空间？如何更加有效的枚举？ 利用桶思路，将原问题之间用 mod 运算降低到一个非常低的解空间中再进行枚举 枚举对象：𝑂𝑏𝑗(𝑎𝑖,𝑎𝑗),1≤ 𝑖 &amp;lt; 𝑗≤ 𝑛 逐一列举： 预处理： (𝑎𝑖 + 𝑎𝑗)%𝑘 = 0 逐一验证：(𝑎𝑖%𝑘 + 𝑎𝑗%𝑘)%𝑘 = 0 求解细节： 会变成两个单独数字的配对问题，存在两种情况 两个数字在同一桶内：组合数公式 两数字不在同一桶内：直接相乘，相当于组合公式 void work() { LL ans = 0; for (int i = 0; i &amp;lt; k; i++) { int j = (k - i) % k; if (j &amp;lt; i) break; // 避免重复 else if (j == i) // 0或者k/2 ans += 1LL * b[i] * (b[i] - 1) / 2; else ans += 1LL * b[i] * b[j]; } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; } 绳子切割问题 # 有N条绳子，它们的长度分别为𝐿_𝑖 (≤1000)。如果从它们中切割出 K 条长度相同的绳子，这K条绳子每条最长能有多长？答案保留到小数点后2位。 枚举法的典型应用</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/2-Divide-and-Conquer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/2-Divide-and-Conquer/</guid>
      <description>分治算法最重要的就是如何确定好划分方式，以及划分的构造&#xA;Theory&amp;amp;Thinkings # 分而治之 # 分解为性质相同的子问题，应该只是规模不同&#xA;如果性质不同怎么办？ 进行预处理，转化为性质相同的子问题 归并排序&#xA;分治的分：不同的划分方法&#xA;黑盒划分：归并排序，逆序对 白盒划分：快速排序 平衡子问题&#xA;减而治之&#xA;当分出的子问题是完全相同时，避免重复递归调用 直到某个子问题不用递归求解 直接舍弃或者使用 减是精髓 快速排序中的划分 partition非常重要&#xA;快速归并排序 #enlighten&#xA;思考方法：先把题目降维，然后进行处理&#xA;递归三要素：&#xA;递归终止条件：递归需要一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递归，防止无限递归 终止处理办法：在递归的临界点对应一种简单的情景，这种情景下，应当直接给出问题的解决方案 递归处理方法：递归问题必须可以分解为若干个规模较小、与原问题 形式相同 的子问题，这些子问题可以用 相同的思路 来解决，并且合并得到原问题答案。 递归与循环&#xA;递归也是一种特殊的迭代，但是在迭代前不知道还要迭代多少次 递归函数一定有参数，且参数会在迭代的过程中步步逼近某个值 递归函数中一定有处理终点，而这个点就是递归出口 递归 有去有回（回到之前的栈帧上） 也就是递归这两个字的含义 循环 有去无回 分治算法基本思想&#xA;分 — 将大规模的原问题分割成 k 个更小规模的 子问题，如果子问题的规模仍然不 够小，则再划分为 k 个“子 子”问题，如此递归地进行下去，直到子问题规模足够 小 (基础问题)，很容易求出其解为止。 治 — 求解规模足够小的基础问题。 合 — 将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上 逐步求出原来问题的解。 分治策略算法细分为三个阶段: Divide 、 Conquer 、 Combine 。 Divide 阶 段是把原问题分割成小问题， Conquer 阶段是递归处理流程， Combine 阶段 是运用小问题的答案合成出原问题的解答。</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/3-DP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/3-DP/</guid>
      <description>Theory&amp;amp;Thinkings # 重叠子问题&#xA;状态表示与递推方程 状态转移：状态转移方程&#xA;状态无后效性： 最优性原理：&#xA;找桥梁&#xA;找这个大的最优化问题如何由很多子问题组合而成&#xA;由易至难，自底向上&#xA;T：矩阵连乘积 最优子结构性质 用最外层的循环实现由易至难&#xA;最优子结构：问题的最优解包含其子问题的最优解 隐含了问题最优解和子问题最优解之间的一种递推关系 重叠子问题：对于每个子问题只会计算一次 动态规划算法设计步骤：&#xA;分析最优解性质，刻画最优子结构性质 确定状态表示和状态递推方程，递归地定义最优值 确定状态转移顺序，自底向上计算最优值 根据计算最优值时得到的信息，自顶向下构造最优解 循环变量一定是问题难易程度的量化指标&#xA;真实求解过程中的 DP 解决问题思路：&#xA;明确 dp 数组下标的含义 定义 base case 确定状态转移方程 DP 算法最重要的是状态（阶段）的寻找，状态转移方程和推理方式的确定&#xA;动态规划 (dynamic programming) 是运筹学的一个 分支，是求解决策过程 (decision process) 最优化的 数学方法。20 世纪 50 年代初美国数学家 R.E.Bellman 等 人在研究多阶段决策过程 (multistep decision process) 的优化问题时，提出了著名的最优化原理 (principle of optimality)，把多阶段过程转化为一 系列单阶段问题，利用各阶段之间的关系，逐个求解， 创立了解决这类过程优化问题的新方法—动态规划。&#xA;基本概念&#xA;状态和状态表示: 表示每个阶段开始时，问题或系统所处的客观状况。状态既是该 阶段的某个起点，又是前一个阶段的某个终点。通常一个阶段有若干个状态，每个状态用多元组𝑆(𝑝1, 𝑝2, &amp;hellip; , 𝑝𝑘) 表示，值域表示状态值，或者对应子问题的答案。 状态转移: 在动态规划的多阶段决策过程中，决策序列对应状态序列，每一次决策 对应一次状态转移，状态转移用递推方程来描述，称之为状态转移方程。 状态无后效性: 如果某个阶段状态给定后，则该阶段以后过程的发展不受该阶段以前 各阶段状态的影响。 最优性原理: 求解问题的一个最优策略序列的子策略序列总是最优的，则称该问题满足最优性原理。 构建原问题最优解与子问题最优解之间的关系</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/4-Greedy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/4-Greedy/</guid>
      <description>Method # 基本思想 # 贪心算法基本思想&#xA;贪心算法是一个分阶段决策过程，在每个局部阶段，贪心法都做出一个当前 最优的局部决策，并期望通过每次所做的局部最优决策产生一个全局最优解。&#xA;贪心算法类似于分治算法和动态规划，也是一种基于子问题思想的策略。&#xA;贪心算法求解步骤&#xA;分解，将原问题求解过程划分为连续的若干个决策阶段 决策，在每一个阶段依据贪心策略进行贪心决策，得到局部的最优解，并缩小待求解问题的规模 合并，将各个阶段的局部解合并为原问题的一个全局最优解 Greedy(C) { // C是问题的输入集合即候选集合 S = {}; // 初始解集合为空集 while (not Solution(S)) { // 集合S没有构成问题的一个可行解 x = Select(C); // 在候选集合C中做贪心决策 S = S + {x}; C = C - {Collection(x)}; // 减去一个与x关联的集合，缩小问题规模 } return S; } 候选集合 C 是构造问题的解 (包括最优解) 的对象集合 解集合 S 表示问题的解，它随着贪心选择的进行不断扩展，直到构成一个满足问题的完整解 选择函数 Select 是贪心策略的实现过程，这是贪心法的关键，它指出哪个候 选对象最有希望构成问题的最优解，选择函数通常和目标函数有关 正确性证明 # 数学归纳法&#xA;证明目标 ∀ 𝒏 𝒑(𝒏) 为真 / / n 的论域为正整数集合 证明框架 基础步骤: p(1) 为真 归纳步骤: 证明∀k(p(k) →p(k+1)) //对任意正整数 k, 给出 p(k)├ P(k+1) 的论证步骤 结论: 对任意正整数 n，p(n) 成立 交换论证法</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/5-Search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/5-Search/</guid>
      <description>Intro # 问题求解与搜索算法 # 问题求解涉及到两个方面:&#xA;问题的表示，比如枚举对象、状态表示 求解的方法，比如自顶向下的递归，自底向上的动态规划 搜索算法是一种通用的问题求解方法: 首先把问题表示 转换为一个状态空间图，然后设计特定的图遍历方法在状态空间中搜索问题的答案。&#xA;为了提高搜索的效率，在遍历状态空间时需要添加优化技术，比如剪枝策略用于尽可能避免无效搜索，启发式信息用来加速朝目标状态逼近的速度。&#xA;状态空间图 # 一个问题用搜索算法求解时，往往需要把问题描述为状态空间图，包括以下要素&#xA;状态 (State): 是为描述某类不同事物间的差别而引入的一组最少变量的有序集合，其矢量 形式为: 1 2 n ，其中每个分量 i 称为状态分量。 操作符 (运算符): 是指把一个状态转换为另外一个状态的操作或者运算。操作符可以是规划、数学运算和问题场景中行为等。 状态图: 如果把状态定义为图的结点，操作符定义为图的边，一个问题的全部可能状态则可 以表示为一个图，即状态图。 路径: 通过操作符序列连接起来的状态图中的一个状态序列。 路径耗散函数: 定义在路径上的一个数值函数，它反映了一条路径的性能度量或者求解问题 的代价。在求解最优化问题时，路径耗散函数往往与优化目标相关联。 状态空间图可以形式化地定义为一个四元组 (S，A，G，F)&#xA;S 表示问题的初始状态，它是搜索的起点。 A 是采取的操作符集合，初始状态和操作符隐含地定义了问题的状态图。 G 表示目标测试，它判断给定的状态是否为目标状态。它可以是表示目标状态的一个状态集合，也可以是一个判定函数。 F 代表路径耗散函数，它的定义需要具体问题具体分析。 搜索就是在状态空间图中从初始状态出发，执行特定的操作，试探地寻找目标状态的过 程。当然，也可以从目标结点到初始结点反向进行。状态空间图中从初始状态到目标状 态的路径则代表问题的解。解的优劣由路径耗散函数量度，最优解就是路径耗散函数值 最小的路径。&#xA;搜索算法类型 # 基于枚举的通用搜索 # DFS # 深度优先搜索 (Depth First Search, DFS) 是一种通用的图和树的遍历方法，给 定图𝐺 = (𝑉, 𝐸)，深度优先搜索的基本思想为:&#xA;初始化 任选一个结点𝑣作为源结点，DFS 访问源结点𝑣，并将其标记为已访问过 能进则进，不进则退 递归遍历 扩展结点𝑣，即访问𝑣的下一个未访问邻接结点𝑤; 递归处理以𝑤为根的所有子结点; 退回到结点𝑣，继续扩展𝑣的其它未曾访问的邻接结点，直到𝑣的所有子结点均已访问过为止。 循环处理 若图𝐺中仍然存在未访问的结点，则另选一个未访问的结点作为新的源 结点重复上述过程，直到图中所有结点均被访问过为止。 基于栈的 DFS 算法框架:</description>
    </item>
    <item>
      <title>About Me</title>
      <link>https://caesaryangs.github.io/others/about_me/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/others/about_me/</guid>
      <description> About Me # </description>
    </item>
    <item>
      <title>Projects</title>
      <link>https://caesaryangs.github.io/others/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/others/projects/</guid>
      <description> Projects # </description>
    </item>
  </channel>
</rss>
