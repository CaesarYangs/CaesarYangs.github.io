[{"id":0,"href":"/blogs/IELTS_2023/","title":"雅思备考指北-v2023","section":"Blogs","content":" 雅思备考指北-v2023 # Prologue # 大四下学期出现了一些规划上的危机，而且我这种情况算是特殊中的特殊，可借鉴的例子比较少。在调整好心态以后决定还是先行动起来，把一些达到目标的必须要求准备好，比如IELTS/GRE这种标化成绩。\n还好最后三十多天调整了心态，在大学的最后把毕设和雅思一起搞定了。\n阅读 # 我在备考前一年一直在有意保持自己的英语水平，所以阅读这块对我来说不是特别大的问题。\n当时用的方法就是在少数派英语学习指南中看到的一种辅助精度法，但是根据我的情况进行了一点改进。我通常是找上一周的一些杂志，比如The Economists这样的，专门将其中的最精华部分，也就是每本开始的Leaders部分，大概有个5-6篇文章。然后把这些排好版打印出来，每篇文章一般是读3遍：第一遍主要浏览大意，基本搞懂70%左右的文章内容，并且顺手把一些不认识的单词标出来；第二遍进一步把之前没有搞懂的地方精读完成，把一些写的很好的句子和段落标记出来；第三遍就是更高层次的阅读，尽量用自己的话把每一段的大意写在边上，从头到尾顺下来。最后再从头到尾整理一下文章结构，脑子里根据刚才写的每段大意和理解的意思自动生成这篇文章的行文结构。这样一篇基本上就读透了。然后下一天继续。\n非常巧妙的是，这个方法跟我后来对雅思阅读的整体理解非常类似。在做完了大量的雅思阅读训练以后，发现了每篇阅读当中的一些更深层次的套路。一些普通的套路我就不再赘述，可以直接去《阅读真经总纲》里面找。\n我总结一般的阅读有三种题型：\n细节题 概括题 结构题 细节题就是常见的T/F/NG，还有选择题。这种题100%能在文中找出来，读就完了。主要就看阅读量和速度能不能跟上。\n概括题一般是每段的大意选择题，概括题目等。这种目标也比较明确，针对某一个段或者整篇文章的开头结尾中间这种看就可以。\n结构题我认为是最难的，还有很多结构题是跟概括题结合在一起的，比如一些转写的填空题（直接把全篇概括让你填空），还有那种在表格里的大意选择题，这是我错误率最高的一种题。这种题需要大量的阅读，以及很好的定位能力，因为很难按照从头到尾的顺序去处理了。我认为的一个最主要方法就是多练，然后就是我上面提到的要对每篇文章有框架思维。经过一遍阅读后要尽量形成这篇文章的整体组织结构，这样就能在出现问你这个内容的同时快速定位，肯定不能精确定位，但也能够定位个大概，在附近2-3段里面选择。这样要比在全篇找容易的多。\n不要大量做题。没有必要把剑雅的题都刷完再上考场。你做题的过程本质上是一个训练的过程，真正提升的部分是在你做题后发现错题，并想办法改进的过程。一直盲目做题只能让你巩固当前的分数水平，并且让自己很累，给自己一种努力的错觉。\n每次做题尽量刷完一套。尤其是机考，在网站上练习的时候尽量一口气做完，因为一共也才整整一小时，这个时间肯定是能挤出来的。碎片做题很难整体把握阅读的节奏。\n放一张当时做题的记录，感觉整体上剑雅的难度跟真题相比还是非常准确的。所以如果自己做的时候出现了问题，一定不要想考试的时候能发挥好，基本上差不多的。赶紧找方法，再练习，找自己的正反馈。\n听力 # 听力在最后的考试里面感觉要比练习的时候难，不知道跟我的发挥状态有没有关系。到最后也就只有8，算是整个练习过程中分数比较低的水平了。\n我在做听力的时候发现不要专注在题目本身，因为雅思是个很科学的考试，它考你听力主要还是要考你在以后国外的真实场景中能不能听到，能不能听懂，而不是做这几个破题。千万别用老钟那套备考思维往里面带。我感觉可以放70%以上的注意力在听文本，30%以下的注意力在题目上。在真正开始放声音前把题目都看完，标记完。在开始放以后，切换大部分的注意力在听这件事本身上，只需要同时关注当前到哪题了，catch up进度就行。这样即使你立刻没有选出答案，大脑里也会有之前听这段对话的印象，等到这个section录音放完，还有很多时间可以思考正确答案选哪个。同时也能达到听到哪看到哪，不在某一个题上浪费大量时间。\n口语 # 所有的备考相关的中文资源or中国老师or中国人讲的视频都不要看了。 考的时候根本没时间想，所以切记一定不要背题！！！！！！考官一眼就能看出来。 口语有四个评分项，其中发音，词汇，语法是三个能短期内提升不少的，流利程度可能得看平时的积累和语感，但影响不大，这三个练好也能提0.5-1分了。 平时可以试着做一下自己的积累，就跟我附上的那个一样，这是我当时积累词和搭配用的表格。看别人说或者剧里面的好词好句都摘下来。目的不是都把他们背下来，目的是为了能在你说的过程中想起来然后插进去这么一两个高级搭配，整体能改善不少。 不要过多看题库。因为视频连线一开始就很容易大脑放空，我之前准备的时候主要是自己把本季的题都过一遍，主要是聊天能力，看自己有没有的可说。然后再想怎么丰富回答的层次，尤其是Part2和Part3. Part1:\n这一部分100%属于聊天内容，每一问回答3句左右就行，再长的话遇到poker-face考官就直接打断你，我就这样了。这一Part主要就是看你回答的流畅度，因为都是简单的问题，不用在意回答的深度，就是聊天。\n我准备的方式就是打开一个mock视频，看他问啥我就自己blabla说一堆，然后放视频，看看人家怎么回答的，最后还会有一个考官的点评和意见，这个时候可以想想自己说的问题，然后把他提到的好词好句积累下来。然后把回答的不好的问题也记下来。\nPart2:\n这块其实就是我说的自言自语的能力。我就属于自己话唠那种，最后2min直接都超时被打断。这块我建议考前可以不用练太多，积累自己想说话的那种感觉很重要，就算是编也得给它编到2min。\n可以设定几个特殊的场景。比如我当时准备的就是学校的瑞幸，如果他问最近发生的一件有意义的事，你就说这个事是在我买咖啡的时候遇到了同学，我们俩聊天喝咖啡blabla就能续下去了；如果他问一个你努力实现的目标，你就说为了学习一个东西，早上很早学校其他地方都没开，自己来到了咖啡馆，很早就开始学习，然后很有氛围blabla。\n虽然题你不能准备，也不能背，但是这些预设的场景能帮你快速开始说话，而且关键的是有细节，他们着重会听你讲故事里面的细节。我感觉可以设3个这样的场景，比如一个瑞，一个麦麦再来一个图书馆。可以提前积累一些你准备的场景里的高级词，比如你说跟同学在一起吃麦乐鸡（Chicken McNuggets）很开心，或者自己迷茫的时候去吃这个麦乐鸡。这些词就让考官觉得你很强。\nPart3:\n其实就是雅思大作文Part2。这部分前期不用单独准备，按照Simon的那个构思的流程学习完，然后让自己能更快地想到观点，想到接下来的论点，然后在脑子里串起来，这样就可以了。不需要很高级的词，主要是说的连贯，逻辑通顺，而且对错甚至也没关系，他们其实不关心你这个题答的是否正确，只要不跑题怎么说都行。但你一定要自己敢说，说的自洽就完全ok了。\nTips：\n看剧！提前沉浸到这个英语环境里，尽量考前每天都要看，不用管别的，就是看的开心就行。我考试当天吃早饭还在看生活大爆炸。\n建议多积累一些口语化的词，比如you know，about that这种，能给自己思考的缓冲时间，同时考官不会觉得你卡壳了。\n定期自己模考。方法就是打开一个视频，他问一个问题你就回答同时用手机录音，然后自己听。就会慢慢发现问题在哪，然后去进步。\n一定要根据Band Description评分标准去准备和提高，其他所有的解读其实都没有下面这个表有用。\n考前可以找一些真人聊聊天，你得亲自感受一下这个语境。因为考试的时候真的问的飞快，脑子和嘴都得跟得上才行。\n一些资源： Mock口语测试视频： https://www.youtube.com/@IELTSDaily 我当时基本上都是看的这个，非常非常非常帮助。就是说的太慢了+考官太温柔，考试的时候完全相反 英国佬的细节教学： https://www.youtube.com/@EnglishSpeakingSuccess 很多词汇积累，考试注意事项等等都有，也是非常有帮助 Pronunciation专项练习： https://www.youtube.com/@rachelsenglish/search?query=pronunciation 一些非常难的发音都在这里练，每天坚持十分钟能有很大提高。比如th这种音，练好了对以后去国外也一直会有帮助。 写作 # 优先看Simon的书！！！！！ 这个书里面写的都是非常精华的内容，上了考场根本来不及细想，只能提前把里面的很多方法提前训练好。还有一个第二版，现在还没有电子版，非常推荐去买个纸质版，基本上有这一本纸质材料就足够了。 把两个大小作文的范文pdf打印出来，然后每天去看看这些范文咋写的，尽量下次考试前看完一遍。培养一下它要求的写作高分的感觉，这样写起来语感和节奏会越来越好，时间分配也会提高。 针对Simon书里面提到的几个点专项练习，我感觉如果目标是我这种6.5或7其实没必要积累很多的大词，主要还是整体的逻辑、衔接和流畅度。所以我比较推荐的是这个书里面的观点练习，有一个section是专门让你自己想观点，然后分段，最后照着他给出的范文想法去纠正自己的思路，大小作文都这样。我当时就是训练了一段时间这个然后能很快很准的想到论点，且跑题几率会大大降低。 最后是看写作真经总纲。我觉得这里面写的没有Simon这个英国佬写的有针对性，方法可以直接用Simon的，但这个书里有很多搭配和句型。比如小作文的很多数字上升下降的描写，很有参考价值。考前一天背一背都管用。 大作文平时主要是在练的时候尽量总结一下自己思考的方法，比如大作文我想的就是要找更大面的几个视角更容易下笔（环境保护、经济发展blabla），而且错也错不到哪去；每个段有不同的论证方法：比如中间两个主要论证的段，一段用平行论证，另一段用递进论证，这样写起来很容易有逻辑性和语言丰富度；一定要举例子，而且至少每个段要有一个，他们还是很看重这样的论证方法的，不要总是车轱辘话解释观点。\n小作文主要就是看图、分类、描述。上来赶紧抓住这个图里面最明显的地方，然后不用任何数字给它描述出来；后面分类没有统一的标准，但最好跟你上面对明显的几个点的描述相关，比如有国家增长和下降最明显，可以考虑把它俩放一起写描述段；主要的地方在于描述段对数字描写要变化形式，不要总是一种句式。比如可以主语从句，定语从句和普通句交替着使用。\n可以一周写两篇大两篇小，没必要再多了。写完可以在网上给一些人互相评阅一下，主要是对逻辑上的检查。还可以直接扔给GPT，我当时基本上90%自己写的都是扔给它判，语法错误、搭配和大作文论点还是很有效的，而且能给你直接估分和改进方法，小作文逻辑就别让它看了，它自己就没逻辑。\n一些资源： 小作文讲的很好的老师： https://www.youtube.com/@ieltsliz 大作文Simon的网站： https://www.ielts-simon.com/ 推销一下自己的站，可以直接把api接上就能用： https://chat.cyang.site Epilogue # 感觉这三四十天挺魔幻的，报了GRE，搞定了雅思，完成了毕设，确定了以后的目标和路径，开始逐步向好的方向发展了。遇到问题千万别慌，对抗熵增要找到自己的办法，希望每个我的读者都能找到。路漫漫其修远兮\n想多了全是问题，做多了全是答案。\n机会虽然渺茫，但仍然是一个机会。什么东西最重要？机会最重要。如果一生中有无限的机会，你的人生会过得无限精彩。然而，人生的机会往往是有限的。\n感谢备考期间给我非常大帮助的文章： 雅思8.0备考经验+剑4-14各部分难度 - 知乎。感觉像是一个虚拟人一样，我俩比着学，看谁哪次剑雅分高分低，挺有意思的。也是我写这篇的契机。\n"},{"id":1,"href":"/blogs/YOLOv5_HNet/","title":"YOLOv5_HNet","section":"Blogs","content":" YOLOv5_HNet # A YOLOv5 modification net for key objects on private helmet dataset CaesarYangs/YOLOv5_HNet\n中文 | EN\n本项目的主要目标是利用一些已有的论文方案，结合我自己的一些思考和改动，实现对于私人数据集上的安全帽检测的效果提升。\n效果提升的标准定义：\n准确率 速度（检测速度） 模型大小（所需算力） 本项目所基于的数据集种类、数量都极其复杂，涉及多场景的情况处理。也在这些珍贵的数据集上进行了大量的实验及必须的消融实验。\ntips：本项目适合完全了解YOLOv5及以上版本源码的同学阅读及使用。建议可以先通过 GitHub - HuKai97/yolov5-5.x-annotations: 一个基于yolov5-5.0的中文注释版本！ HuKai大神之前做过的这个非常详尽的标注版本进行整体源码和必要细节阅读理解。也非常感谢这个项目让我在早期能够快速吃透并上手修改工作。\nSolution1: 改变Anchor，添加小目标检测层 # 思路：\n根据对数据集的分析，发现更多的情况是监控拍摄到的图片，结果就是目标的距离很远，物体较小。自然想到的第一个方向就是针对这些小目标着重优化。\n改进要点：\n添加一层新的小目标Anchor。 [5, 6, 8, 14, 15, 11] #new_anchor 修改FPN结构，增加层数。\n在原来5层FPN的基础上增加两层：分别是对dim=512及dim=256维度特征的再次提取，经过再次上采样提取过的最后一层连接到检测头，替换原来的单层提取/上采。\n利用kmeans，针对特定数据集情况做anchor重新聚类\n本质上是针对后期YOLOv5模型自带的anchor回归预测的一个手动验证，看经过我解耦后的单独anchor重聚类算法能否对基础的YOLO模型有所提升，以验证这个方法对于安全帽检测这个特定领域的有效性。\n训练结果：\ntype model parameters FLOPs pt_size mAP@0.5 mAP@0.5~0.95 FPS Power Plant YOLOv5s_baseline 7.06M 16.5G 14.3MB 0.75 0.484 30.5 Power Plant little_obj_anchor_fpn 50.9M 192.5G 102.3MB 0.748 0.45 4.3 Power Plant little_obj_anchor_kmeans 7.06M 16.5G 14.3MB 0.75 0.473 30.5 Power Plant little_obj_anchor 7.06M 16.5G 14.3MB 0.7552 0.4867 30.5 分析：\n此方法可谓”大而无当“。仅仅通过堆砌特征层，堆砌检测头的力大砖飞式改进并不能在安全帽这种特定领域下有很好的效果，而且徒增了接近十倍的算力需求，反而整体的准确率几乎没有提升。也有可能是需要特定的fine-tunning来实现目标检测上的“Large Model”，但肯定不会是无脑堆砌。作为一个反例值得思考。\n同时，证明了anchors重聚类对于提升还是比较有帮助的，不增加任何计算压力，不修改任何网络结构的情况下也能实现一些提升。证明了remapping anchors对于安全帽这种特定领域下的目标的可用性。\nSolution2: 改变Neck\u0026amp;Head结构，加入注意力机制，Transformer等 # 思路：\n此方法的灵感来源于 TPH-YOLOv5 这篇论文，原作者给YOLOv5加入了Transformer Prediction Head，最后的检测有了比较好的提高。我便基于这个检测头，根据我手中数据集的特点，选择重点优化FPN结构，并结合TPH和一些注意力机制。\n改进要点：\n改变FPN结构为Bi-FPH（加权双向特征金字塔网络），以期提升特征融合的精度及准确度，并一定程度上解决小目标问题。 增加CBAM（卷积注意力模块），这是一种用于前馈卷积神经网络的简单而有效的注意力模块。CBAM是轻量级的通用模块，因此可以忽略的该模块的开销而将其无缝集成到任何CNN架构中，并且可以与基础CNN一起进行端到端训练。 最后结合TPH检测头，最后组合为四头检测Head。 训练结果：\ntype model parameters FLOPs pt_size mAP@0.5 mAP@0.5~0.95 FPS Power Plant YOLOv5s_baseline 7.06M 16.5G 14.3MB 0.75 0.484 30.5 Power Plant bifpn-cbam-tph 45M 180G 87.5MB 0.76 0.388 10 Car Factory YOLOv5s_baseline 7.06M 16.5G 14.4MB 0.83 0.585 30 Car Factory bifpn-cbam-tph 45M 180G 87.5MB 0.85 0.574 12 分析：\n加入了一系列机制后，整体的准确率的确有了提升，但是相对的就是算力的大幅提高以及收敛速度显著下降。同时检测速度也极大下降。我也对此有一些疑问，貌似过分的特征提取or注意力机制对于安全帽这类物体检测来说提升效果和意义并不明显。\nSolution3: Network Slim 轻量化网络设计 # 思路：\n想法来源于 [1807.11164] ShuffleNet V2: Practical Guidelines for Efficient CNN Architecture Design 这篇论文。由于之前的测试都集中在对于准确率的提升上，以上提升准确率方法带来的弊端就是网络结构成倍增加，由此就需要一种能够轻量化网络的思路，我的想法是是否能够基于以上的有效的提升思路，再结合轻量化网络的方法，实现一种速度和准确率的balance。\n改进要点：\nG1. 卷积层的输入特征channel和输出特征channel要尽量相等； G2. 尽量不要使用组卷积，或者组卷积g尽量小； G3. 网络分支要尽量少，避免并行结构； G4. Element-Wise的操作要尽量少，如：ReLU、ADD、逐点卷积等； shuffleNetV2 # 替换backbone和后面所有C3结构为Shuffle Block，尽量减少非必要卷积操作。 尽量减少如SPP此类的并行操作结构 head中的C3改为DWConv结构 两级结构尝试：stage1为仅处理backbone部分，stage2为同时处理backbone和neck部分 MobileNetV3 # 使用MobileNetV3替换主要的特征提取backbone 训练结果：\ntype model parameters FLOPs pt_size mAP@0.5 mAP@0.5~0.95 FPS Power Plant YOLOv5s_baseline 7.06M 16.5G 14.3MB 0.75 0.484 30.5 Power Plant ShuffuleNetV2 0.7M 2.6G 1.6MB 0.586 0.299 37 Power Plant bifpn-cbam-tph-slim 45M 92.8G 72.5MB 0.758 0.415 11 Car Factory YOLOv5s_baseline 7.06M 16.5G 14.4MB 0.83 0.585 30.5 Car Factory ShuffuleNetV2_stage1 4.8M 16.5G 8.3MB 0.796 0.515 25 Car Factory ShuffuleNetV2_stage2 0.7M 16.5G 1.7MB 0.768 0.523 38 Car Factory bifpn-cbam-tph-slim 45M 92.8G 72.5MB 0.86 0.57 12 Car Factory mobileNetV3 5.6M 12.8G 3MB 0.47 0.229 35 分析：\n的确经过对应的设计后，在保证检测精度没有大幅下降的前提下，减少了一半多的算力需要，提升了一倍的FPS（但也就只有10帧\u0026hellip;）。理论上所需的计算量与baseline相比还是差了很多，效果有提升但也比较小，从此我便开始思考以上这些修改方式造成这种结果的原因。\n后来再次做了一个纯ShuffleNetV2 backbone的实验后，发现针对安全帽这种特点的数据，原本的网络尤其是骨干特征提取网络backbone部分是非常优秀的，能够平衡特征提取的精度和速度，因此不应该针对这一块进行大改；同时，注意力机制这种结构对于目前的安全帽检测算法来说，增加算力，减少速度的影响要大于准确率提升带来的优势，所以要根据需求进行tradeoff，目前使用这些没有一个兼顾速度和准确的方法。\nSolution4: Conv卷积核 + FPN修改 # 思路：\n从以上的三个solutions可以基本总结出一个情况，针对安全帽这类物体，YOLOv5原始的backbone效果已经足够好，有了足够的balance，因此结构不能进行大改；同时，在此基础上提高准确率的方法就导向了两种方法：一是改进卷积核，二是针对Neck中的FPN进行修改，并在此基础上做准确率和速度的balance\n改进要点：\nbase modification：\n将一部分backbone中经过C3卷积核之前，添加新的Focus-Conv卷积核，替代全部之前的stride卷积层和池化层，用于进一步在像素中提取信息，提供给下一层卷积操作。常见的stride卷积操作会导致细粒度信息的丢失和学习效率较低的特征表示，从这一点出发，为了在使用类似stride的同时避免对小物体/低分辨率情况下的特征丢失。 在Neck部分concat之前添加一层Focus-Conv卷积，用以增加特征提取，同时减弱stride操作带来的副作用。 advanced modification：\n在base基础上将FPN更换为Bi-FPN结构，实现更多层次的特征提取。 训练结果：\ntype model parameters FLOPs pt_size mAP@0.5 mAP@0.5~0.95 FPS Power Plant YOLOv5s_baseline 7.06M 16.5G 14.3MB 0.75 0.484 30.5 Power Plant focus-conv-yolov5 8.56M 28.8G 17.3MB 0.806 0.485 31 Car Factory YOLOv5s_baseline 7.06M 16.5G 14.4MB 0.83 0.585 30.5 Car Factory focus-conv-yolov5 8.56M 28.8G 17.3MB 0.875 0.573 31 分析：\n在没有明显增加参数量及FLOPs的情况下，发现这种基于focus结构改进的focus-conv卷积核能够在针对安全帽检测的应用场景中有比较好的表现，且能够平衡准确率和检测速度，是一个比较可行的优化方案。\nReference # GitHub - ultralytics/yolov5: YOLOv5 🚀 in PyTorch \u0026gt; ONNX \u0026gt; CoreML \u0026gt; TFLite GitHub - HuKai97/yolov5-5.x-annotations: 一个基于yolov5-5.0的中文注释版本！ GitHub - ppogg/YOLOv5-Lite: 🍅🍅🍅YOLOv5-Lite: lighter, faster and easier to deploy. Evolved from yolov5 and the size of model is only 930+kb (int8) and 1.7M (fp16). It can reach 10+ FPS on the Raspberry Pi 4B when the input size is 320×320~ GitHub - HuKai97/YOLOv5-ShuffleNetv2: YOLOv5的轻量化改进(蜂巢检测项目)\n"},{"id":2,"href":"/blogs/regex101/","title":"RegEx101 正则入门笔记","section":"Blogs","content":" RegEx101 正则入门笔记 # 正则表达式的两种基本用途：搜索和替换。给定一个正则表达式，它要么匹配一些文本（进行一次搜索)，要么匹配并替换一些文本（进行一次替换)。\n非常好的在线正则表达式匹配检测工具： regex101: build, test, and debug regex 学习与工作上都非常好用 匹配单个字符 # 正则表达式，也被称为模式，其实是一些由字符构成的字符串。这些字符可以是字面字符（普通文本)或元字符（有特殊含义的字符)。\n普通文本\n正则表达式是区分大小写的。 任意字符\n注意正则表达式使用字符串内容来匹配模式。匹配到的未必总是整个字符串，也可能是与某个模式相匹配的子串。在上面的例子里，我们使用的正则表达式并不能匹配完整的文件名， 而是只匹配了其中一部分。如果你需要把某个正则表达式的匹配结果传递到其他代码或应用程序里做进一步处理，就必须记住这种差异。\n特殊字符\n. 表示匹配任意单个字符。 \\ 是一个元字符（metacharacter，表示这个字符有特殊含义，代表的不是字符本身）。 .a.\\. 结果：na1.xls 第一个.匹配a前面的单个字符；第二个.匹配a后面的单个字符；\\.作为转义匹配真正的.符号 匹配一组字符 # 在正则表达式里，我们可以使用元字符 [ 和 ] 来定义一个字符集合。在使用 [ 和 ] 定义的字符集合里，出现在 [ 和 ] 之间的所有字符都是该集合的组成部分，必须匹配其中某个成员（但并非全部)。\n此处的 [ 和 ] 代表着强制匹配其中的元素。只有存在才能够匹配成功。 [ 和 ] 不匹配任何字符，它们只负责定义一个字符集合。接下来，再由真正的 regex 匹配部分参与匹配操作。 使用 [ 和 ] 的字符集合在不需要区分字母大小写（或是只需要匹配某个特定部分）的搜索操作里比较常见。 利用字符集合区间\n- 连字符，一种特殊的元字符。可以用这种连字符来定义字符区间。 一些合法的字符区间：\n[a-z]：匹配 a 到 z 所有小写字母 [A-Z]：匹配 A 到 Z 所有大写字母 [A-z]：匹配从 ASCⅡ字符 A 到 ASCIⅡ字符 z 的所有字母。这个模式一般不常用，因为它还包含 [ 和 ^ 等在 ASCⅡ字符表里排列在 Z 和 a 之间的字符。 字符区间的首、尾字符可以是 ASCⅡ字符表里的任意字符。但在实际工作中，最常用的字符区间还是数字字符区间和字母字符区间。\n注意 -（连字符）是一个特殊的元字符，它只有出现在 [ 和 ] 之间的时候才是元字符。在字符集合以外的地方，- 只是一个普通字符，只能与 - 本身相匹配。因此，在正则表达式里，- 字符不需要被转义。\n在同一个字符集合里可以给出多个字符区间。比如说，下面这个模式可以匹配任何一个字母（无论大小写)或数字，但除此以外的其他字符（既不是数字也不是字母的字符)都不匹配：\n[A-Za-z0-9]== [ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789] 排除\n字符集合通常用来指定一组必须匹配其中之一的字符。但在某些场合，我们需要反过来做，即指定一组不需要匹配的字符。换句话说，就是排除字符集合里指定的那些字符。\n使用元字符 ^ 来排除某个字符集合。而不用逐个列出要匹配的字符。 [^0-9]这种用法就恰好与[0-9]相反 小结\n元字符 [ 和 ] 用来定义一个字符集合，其含义是必须匹配该集合里的字符之一（各个字符之间是 OR 的关系，而不是 AND 的关系)。 定义一个字符集合的具体做法有两种： 一是把所有的字符都列举出来； 二是利用元字符 - 以字符区间的方式给出。可以用元字符 ^ 排除字符集合，强制匹配指定字符集合之外的字符。 元字符 # 转义字符\n因为元字符在正则表达式里有着特殊的含义，所以这些字符就无法用来代表它们本身。比如说，你不能使用 [ 来匹配 [ 本身，也不能使用 . 来匹配 . 本身。\n通过加上通用的转义字符 \\ 对其进行转义 对元字符进行转义需要用到 \\ 字符。这意味着 \\ 字符也是一个元字符，它的特殊含义是对其他元字符进行转义。在需要匹配 \\ 本身的时候，我们必须把它转义为 \\\\。 匹配空白字符\n元字符大致可以分为两种：一种是用来匹配文本的（比如 .)，另一种是正则表达式语法的组成部分（比如 [ 和 ])。 空白字符匹配： 匹配特定字符类型\n数字元字符\n匹配字母数字（与非字母数字）\n匹配空白字符\n因此，正则表达式的写法并不唯一。只需挑选最舒服的即可。 匹配十六进制或八进制数值\n十六进制：使用前缀 \\x 给出 八进制：使用前缀 \\0 给出 POSIX 字符类\nPOSX 是一种特殊的标准字符类集，也是许多（但不是所有）正则表达式实现都支持的一种简写形式。\n重复匹配 # 目的是要匹配尽可能多的字符。可以通过几种特殊的元字符实现。\n匹配一个或多个字符\n要匹配某个字符或字符集合，只要简单地在其后面加上一个 + 字符就行了。 + 匹配一个或多个字符（至少一个；不匹配零个字符的情况） + 还可以用来匹配一个或多个字符集合。配合之前的 [ 或 ] 来实现 注意你可能已经注意到了：我们没有对字符集合 [\\w.] 里的.字符进行转义，但依然能够匹配.字符。一般来说，当在字符集合里使用的时候，像.和+这样的元字符将被解释为普通字符，不需要转义，但转义了也没有坏处。[\\w\\.] 的使用效果与 [w\\.] 是一样的。\n匹配零个或多个字符\n这种匹配使用 * 元字符来完成。其与 + 的用法完全一样，但可以支持匹配零个或多个。 注意：可以把 * 理解为一种“使其可选”(make it optional)的元字符。+ 需要最少匹配一次，而 * 可以匹配多次，也可以一次都不匹配。 匹配零个或一个字符\n使用元字符 ? 来匹配可选文本 ? 只能匹配某个字符或字符集合的零次或一次出现。最多不超过一次。非常适合匹配一段文本中某个特定的可选字符。 匹配的重复次数\n为了解决这些指定重复的问题并对重复性匹配有更多的控制权，正则表达式允许使用重复范围(interval)。重复范围在 { 和 } 之间指定。\n要想设置具体的匹配次数，把数字写在 {} 之间即可。 如：{3} 表示匹配前一个字符或字符集合 3 次。若只匹配两次，则不算匹配成功。 区间范围\n{} 语法还可以用来为重复匹配次数设定一个区间范围，也就是匹配的最小次数和最大次数。\n区间必须以 {2,4}（最少重复 2 次，最多重复 4 次)这样的形式给出。 匹配至少重复多少次\n指定至少要匹配多少次(不指定最大匹配次数) 。这种用法的语法类似于区间范围语法,只是省略了最大值部分而已。\n比如说,{3,} 表示至少重复 3 次,换句话说,就是“重复 3 次或更多次” 。 此时，+ 在功能上便等价于 {1,} 防止过度匹配\n? 的匹配范围有限(仅限零次或一次匹配) ,当使用精确数量或区间时,重复范围匹配也是如此。但其他重复匹配形式在重复次数方面都没有上限值,而这样做有时会导致过度匹配的现象。\n* 和 + 都是所谓的“贪婪型”（greedy)元字符， 其匹配行为是多多益善而不是适可而止。它们会尽可能地从一段文本的开头一直匹配到末尾，而不是碰到第一个匹配时就停止。这是有意设的，量词就是贪婪的。 在不需要这种“贪婪行为”的时候该怎么办？答案是使用这些量词的“懒惰型”（lazy)版本（之所以称之为“懒惰型”是因为其匹配尽可能少的字符，而非尽可能多地去匹配)。懒惰型量词的写法是在贪婪型量词后面加上一个 ？。 位置匹配 # 单词边界\n\\b 是由其所指定的单词边界。用来匹配一个单词的开头或结尾。 \\b 匹配的是字符之间的一个位置，一边是单词另一边是其他内容。 如果想要匹配完整的单词，就必须在匹配的文本前后都加上 \\b 字符串边界\n^ 匹配一个字符串的开头位置 $ 匹配字符串结尾位置 "},{"id":3,"href":"/blogs/PyQT5_in_ARM_mac/","title":"在 Apple Silicon 上配置 PyQt5 以及 LabelImg","section":"Blogs","content":" 在 Apple Silicon 上配置 PyQt5 以及 LabelImg # Mac M1 芯片安装 labelImg - 简书\n最近突然需要继续做一些数据标注的任务，下载好了之前经常用的 Labelme 后发现输出的标记文件是 json 格式的，不符合项目规范。发现 labelImg 这款标注软件刚好是输出 xml 作为标记文件的，十分合适。\n但是由于最近刚刚换了电脑，时隔一年的试用后终于把我的主力机换到了 Apple Silicon 平台上来，随之而来的就是这一系列的配置问题。\nGitHub - heartexlabs/labelImg\nQ-问题 # 官方的安装文档向来是非常重要的部分。主要是在执行 pip3 install pyqt5 lxml # Install qt and lxml by pip 的时候报错，直接 error。\n在这一部分可能会有很多的人会遇到与我相似的问题，故将整个问题的出现与操作列出。\n一般到这里复制错误信息到 Google 会发现有一部分用户也遇到了这类问题，主要的原因就是 arm64 架构和此处的 PyQt5 不兼容所导致的。\n此时可以尝试利用 homebrew 中更新的命令：brew install pyqt@5 进行安装。\n并且可以看到这个命令安装的 PyQt5 已经是适配 arm64 架构的版本了。\n但此时如果继续按照官方文档走下去安装，会发现在安装labelimg的时候依旧会报错。并且所报的错误与之前几乎完全相同。\n此时就可以发现，整个的错误原因都是来源于PyQt5没有正确导入造成的。虽然已经在本地安装好相应的包了，但是并没有导入到对应的Python环境当中，导致无法正确使用。如果在此时尝试直接下载GitHub的源码编译安装的话，会非常直接的发现报错内容为：PyQt5 import error\n正确准备arm64架构上的PyQt5 # Outline # 安装并转移 pyqt5 arm64 版本： M1 Mac 安装 PyQt5 的方法 - 知乎 直接 pip 安装 labelimg 打开即可使用。且为 arm64 版本，性能极佳。 创建虚拟环境（推荐） # 非常推荐利用python和conda自带的虚拟环境来管理各种不同的空间和包，这样能做到最大限度的解耦，并且即用即取，不用即弃，也不易污染dev环境。\n创建空间：conda create -n \u0026quot;your_env_name\u0026quot; python=\u0026quot;3.9\u0026quot; 激活空间：conda activate your_env_name 由于labelimg的当前支持版本为Python3.9，此处便直接填入。\n安装PyQt # 此处利用homebrew作为包管理器\n安装arm64架构的PyQt5：brew install pyqt@5 迁移——最重要的环节 # 这一步迁移就决定了可以实现完全原生arm64架构的PyQt5体验，并且基于这一套包的上层应用都可以在原生Apple Silicon架构中运行，获得最佳的性能和能耗表现。\n通过conda env list查看环境列表和路径 切换到环境目录下，寻找对应的site-package目录。此目录下存放了全部在此python版本下安装的包文件。\n拷贝PyQt5到对应的目录下\n`cp -r PyQt5/ /opt/homebrew/Caskroom/miniforge/base/envs/label/lib/python3.9/site-packages 全部准备工作就做好了。可以通过相应的命令来检测是否安装正确：\nimport PyQt5 没有报错即包导入成功\n安装labelimg # pip install labelimg 即可成功安装。\n安装后在相应路径下打开python env，输入labelimg .即可打开程序\n"},{"id":4,"href":"/blogs/test/","title":"Test","section":"Blogs","content":" HHHHHH # "},{"id":5,"href":"/docs/Advanced-OS/class-notes/1-Linux-UNIX%E6%A6%82%E8%AE%BA/","title":"1 Linux Unix概论","section":"Class Notes","content":" 操作系统相关概念 # 什么是操作系统\n最基础的系统软件\n计算机软硬件资源的管理与控制 软件涵盖程序、文档、数据 硬件涵盖处理器、内存、外存及各类设备 硬件资源及管理操作抽象示例\n磁盘操作：把数据处理结果写到磁盘，也就是从内存拷贝信息到磁盘 分解动作： 内存数据块拷贝到设备缓冲区 load(addrBlock, length, bufDev); 磁盘设备执行寻道操作 seek(dev, trackNo); 设备缓冲区写出到指定扇区 out(bufDev, sectorNo); void write(char *addrBlock, int length, int dev, int trackNo, int sectorNo){ load(addrBlock, length, bufDev); seek(dev, trackNo); out(bufDev, sectorNo)； } write(addrBlock, 8, dev, 21532); fprintf(fd, \u0026#34;%d\u0026#34;, data); + fseek(fd, offset, whence); 什么是操作系统\n最基础的系统软件 计算机软硬件资源的管理与控制 软件涵盖程序、文档、数据 硬件涵盖处理器、内存、外存及各类设备 用户使用计算机的基本操作环境 命令接口、图形化用户接口 各类程序运行的基础环境 程序接口：系统调用接口、函数库 操作系统内核\n实现操作系统的核心功能 计算机系统的启动初始化及电源管控 处理器、内存、外设等硬件的管理与控制 文件系统的支持 操作系统的基本特征及支撑机制\n并发 注意与并行概念的区别 进程、线程、同步互斥及通信机制 共享 硬件共享：处理器、内存、外设 软件共享：程序、数据 共享与保护机制结伴而行 虚拟与异步 操作系统发展历程 # 单道批处理系统 监督程序（FMS Fortran Monitor System 、IBSYS） 多道批处理系统 多道程序设计技术 分时操作系统 CTSS（Compatible Time Sharing System） 麻省理工学院（1962 年） 时钟中断、时间片轮转调度、交换技术 实时操作系统 实时调度算法、可靠性 嵌入式操作系统 软硬件合体、微型化、专业化 网络操作系统 网络传输功能支持 分布式操作系统、网格操作系统 云操作系统、集群操作系统 UNIX/Linux 操作命令入门 # UNIX/Linux 系统启动及配置\nShell 命令分隔/连接符\n管道线| （左侧命令输出作为右侧命令输入） ls -l | wc -l ||（左侧命令执行失败时执行右侧命令） rmdir /home/zgs || echo \u0026ldquo;Failed!\u0026rdquo; \u0026amp;\u0026amp;（左侧命令执行成功时执行右侧命令） rmdir /home/zgs \u0026amp;\u0026amp; echo \u0026ldquo;Success!\u0026rdquo; \u0026amp;（后台执行左侧命令） gas BJTU_OS.s \u0026amp; 输入输出重定向：命令 [\u0026gt;、\u0026lt;、\u0026raquo;、\u0026laquo;] 文件 "},{"id":6,"href":"/docs/Advanced-OS/class-notes/2-Linux-Shell/","title":"2 Linux Shell","section":"Class Notes","content":" 最简单 Shell 程序解析及运行 # #!/bin/sh 是指此脚本使用/bin/sh 来解释执行，#!是特殊的表示符，其后面跟的是此解释此脚本的 shell 的路径。\nShell 程序第一行规范建议\n建议写法 #! /bin/sh 强烈不建议写法—— #!型注释 #! 其它注释内容 两种运行方式 ./ sh Shell 程序调试方式 # 命令 选项 功能说明 sh -n 程序名 纯粹性 解释分析 解释但不执行命令（用于检查程序语法错误） sh -x 程序名 显示替换结果程序并执行 在变量替换之后、执行命令之前，显示程序的每一有效行（非空且非注释行） sh -v 程序名 显示原始程序并执行 在执行之前，按输入的原样显示输出程序中所有各行（包括空行、注释行） set -x 打开（命令）回显 跟踪程序的执行（主要用于 Shell 程序中） set +x 关闭（命令）回显 关闭跟踪功能（主要用于 Shell 程序中） 局部变量应用编程 # Shell 变量赋值与引用\nShell 变量赋值 \u0026lt;变量名\u0026gt;=\u0026lt;初始值\u0026gt; 譬如：fileName=\u0026ldquo;zgsFile.txt\u0026rdquo; 注意等号两边不能有空格！！！ Shell 变量引用 $\u0026lt;变量名\u0026gt; \u0026quot;$fileName\u0026quot;、“$fileName”、‘$fileName’ 或任何引号外 $fileName 有效 '$fileName' 无效（$ 亦按普通字符处理） $fileName 比较特殊（按命令串处理） 清理变量 unset varName 空格在linux中时作为一个很典型的分隔符，比如string1=this is astring，这样执行就会报错。为了避免这个问题，因此就产生了单引号和双引号。他们的区别在于，单引号将剥夺其中的所有字符的特殊含义，而双引号中的\u0026#39;$\u0026#39;（参数替换）和\u0026#39;`\u0026#39;（命令替换）是例外。所以，两者基本上没有什么区别，除非在内容中遇到了参数替换符$和命令替换符`。 Shell 变量分类\n局部变量（本地变量） 自己定义的变量 环境变量（类似于全局变量） 可以自己定义并全局化 譬如 $PATH 预定义变量（特殊变量） $+【*#$?!】 位置变量（类似于 C 程序的命令行参数） $+【数字】 环境变量及 export 命令 # 查看系统环境变量取值 -env 命令\nBASH脚本基础：环境变量PS2介绍_bash ps2-CSDN博客\n$ echo $HOME home/zhaigaoshou2018 $ echo $LANG en_US.UTF-8 $ echo $TERM xterm-256color $ echo $PS2 \u0026gt; $ echo $PATH opt/ros/kinetic/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin Shell 程序的环境变量\n定义方式类似于局部变量，但在作为环境变量使用前必须通过 export 命令进行导出 环境变量生命周期和作用域涵盖对应所有各级子孙进程 系统环境变量生命周期和作用域涵盖所有用户及各子孙进程，最好在.profile 文件中定义 export 命令解析\n是变量（名）而非仅仅变量取值的传递 位置变量及特殊变量应用编程 # Shell 程序的位置变量\n类似于 C 程序的命令行参数，用来对命令行中各对应位置的参数进行描述 $0 对应 Shell 命令或 Shell 程序名本身 $1、$2、…、$9 分别对应传入的第 1 个参数、第 2 参数、…、第 9 个参数 当实际参数大于 9 个时，需要用 shift 命令来移动位置参数 每执行一次 shift n 命令，最前面的 n 个传入参数将被移去，于是第 n+1 个参数成为 $1，以此类推 缺省情况下，n 等于 1 Shell 命令中的特殊变量\n$* 命令行中的传入参数序列 $# 命令行中的传入参数的个数 $? 前一个命令返回的结果（状态）值，0为正常 $$ 当前Shell进程的进程标识符PID值 $! 最近访问的后台进程的进程标识符PID值 条件判断控制结构应用编程 # if-else 基本代码结构\ncommand-list1 或 command-list2 等两处命令行部分均可嵌套使用 if 条件判断控制结构 else 分支可无 if [ \u0026#34;$varZGS\u0026#34; = valueZGS ] then command-list1 else command-list2 fi command-list1 或 command-list2 等三处命令行部分均可嵌套使用 if 条件判断控制结构，且 then 命令行与 fi 之间的 elif-then 命令行可有连续多个 if [ \u0026#34;$varZGS1\u0026#34; = valueZGS1 ] then command-list1 elif [ \u0026#34;$varZGS2\u0026#34; = valueZGS2 ] then command-list2 else command-list3 fi 分支判断控制结构应用编程 # case-Shell 例程\ncase \u0026#34;$cmdID\u0026#34; in d|D) date ;; w|W) who ;; s|S) echo \u0026#34;Hello! `who`\u0026#34; ;; c|C) echo \u0026#34;Hello! China!\u0026#34; ;; *) echo \u0026#34;$cmdID is not a valid choice!\u0026#34; echo \u0026#34;Run the program and try again!\u0026#34; exit 1 ;; esac exit 0 case 代码基本结构\ncase \u0026#34;$varZGS\u0026#34; in pattern1) command-list1 ;; pattern2) command-list2 ;; pattern3) command-list3 ;; pattern4) command-list4 ;; …… *) command-list ;; esac 循环控制结构应用编程\nwhile-Shell 例程\n#! /bin/sh Sum=0 i=0 while [ $i != \u0026#34;100\u0026#34; ] do i=`expr $i + 1` Sum=`expr $Sum + $i` done echo \u0026#34;Sum-from-1-to-$i = $Sum\u0026#34; expr command in Linux with examples - GeeksforGeeks Basic operations like addition, subtraction, multiplication, division, and modulus on integers. Evaluating regular expressions, string operations like substring, length of strings etc. while 循环结构编程要旨\n基本代码结构 while [ \u0026#34;$varZGS\u0026#34; != valueZGS ] do command-list done while 循环执行过程 首先判断循环条件是否成立 若不成立，则转③结束循环；否则，进入循环体执行有关命令，然后转① 循环结束 until 循环结构编程要旨\n基本代码结构 until [ $varZGS = valueZGS ] do command-list done until 循环执行过程 首先判断循环条件是否成立 若成立，则转③结束循环；否则，进入循环体执行有关命令，然后转① 循环结束 for shell 例程\n#! /bin/sh Sum=0 for zI in 1 2 3 4 5 6 do Sum=`expr $Sum + $zI` done echo \u0026#34;SumOf[1 2 3 4 5 6] = $Sum\u0026#34; for 循环结构 1 编程要旨\n基本代码结构 for varZGS do command-list done for 循环执行过程 首先判断 Shell 程序还有无传入参数 若无，则转③结束循环；否则，将最前面的传入参数赋值给循环变量，进入循环体执行有关命令，然后传入参数执行左移操作，转① 循环结束 for 循环结构 2 编程要旨\n基本代码结构 for zI in zList do command-list done for 循环执行过程 首先判断循环变量取值列表还有无数值 若无，则转③结束循环；否则，将最前面的数值赋值给循环变量，进入循环体执行有关命令，然后有关取值列表执行左移操作，转① 循环结束 for 循环结构 3 编程要旨\n基本代码结构 for varZGS in `cmd` do command-list done break 与 continue 编程要旨\n逆序显示命令行参数的 shell 例程\n#! /bin/sh # A continue shell-script count=$# cmd=\u0026#39;echo\u0026#39; while true do cmd=\u0026#34;$cmd \\$$count\u0026#34; count=`expr $count - 1` [ $count -gt 0 ] \u0026amp;\u0026amp; continue eval $cmd exit 0 done #! /bin/sh # A break shell-script count=$# cmd=\u0026#39;echo\u0026#39; while true do cmd=\u0026#34;$cmd \\$$count\u0026#34; count=`expr $count - 1` [ $count -eq 0 ] \u0026amp;\u0026amp; break done eval $cmd 拷贝若干文件的 shell 例程\nFetching Title#lq1u\n#! /bin/sh # A shell script for copying files to directory eval dir=\\$$# if [ -d $dir ] then echo $dir cmd=cp while [ $1 ] do if [ -f $1 ] then { cmd=\u0026#34;$cmd $1\u0026#34; echo $cmd } else echo \u0026#34;$1 is not a file\u0026#34; fi shift done cmd=\u0026#34;$cmd $dir\u0026#34; echo $cmd $cmd fi 显示若干文件内容的 Shell 例程\n#! /bin/sh # A shell script for displaying contents of specified files echo \u0026#34;Error messgages:\u0026#34; \u0026gt; errFile exitStatus=0 if [ $# = 0 ] then { echo \u0026#34;At least one argument is needed!\u0026#34; \u0026gt;\u0026gt; errFile echo \u0026#34;Usage: shApp-CatFilesBv file1 [file2 … fileN]\u0026#34; \u0026gt;\u0026gt; errFile exitStatus=1 } fi while [ $1 ] do if [ -f \u0026#34;$1\u0026#34; ] \u0026amp;\u0026amp; [ -r \u0026#34;$1\u0026#34; ] then { i=1 while read LINE do echo \u0026#34;$i#: \u0026#34; $LINE i=`expr $i + 1` done \u0026lt; \u0026#34;$1\u0026#34; } else echo \u0026#34;$1 is a not ordinary file or it can\u0026#39;t be read!!!\u0026#34; \u0026gt;\u0026gt; errFile exitStatus=2 fi shift done 监控系统用户的 shell 例程\n#! /bin/sh # A shell script for monitoring log-user who | sort \u0026gt; prev while true do sleep 10 who | sort \u0026gt; curr echo \u0026#34;logged out:\u0026#34; comm -23 prev curr #显示只在`prev`中而不在`curr`中的行，即已注销的用户 echo \u0026#34;=================\u0026#34; echo \u0026#34;logged in:\u0026#34; comm -13 prev curr #显示只在`curr`中而不在`prev`中的行，即新登录的用户 echo \u0026#34;=================\u0026#34; mv curr prev done 函数应用编程 # 函数定义 function_name() { \u0026lt;命令行序列\u0026gt; return [n] } 调用方式 function_name [\u0026lt;参数序列\u0026gt;] Shell 文件中函数调用要旨\n命令行中定义的函数 存在于 B-Shell 内存空间 文件中定义的 Shell 函数使用方式 source \u0026lt;ShellFunFileName\u0026gt; 若想使有关函数永久保留在 Shell 空间，则需将语句 “.~/\u0026lt;ShellFunFileName\u0026gt;” 写入文件.profile 和.bashrc 中，从而在启动 Shell 时读取这些函数文件加载到 Shell 空间中 【/etc/profile.d/*.sh】 查看（Shell 空间中的）函数与导出函数 set 命令、export \u0026lt;函数名\u0026gt;【使子进程可用】 #! /bin/sh # A shell script demonstrating functions for Jia/Jian/Cheng/Chu Add() { echo -e \u0026#34;add: $1 + $2 = \\c\u0026#34; echo \u0026#34;$1 + $2\u0026#34; | bc } Sub() { echo -e \u0026#34;sub: $1 - $2 = \\c\u0026#34; echo \u0026#34;$1 - $2\u0026#34; | bc } Mult() { echo -e \u0026#34;mult: $1 * $2 = \\c\u0026#34; echo \u0026#34;$1 * $2\u0026#34; | bc } Div() { echo -e \u0026#34;div: $1 / $2 = \\c\u0026#34; echo \u0026#34;$1 / $2\u0026#34; | bc } Mod() { echo -e \u0026#34;mod: $1 % $2 = \\c\u0026#34; echo \u0026#34;$1 % $2\u0026#34; | bc } 函数必须先定义，后使用 函数在当前环境中运行，可共享其主调程序中的变量，还允许以给位置参量赋值的方式向函数传递参数 可使用 local 功能在函数内部创建局部变量 return 命令返回主调程序；exit 命令结束整个程序 可用 export -f 把函数导出到子 Shell 中 函数可以递归，且递归调用次数没有限制 "},{"id":7,"href":"/docs/Advanced-OS/class-notes/3-Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","title":"3 Linux内核数据结构及系统调用","section":"Class Notes","content":" Linux 内核编程及编译 # Linux 内核所用编程语言\nC 语言 汇编语言 Linux 内核代码已超 2 千万行、接近 3 千万行\nLinux 内核编译常用工具\nGCC（GNU Compiler Collection） GCC 不仅支持 C 语言，还扩展支持了 C++、Java、Go 等语言 GCC 支持多种不同的硬件平台，如 x86、ARM、MIPS、LoongArch 等体系结构 GCC 编译流程 Linux 内核编程技巧 # 语句表达式 # 语句表达式（即括号内的复合语句）\n宏构造利器：语句表达式 - Linux内核中语句表达式的使用 - 嵌入式C语言自我修养 | 宅学部落\n旨在使宏定义变得更加安全 #define max(x,y) ((x)\u0026gt;(y)?(x):(y)) #基于整型数据的改进 #define max(x,y) \\ ({ int _x=(x), _y=(y); _x \u0026gt; _y ? _x : _y; }) # 基于未知数据类型的改进 #define max(x, y) ({\t\\ typeof(x) _x = (x);\t\\ typeof(y) _y = (y);\t\\ (void) (\u0026amp;_x == \u0026amp;_y);\t\\ _x \u0026gt; _y ? _x : _y; }) 零长数组（变长数组） # 在定义数据结构时非常有用、不占用结构体空间\nstruct T_Line { int length; char contents[]; }; typedef struct { unsigned int meg_len; //至少包含一个成员 char msg_data[];\t//变长数组成员必须是结构体最后一个 } MsgBuffer; 使用：\n//内存申请 p_buffer = (MsgBuffer *)malloc(sizeof(MsgBuffer) + sizeof(int) * cur_len); if(NULL != p_buffer){ p_buffer-\u0026gt;msg_len = cur_len; memcpy(p_buffer-\u0026gt;data,data,cur_len); } //内存释放 free(p_buffer); p_buffer = NULL; 基于区间的分支选择 # 注意…两边均有空格 对于 ASCII 码或整数范围指定非常有用 static int local_atoi(const char *name) { int val = 0; for (;; name++) { switch (*name) { case \u0026#39;0\u0026#39; ... \u0026#39;9\u0026#39;: val = 10*val+(*name-\u0026#39;0\u0026#39;); break; default: return val; } } } 基于成员名的灵活初始化 # 标准 C 语言要求数组或结构体初始化必须顺序出现 GNU C 则可通过指定索引或结构体成员名初始化 支持参数个数可变的宏 # 主要应用于输出操作类函数里\n#define pr_emerg(fmt, ...) \\ printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__) #define pr_alert(fmt, ...) \\ printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__) #define pr_crit(fmt, ...) \\ printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__) #define pr_err(fmt, ...) \\ VA_ARGS 为编译器保留字段，预处理伊始把参数传递给被定义的宏，而当宏调用展开时，实参便传递给了替换后的 printk 函数\n面向编译检查与优化的属性声明 # 函数属性：noreturn、const、format、interrupt、isr 语法格式：attribute((\u0026lt;属性列表\u0026gt;)) 变量/类型属性：aligned、packed、sections GCC 内建函数 # GCC 内建函数（以 builtin 作为函数名前缀）\nLinux 内核常用内建函数 __builtin_constant_p(x): 用来判断编译时 x 是否就可确定为常量。 __builtin_expect(exp, c): 寓意 exp==c 的概率很大，从而可用来引导 GCC 编译器进行条件分支预测。这也即根据最有可能执行的分支实施指令序列优化处理，使指令尽可能顺序执行以提高 CPU 预取效率。 __builtin_prefetch(const void* addr, int rw, int locality): 主动进行数据预取，即使用地址 addr 内存单元的值之前就将其取值加载到高速缓存 cache 里，从而减少延迟和改善性能。 关于函数形参存放位置的指定 # 在标准 C 语言中，函数形参在传入实参时会涉及参数存放位置问题。\n对于 x86 体系结构来说，函数参数和局部变量均被存放到函数局部堆栈里。\n而对于 ARM 体系结构，函数参数按照 ATPCS（ARM Procedure Call Standard）标准进行传递。具体来说，前五个参数存放在寄存器 R0~R4 中，超出之后的参数则被存放在局部堆栈中。\n为此，ARM 平台没有定义自身的 asmlinkage 宏，而直接引用内核的 asmlinkage 宏，即：\n#define asmlinkage CPP_ASMLINKAGE 整型常数后缀 ul # 在 C 语言中，数字常量会被隐式处理为 int 类型，因此两个 int 类型的数据相加可能导致溢出。为了避免这种情况，可以使用 ul 后缀，将 int 类型的数据强制转换为无符号长整类型 (unsigned long)。\n范例：\n1 表示有符号整数（int）1。 1ul 表示无符号长整类型数（unsigned long）1。 Linux 系统调用实现机制 # 定义: 系统过程→系统服务→系统调用命令\n与普通过程调用的区别\n运行在不同的系统状态 软中断进入机制 返回及重新调度问题 嵌套调用 如何从用户空间进入内核空间？\n软中断/陷入机制（int 指令） 如何跳转至系统调用总控程序模块？\n中断向量表（函数指针数组：整数索引⬄函数） 如何跳转至特定系统调用处理函数？\n系统调用表（函数指针数组：整数索引⬄函数） 如何从内核空间返回用户空间？\n（软）中断返回机制（ret 指令） 系统调用应用编程举例说明\n简单用户程序例子 从一个文件读取数据，再将它们拷贝到另一文件中（两个文件名已获得） 系统调用分析 源数据文件打开 目标数据文件创建 文件数据读入到缓冲 缓冲数据写出到文件 关闭数据文件 系统调用号\n/usr/include/asm/unistd.h : （1）#include \u0026lt;asm/unistd_32.h\u0026gt;⬄/usr/include/asm/unistd_32.h #define __NR_read\t3 #define __NR_write\t4 #define __NR_open\t5 #define __NR_close\t6 #define __NR_creat\t8 （2）#include \u0026lt;asm/unistd_64.h\u0026gt;⬄/usr/include/asm/unistd_64.h #define __NR_read\t0 #define __NR_write\t1 #define __NR_open\t2 #define __NR_close\t3 #define __NR_creat\t85 系统调用表\n系统调用号与系统调用之间的联系建立在系统调用表 sys_call_table 中，本质上利用函数指针数组实现\n/usr/include/unistd.h: extern long int syscall(long int __sysno, ...) __THROW; _syscall2(long, open, const char*, filename, int, flags); _syscall2(long, creat, const char*, filename, int, flags); _syscall3(ssize_t, read, unsigned, fd, char*, buf, size_t, count); _syscall3(ssize_t, write, unsigned, fd, char*, buf, size_t, count); _syscall1(void, close, unsigned, fd); //实现 FUNPTRTYPE sys_call_table[] = {sys_read, sys_write, sys_open, sys_close, …, sys_creat, …}; 系统调用实现机制\n系统调用的实现要领\n设置系统调用号和参数 系统调用号（指定寄存器/内存单元） 参数（直接寄存器 、间接参数表指针） UNIX(CHMK 命令)/DOS(INT21 软中断) 系统调用命令的一般性处理 将处理机状态由用户态转为系统态 保护 CPU 现场，将 PSW、PC、系统调用号、用户栈指针、通用寄存器等压入堆栈 用户定义参数送至指定位置 分析系统调用类型，转相应处理子程序 中断和陷入向量表、系统调用表 Linux 内核常用数据结构 # 链表\n数组要求占用连续存储空间且无法动态扩展，含若干结点（均由有效数据和指针两部分组成）\n单向链表、双向链表、Linux 内核链表类属机制\nLinux 内核链表类型定义 //\u0026lt;linux-4.8.8/include/linux/types.h\u0026gt; struct list_head { struct list_head *next, *prev; }; Linux 内核链表结点添加/删除/替换操作函数 //\u0026lt;linux-4.8.8/include/linux/list.h\u0026gt; static inline void list_add(struct list_head *new, struct list_head *head); static inline void list_add_tail(struct list_head *new, struct list_head *head); static inline void list_del(struct list_head *entry); static inline void list_replace(struct list_head *old, struct list_head *new); Linux 内核链表遍历操作宏 //\u0026lt;linux-4.8.8/include/linux/list.h\u0026gt; #define list_for_each(pos, head) \\ for (pos = (head)-\u0026gt;next; pos != (head); pos = pos-\u0026gt;next) #define list_for_each_prev(pos, head) \\ for (pos = (head)-\u0026gt;prev; pos != (head); pos = pos-\u0026gt;prev) 红黑树\n广泛用于内核内存管理和进程调度\n二叉树、B- 树、B+ 树、平衡二叉树、红黑树\nB 树与 B+ 树 B- 树（B 树，平衡多叉树） 一棵 m 阶 B 树是一棵平衡的 m 路查找树 B- 树或者是空树，或者是满足下列性质的树： 1、每个结点最多拥有 m 棵子树； 2、具有 k 棵子树的非叶结点包含 k-1 个关键字（从小到大排列，且对应左子树结点均小、右子树结点均大）； 3、除根结点以外的所有非叶结点拥有至少⌈m/2⌉棵子树； 4、非空 B 树的根结点拥有至少一个关键字及两棵子树 5、所有的叶子结点都位于同一层 B+ 树（B 树 + 索引顺序访问方法） 叶子结点存储关键字及相应记录的地址，叶子结点以上各层作为索引使用 一棵 m 阶的 B+ 树定义如下： 1、每个结点至多有 m 个子女； 2、除根结点外，每个结点至少有 [m/2] 个子女，根结点至少有两个子女； 3、有 k 个子女的结点必有 k 个关键字 B+ 树的查找与 B 树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止 平衡二叉树（Balanced Binary Tree） 一棵空树；或其左右两棵子树的高度差的绝对值不超过 1，且左右两棵子树均为平衡二叉树 红黑树（平衡二叉树变体：左右子树高度差可能大于 1，但平衡代价低） 每个结点或红或黑（非红即黑）的二叉排序树 根结点为黑色，每个叶结点也均为黑色 若结点为红色，则两个子结点都为黑色父结点一定为黑色 从一个内部结点到其所有叶结点的各简单路径上的黑色结点数量都是相同的存在黑色子结点的结点一定有两个子结点 优点在于所有重要操作（包括插入、删除、搜索）的时间复杂度均为 O(log n) 着色规则 添加新的结点，默认颜色为红色。（可能破坏红黑树性质/要求） 若为根结点位置，直接修正为黑色 若非根结点位置 如果父结点为黑色，无需任何操作 如果父结点为红色 若叔叔结点为红色，则将父结点和叔叔结点都设置为黑色、同时将非根结点的祖父结点设置为红色 若叔叔结点为黑色，则将父结点设置为黑色、祖父结点设置为红色，并以父结点为支点旋转祖父结点 Linux 内核红黑树实现 // linux-4.8.8/include/linux/rbtree.h struct rb_node { unsigned long __rb_parent_color; struct rb_node *rb_right; struct rb_node *rb_left; } __attribute__((aligned(sizeof(long)))); struct rb_root { struct rb_node *rb_node; }; 红黑树相关操作函数 extern void rb_insert_color(struct rb_node *, struct rb_root *); extern void rb_erase(struct rb_node *, struct rb_root extern struct rb_node *rb_next(const struct rb_node *); extern struct rb_node *rb_prev(const struct rb_node *); extern struct rb_node *rb_first(const struct rb_root *); extern struct rb_node *rb_last(const struct rb_root *); extern struct rb_node *rb_first_postorder(const struct rb_root *); extern struct rb_node *rb_next_postorder(const struct rb_node *); extern void rb_replace_node(struct rb_node *victim, struct rb_node *new,\tstruct rb_root *root); extern void rb_replace_node_rcu(struct rb_node *victim, struct rb_node *new,\tstruct rb_root *root); …… //也参linux-4.8.8/lib/rbtree.c static __always_inline void__rb_insert(struct rb_node *node, struct rb_root *root,\tvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new)); 红黑树在处理器调度中的应用 // linux-4.8.8/include/linux/sched.h …… struct sched_entity { struct load_weight\tload; struct rb_node\trun_node; …… #ifdef CONFIG_FAIR_GROUP_SCHED int\tdepth; struct sched_entity\t*parent; struct cfs_rq\t*cfs_rq; …… #endif …… }; // linux-4.8.8/kernel/sched/sched.h struct cfs_rq { struct load_weight load; unsigned int nr_running, h_nr_running; u64 exec_clock; u64 min_vruntime; #ifndef CONFIG_64BIT u64 min_vruntime_copy; #endif struct rb_root tasks_timeline; struct rb_node *rb_leftmost; struct sched_entity *curr, *next, *last, *skip; …… }; 循环缓冲\n解决生产者和消费者数据传输问题的经典模型\n数据元素传输后其他数据元素无需前移故而高效\nLinux 内核循环缓冲实现\n//linux-4.8.8/include/linux/kfifo.h struct __kfifo { unsigned int\tin; unsigned int\tout; unsigned int\tmask; unsigned int\tesize; void\t*data; }; #define INIT_KFIFO(fifo) …… #define DEFINE_KFIFO(fifo, type, size) …… static inline unsigned int __must_check__kfifo_uint_must_check_helper(unsigned int val) { … } static inline int __must_check__kfifo_int_must_check_helper(int val) { … } #define kfifo_alloc(fifo, size, gfp_mask) …… "},{"id":8,"href":"/docs/Advanced-OS/class-notes/4-Linux%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"4 Linux处理器及内存管理","section":"Class Notes","content":" Linux 进程/线程管理控制 # 进程与线程 # 为什么要引入进程？\n单道环境 =\u0026gt; 多道环境 单道环境及计算机系统各类资源的利用率 多道环境及计算机系统资源利用率的提高 计算机不同部件成本与运行速度的差异性、计算机处理任务本身所需操作部件的差异性以及由此导致的计算机不同部件即资源利用的不平衡性 通过多道程序的并发执行（支持） 实现计算机系统资源利用效率的最大化 引入进程概念（由特定的程序及相关联的进程控制块所组成）来描述并发执行程序的动态运行过程，解决由此引发的资源共享问题 进程及其与程序之间的区别与联系?\n程序的动态执行过程 系统资源分配的独立单位 进程标识符、进程控制块 与程序之间的区别（动态/静态性、生命周期、是否支持并发、组成） 进程控制块中的内容？\n标识符 调度信息、控制信息 资源信息 为什么要引入线程？\n进程并发执行基础（资源拥有 + 调度分派） 进程创建、切换和撤销等操作时空开销较大 进程并发执行程度及进程间通信效率受限 事务处理软件、数据库处理软件、窗口系统及操作系统自身对系统并发程度进一步提高的客观需求，而且有关需求呈现出多项任务处理同组数据（存储资源）的特征 解决方案：（非处理器）资源拥有与（处理器）调度分派两类特性的分离 线程与进程间的区别与联系？\n轻型实体及共享进程资源 独立调度和分派的基本单位 创建、撤销、切换等系统开销 地址空间共享及通信效率 系统并发执行程度大大提高 UNIX/Linux 进程 # UNIX 进程\n进程映像的概念 处理器映像 + 内存映像 + 进程控制块 + 程序（用户程序 内核程序） 数据段（静态/全局数据）+ 代码段 + 工作区（栈 + 堆） proc 结构 user 结构 共享代码段 proc 结构体数组\nstruct proc { char p_stat;\t/*进程状态*/ char p_flag;\t/*进程特征，含SLOAD标志位*/ char p_pri;\t/*进程优先数*/ char p_uid;\t/*用户标识符*/ char p_time;\t/*驻留时间*/ char p_cpu;\t/*占用CPU时间*/ char p_nice;\t/*计算优先数时用，[-20,19]*/ int p_pid;\t/*进程标识符*/ int p_ppid;\t/*父进程标识符*/ int p_addr;\t/*进程映像数据分部地址，由此可以找到user结构*/ int p_size;\t/*进程映像数据分部大小*/ int p_wchan;\t/*等待原因*/ int p_textp;\t/*代码段所在的共享段表项text的地址*/ char p_sig;\t/*软中断号*/ int p_ttyp;\t/*控制终端tty结构的地址*/ }proc[NPROC]; UNIX 进程 user 结构体\nstruct user { int u_rsav[2];\t/*保留现场保护区指针r5和r6值*/ int u_fsav[2];\t/*保存fp注册器*/\tchar u_segflg;\t/*用户/核心空间标志*/ char u_error;\t/*返回出错代码*/ char u_uid;\t/*有效用户标识符*/ char u_gid;\t/*有效组标识符*/ char u_ruid; /*真实用户标识符*/ char u_rgid; /*真实组标识符*/ int u_procp;\t/*proc结构地址，与proc结构链接*/ char *u_base;\t/*读写文件时的内存地址参数*/ char u_count;\t/*读写文件时的传送字节数参数*/ char u_offset[2]; /*文件读写位移参数*/\tint *u_cdir;\t/*当前目录i节点地址*/ char *u_dirp;\t/*i节点当前指针*/ char *u_dbuf[DIRSIZ]; /*当前路径名组件（文件名和路径名） */ int *u-pdir; /*父目录*/ int u-uisa[16]; /*进程相对虚、实地址映射表*/ int u-uisd[16]; int u_ofile[NOFILE]; /*用户打开文件表，NOFILE默认为15*/ int u_arg[5];\t/*保存系统调用的参数*/ int u_tsize;\t/*代码段大小*/ int u_dsize;\t/*用户数据段大小*/ int u_ssize;\t/*用户栈大小*/ int u-sep; /*I和D分离标志 */ int u-qsav[2]; /*进程放弃CPU时的现场保护信息*/ int u-ssav[2]; int u-signal[NSIG]; /*用于设置收到信号后的动作*/ int u_utime;\t/*用户态执行时间*/ int u_stime;\t/*核心态执行时间*/ int u_cutime;\t/*子进程用户态执行时间*/ int u_cstime;\t/*子进程核心态执行时间*/ int *u_ar0;\t/*当前中断保护区内r0的地址*/ int u-prof[4]; /*统计程序各部分的执行频率 */ char u-intflag； /*来自系统内核栈的进程特征标志 */ } user; struct { int u_ino;\tchar u_name[DIRSIZ];\t} u_dent;\t/*当前目录项*/ 字段 描述 u-prof[0] 统计表起始地址 u-prof[1] 统计表长度即代码分组数 u-prof[2] 被统计程序代码起始地址 u-prof[3] 比例尺大小即每个代码分组所含指令数的倒数 UNIX 共享段表\nstruct text { int x_daddr;\t/*磁盘地址*/ int x_caddr;\t/*内存地址*/ int x_size;\t/*内存块数*/ int *x_iptr;\t/*文件内存i节点地址*/ char x_count;\t/*共享进程数*/ char x_ccount;\t/*内存副本的共享进程数*/ } text[NTEXT]; UNIX 进程控制用数据结构\nLinux 进程控制块所含信息\n进程执行状态 运行/就绪态、挂起状态、阻塞状态、僵死状态 调度信息 优先级（普通进程、实时进程）、时间片 标识符 进程标识符、用户标识符、组标识符 进程间通信相关信息 链接信息 父进程、兄弟进程、子进程 时间和定时器 进程创建时间、消耗处理器时间、定时器 文件系统相关信息 文件打开指针、当前目录指针、根目录指针 地址空间 虚拟地址空间 处理器相关信息 组成进程上下文的寄存器及栈信息 UNIX/Linux 进程状态演化 # UNIX 进程表项之 p_stat 与 p_flag\np_stat NULL\t0\t此 proc 结构为空 SSLEEP\t1\t高优先权睡眠状态、 SWAIT\t2\t低优先权睡眠状态 SRUN\t3\t运行或就绪态，仅当运行态时其 user 结构在内存 SIDL\t4\t进程创建时的过渡状态 SZOMB\t5\t进程终止前状态（僵死状态），等待善后处理 SSTOP\t6\t进程正被跟踪即暂停/挂起状态 p_flag (SLOAD = 01 表示在内存中时) SSYS\t02\t常驻内存的系统进程（0#进程）标志 SLOCK\t04\t进程被锁，不能调出内存 SSWAP\t010\t交换标志 STRC\t020\t进程正被跟踪标志 SWTED\t040\t关于进程跟踪的另一标志 UNIX 进程状态转换： Linux 进程状态转换：\nUNIX/Linux 进程创建与执行 # 进程创建及相关函数\nint fork( ); 创建子进程 返回值=0，表明创建成功，返回到子进程继续执行 返回值\u0026gt;0，表明创建成功，返回到父进程继续执行，其值为子进程的 PID 号 返回值=-1，表明创建失败 ==在父进程中 fork 的返回值是子进程的 PID。在子进程中 fork 的返回值是 0== int getpid( ); 获取本进程标识符 int getppid( ); 获取父进程标识符 int wait( ); 等待子进程结束 成功则返回子进程标识符 线程通讯、wait和sleep 区别?sleep(0) vs wait(0)有什么区别_wait(null)与wait(0)区别-CSDN博客\nint fork( ); 子进程创建步骤\n（1）申请空闲 PCB，除子进程特有信息（如 p-pid）外，均复制父进程的相应信息（譬如文件打开表及资源） （2）申请空闲内存区，复制父进程的进程映像数据分部，包括数据段、内核栈、用户栈和 user 结构体 （3）共享父进程的共享段表项 text （4）从 fork 系统调用返回主调函数 fork() 调用及进程创建问题\n程序顺序逻辑结构而非分支判断或循环结构中多次调用 fork()，譬如 n 次，则整个程序运行过程所执行的进程数为 $2^n$ 当程序需要创建若干子进程，而不想创建孙子进程时，应当将 fork() 调用放入父进程的程序空间也即 fork() 调用返回值判断大于 0 成立时的条件分支中 fork() 调用的位置即所在程序段非常重要，直接关系到其所创建进程在整个进程家族中的逻辑地位 进程加载程序代码 exec()\nfork() 创建的子进程虽然与其父进程拥有不同的进程映像，但其程序却未发生改变 exec() 系统调用可在当前进程上运行新程序，其主要功能是将指定的可执行文件加载到指定的进程映像中，并覆盖掉原有程序 exec 族系统调用共有六种函数 子进程可以选择执行特定程序，但是不能使用 exec 调用父进程 除非 exec 调用失败，否则对应进程将不会返回旧程序 Linux 线程与进程控制\nLinux 独特的线程实现方案 不严格区分进程与线程 构成同一用户级进程的多个用户级线程将被映射到共享相同组标识符的内核级线程上，于是这些线程就可共享如文件、内存之类的资源，从而避免调度器在同组线程之间切换时进行上下文切换，也即无需进行上下文切换 进程创建采用克隆方式 fork() =\u0026gt; clone() 新进程可共享父进程资源 当两个进程共享相同的虚存资源时，它们就像同一进程的线程一样执行 Linux Clone函数 - charlieroro - 博客园 Linux Clone函数 - charlieroro Linux 内核并发机制 # 并发控制的必要性和重要性 # 可能出现“与时间有关错误”的原因:\n与诸进程的执行速度有关； 由于多个进程都共享了同一变量或者互相需要协调同步； 对于变量的共享或者互相协作的进程没有进行有效的控制 操作系统内核功能自身需要\n各类资源管理的基本依据暨相关数据结构譬如可用内存空间大小等均为共享数据，在各进程进行资源申请（分配）和释放（回收）时会发生并发访问的情况\n操作系统必须提供有效可靠的并发控制机制，保证上述并发处理的正确协调 Linux 提供互斥、同步、通信机制\nLinux 并发控制触发机制 # 早期不支持对称多处理器体系结构的 Linux\n中断服务程序是导致并发访问的因素 只有发生中断或内核代码路径上显式要求重新调度和执行另一进程时，才会发生并发访问 支持对称多处理器体系结构的 Linux\n并发运行在不同处理器上的多个内核线程完全有可能在同一时刻并发访问共享数据，并发访问随时可能发生 现代 Linux 内核已支持内核抢占，调度器可以抢占正在运行的进程而重新调度执行其他进程 内核中的并发源\n中断 中断发生后，中断处理程序和被中断程序之间 中断处理时通常会禁用所有中断或禁用当前级别以下的所有中断，但若时间太长可能造成事件错失，于是产生了上 - 下协同机制 top-half\u0026amp;bottom-half 软中断请求（softirq）和小任务（tasklet） 随时可能被调度，从而打断当前进程 invoke_softirq() 或 ksoftirqd() 触发执行软中断 内核抢占 调度器支持可抢占特性，将会导致进程与进程之间的并发 多处理器并发执行 多处理器上可以同时运行多个进程 单处理器系统内核中并发\n中断处理程序 可以打断软中断、小任务和进程的执行 软中断请求和小任务 软中断请求间不会并发，但会打断进程的执行 支持抢占的内核 不同进程之间会产生并发 不支持抢占的内核 不同进程之间会否产生并发？ 会：主动放弃处理器情形也会触发重新调度 SMP 系统内核中的并发\n不同类型的中断处理程序之间可能并发 不同类型的中断处理程序可被不同处理器执行 同一类型的中断处理程序不会并发 同一类型的软中断可能在不同处理器上并发 同一类型的小任务是串行执行的 不会在多个处理器上并发 不同处理器上的进程会并发执行 并发访问潜在漏洞\n进程上下文操作某临界资源时发生中断，而恰巧某中断处理程序也访问了该资源 进程上下文访问临界资源时发生抢占调度 在自旋锁临界区中主动睡眠让出处理器 两个处理器同时修改同一临界资源 关键考虑什么呢？ 包括静态局部变量、全局变量、共享数据结构、缓存、链表、红黑树等所隐含的资源数据 资源数据的访问路径 UNIX/Linux 并发同步机制 # 并发访问之同步必要性\n问题场景 一个进程在操作某临界资源时发生中断而某中断处理程序恰巧也访问该临界资源 进程在访问某临界资源时发生被抢占调度，而另一进程也恰巧访问该临界资源 解决方案关键要领 找出应被保护资源或数据（静态局部/全局变量、共享数据结构/缓存/链表/红黑树等） 检查确认可能并发访问上面被保护资源或数据的代码段（也即临界区） UNIX 并发同步机制\n管道 环形缓冲，生产者 - 消费者模型，读写操作 消息 消息队列及消息的发生与接收 共享存储器 使用者进程自备互斥机制 信号量 进程间同步操作 信号（用于通知另一进程发生了异步事件） Linux 并发同步机制\n原子操作 保证变量操作指令代码片段的“原子”般执行 自旋锁 忙 - 等待模式，分为基本自旋锁和读者 - 写者自旋锁 信号量 二元信号量、计数型信号量、读写型信号量 内存屏障 预防内存访问的越界 R- CU（read-copy-update）及等待队列 Linux- 原子操作 # 原子操作执行既不会被中断，也不会被干扰\n单处理器系统中，线程对原子操作的执行一旦启动将一直到完成，期间不会被中断 多处理器系统中，被操作的变量会被上锁以防止其他线程的访问，直到对应操作完成 Linux 内核提供两类原子操作\n整数操作，针对整数变量 位图操作，针对位图的某一位 实现 Linux 的任何体系结构，均须支持这些原子操作（汇编指令或内存总线上锁方式）\nLinux 原子数据类型\n//Linux-4.8.8/include/linux/types.h typedef struct { int counter; } atomic_t; #ifdef CONFIG_64BIT typedef struct { long counter; } atomic64_t; #endif 整数原子操作\n#define __raw_cmpxchg(ptr, old, new, size, lock) \\ ({\t\\ __typeof__(*(ptr)) __ret;\t\\ __typeof__(*(ptr)) __old = (old);\t\\ __typeof__(*(ptr)) __new = (new);\t\\ switch (size) {\t\\ case __X86_CASE_B:\t\\ { volatile u8 *__ptr = (volatile u8 *)(ptr);\t\\ asm volatile(lock \u0026#34;cmpxchgb %2,%1\u0026#34;\t\\ : \u0026#34;=a\u0026#34; (__ret), \u0026#34;+m\u0026#34; (*__ptr)\t\\ : \u0026#34;q\u0026#34; (__new), \u0026#34;0\u0026#34; (__old)\t\\ : \u0026#34;memory\u0026#34;);\t\\ break;\t\\ }\t\\ case __X86_CASE_W: { ...... }\t\\ case __X86_CASE_L: { ...... }\t\\ case __X86_CASE_Q: { ...... }\t\\ default:\t__cmpxchg_wrong_size();\t\\ }\t\\ __ret;\t\\ }) 位图原子操作\n//Linux-4.8.8/include/asm-generic/bitops/atomic.h static inline void set_bit(int nr, volatile unsigned long *addr) { unsigned long mask = BIT_MASK(nr); unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr); unsigned long flags; _atomic_spin_lock_irqsave(p, flags); *p |= mask; _atomic_spin_unlock_irqrestore(p, flags); } static inline void clear_bit(int nr, volatile unsigned long *addr) static inline void change_bit(int nr, volatile unsigned long *addr) static inline int test_and_set_bit(int nr, volatile unsigned long *addr) static inline int test_and_clear_bit(int nr, volatile unsigned long *addr) static inline int test_and_change_bit(int nr, volatile unsigned long *addr) Linux- 自旋锁 # 基本自旋锁\n朴素型 plain static __always_inline void spin_lock(spinlock_t *lock) 禁止内核抢占，preempt_disable();preempt_enable(); 在单处理机环境中可以使用特定的原子级汇编指令 swap 或 test_and_set 实现进程互斥；多 CPU 环境中可通过“锁总线”（bus locking）的形式保证 test_and_set 指令执行的原子性，因为 test_and_set 指令对内存的两次操作都需要经过总线 Linux 自旋锁类型\n//Linux-4.8.8/include/linux/spinlock_types.h typedef struct spinlock { union { struct raw_spinlock rlock; #ifdef CONFIG_DEBUG_LOCK_ALLOC # define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map)) struct { u8 __padding[LOCK_PADSIZE]; struct lockdep_map dep_map; }; #endif }; } spinlock_t; typedef struct raw_spinlock { arch_spinlock_t raw_lock; #ifdef CONFIG_GENERIC_LOCKBREAK unsigned int break_lock; #endif #ifdef CONFIG_DEBUG_SPINLOCK unsigned int magic, owner_cpu; void *owner; #endif #ifdef CONFIG_DEBUG_LOCK_ALLOC struct lockdep_map dep_map; #endif } raw_spinlock_t; #ifdef CONFIG_QUEUED_SPINLOCKS #include \u0026lt;asm-generic/qspinlock_types.h\u0026gt; #else typedef struct arch_spinlock { union { __ticketpair_t head_tail; struct __raw_tickets { __ticket_t head, tail; } tickets; }; } arch_spinlock_t; 中断请求型 static __always_inline void spin_lock_irq(spinlock_t *lock) 中断请求保护型 #define spin_lock_irqsave(lock, flags) …… / static __always_inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags) 禁止内核抢占， 关闭中断，保存中断状态寄存器标志位 preempt_disable(); local_irq_save(flags); 后半部分型 static __always_inline void spin_lock_bh(spinlock_t *lock) 用来关闭/开放软中断 local_bh_disable() local_bh_enable() 读者 - 写者自旋锁\n支持内核空间更大程度的并发 每个读者 - 写者自旋锁由一个 24 位读者计数器和一个开关锁标志组成 队列自旋锁\n自旋锁理解：就是一个 while 循环，在不需要 OS 进行进程和线程调度的情况下进行自旋等待 看完你就明白的锁系列之自旋锁 - 程序员cxuan - 博客园\nLinux 读写自旋锁操作\n/linux-4.8.8/include/linux/rwlock.h #define rwlock_init(lock) ...... #define read_lock(lock) ...... #define read_unlock(lock) ...... #define write_lock(lock) ...... #define write_unlock(lock) ...... #define read_lock_irq(lock) ...... #define read_unlock_irq(lock) ...... #define write_lock_irq(lock) ...... #define write_unlock_irq(lock) ...... Linux- 信号量 # 计数型信号量\n//linux-4.8.8/include/linux/semaphore.h struct semaphore { raw_spinlock_t\tlock; unsigned int\tcount; struct list_head\twait_list; }; void sema_init(struct semaphore *sem, int val); void down(struct semaphore *sem); void up(struct semaphore *sem); int __must_check down_interruptible(struct semaphore *sem); int __must_check down_killable(struct semaphore *sem); int __must_check down_trylock(struct semaphore *sem); int __must_check down_timeout(struct semaphore *sem, long jiffies); 互斥锁\nstruct mutex { atomic_t\tcount; spinlock_t\twait_lock; struct list_head\twait_list; #if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER) struct task_struct\t*owner; #endif #ifdef CONFIG_MUTEX_SPIN_ON_OWNER struct optimistic_spin_queue osq; #endif #ifdef CONFIG_DEBUG_MUTEXES void\t*magic; #endif #ifdef CONFIG_DEBUG_LOCK_ALLOC struct lockdep_map\tdep_map; #endif }; 其中的 spinlock 代表了在互斥锁的实现中，通常会使用自旋锁来保护一些关键操作，以确保在多线程环境中的原子性，并不是直接代表互斥锁是由自旋锁实现的，二者是不同的并发同步机制。\n读写型信号量\n//linux-4.8.8/include/linux/rwsem.h struct rw_semaphore { atomic_long_t count; struct list_head wait_list; raw_spinlock_t wait_lock; #ifdef CONFIG_RWSEM_SPIN_ON_OWNER struct optimistic_spin_queue osq; struct task_struct *owner; #endif #ifdef CONFIG_DEBUG_LOCK_ALLOC struct lockdep_map\tdep_map; #endif }; Linux- 内存屏障 # 预防内存读写访问的越界 #define mb()\tbarrier() 或 dsb() 或 do { dsb(); arm_heavy_mb(); } while (0) #define __smp_mb()\tdmb(ish) 预防内存读访问的越界 #define rmb() dsb() #define __smp_rmb()\t__smp_mb() 预防内存写访问的越界 #define wmb() barrier() 或 dsb(st) 或 do { dsb(st); arm_heavy_mb(); } while (0) #define __smp_wmb()\tdmb(ishst) Linux-RCU 读时复制更新 # 已有其他机制存在的问题\n均使用了原子操作指令，多处理器争用共享变量会增大缓存一致性的复杂性并导致性能下降 [[MiniOB事务#^755b43|允许多个线程同时读，并运行一个线程同时修改链表]]\n读者线程几乎无同步开销 写者线程负责同步协调并创建副本实施修改，且等所有读者线程完成后才会把旧数据销毁掉 重要应用场景\n有效提高链表中遍历读取数据的效率 Linux- 等待队列 # 本质上是双向链表\n当运行进程需要获取某资源遭遇不可用情况时，可把该进程插入等待队列以等待对应资源的释放，这时进程进入睡眠状态\n简单应用实现 # 互斥锁应用编程\nvoid* thread_executive(void* zThreadName) { int nRandom, nTemp1, nTemp2; int i; char *pThreadName = (char*)zThreadName; for (i=0; i\u0026lt;1000; i++) { nRandom = rand(); pthread_mutex_lock(\u0026amp;mutex); nTemp1 = nAccount1 - nRandom; nTemp2 = nAccount2 + nRandom; nAccount1 = nTemp1; nAccount2 = nTemp2; pthread_mutex_unlock(\u0026amp;mutex); printf(\u0026#34;[%s] Loop #%d: nAccount1 = %d, nAccount2 = %d\\n\u0026#34;, pThreadName, i, nTemp1, nTemp2); } return NULL; } #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; pthread_mutex_t mutex; int nAccount1=0, nAccount2=0; int main(void) { pthread_t thread1; pthread_t thread2; srand(time(NULL)); pthread_mutex_init(\u0026amp;mutex, NULL); pthread_create(\u0026amp;thread1, NULL, thread_executive, \u0026#34;thread1\u0026#34;); pthread_create(\u0026amp;thread2, NULL, thread_executive, \u0026#34;thread2\u0026#34;); pthread_join(thread1, NULL); pthread_join(thread2, NULL); pthread_mutex_destroy(\u0026amp;mutex); return 0; } 信号量应用编程\n生产者 - 消费者问题 循环缓冲 buffer[N] 输入输出指针 in=0; out=0; 信号量设置及相关操作函数 信号量 mutexP、mutexC、empty、full int sem_init(sem_t *sem, intpshared, unsigned intvalue); int sem_wait(sem_t *sem); int sem_post(sem_t*sem); int sem_destroy(sem_t*sem); #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;semaphore.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 5 typedef int ITEM; ITEM buffer[N]; int in=0, out=0; sem_t empty, full, mutexP, mutexC; void* executive_producer(void* zThreadName) { int nextP, i; char *pThreadName = (char*)zThreadName; for (i=0; i\u0026lt;30; i++) { nextP = rand(); sem_wait(\u0026amp;empty); sem_wait(\u0026amp;mutexP); buffer[in] = nextP; printf(\u0026#34;[%s] Loop #%d: PRODUCING %d =\u0026gt; buffer[%d] \\n\u0026#34;, pThreadName, i, nextP, in); in = (in+1) % N; sem_post(\u0026amp;mutexP); sem_post(\u0026amp;full); } return NULL; } void* executive_consumer(void* zThreadName) { int nextC, i; char *pThreadName = (char*)zThreadName; for (i=0; i\u0026lt;20; i++) { sem_wait(\u0026amp;full); sem_wait(\u0026amp;mutexC); nextC = buffer[out]; printf(\u0026#34;[%s] Loop #%d: CONSUMING nextC \u0026lt;= buffer[%d] = %d\\n\u0026#34;, pThreadName, i, out, nextC); out = (out+1) % N; sem_post(\u0026amp;mutexC); sem_post(\u0026amp;empty); } return NULL; } int main(void) { #define nP 3 #define nC 5 int i; char threadProducerName[nP][10]; char threadConsumerName[nC][10]; pthread_t thread_producer[3]; pthread_t thread_consumer[5]; srand(time(NULL)); sem_init(\u0026amp;mutexP, 0, 1); sem_init(\u0026amp;mutexC, 0, 1); sem_init(\u0026amp;empty, 0, N); sem_init(\u0026amp;full, 0, 0); for (i=0; i\u0026lt;nP; i++) { sprintf(threadProducerName[i], \u0026#34;producer%d\u0026#34;, i); pthread_create(\u0026amp;thread_producer[i], NULL, executive_producer, threadProducerName[i]); } for (i=0; i\u0026lt;nC; i++) { sprintf(threadConsumerName[i], \u0026#34;consumer%d\u0026#34;, i); pthread_create(\u0026amp;thread_consumer[i], NULL, executive_consumer, threadConsumerName[i]); } for (i=0; i\u0026lt;nP; i++) pthread_join(thread_producer[i], NULL); for (i=0; i\u0026lt;nC; i++) pthread_join(thread_consumer[i], NULL); sem_destroy(\u0026amp;mutexP); sem_destroy(\u0026amp;mutexC); sem_destroy(\u0026amp;empty); sem_destroy(\u0026amp;full); return 0; } Linux 父子进程间同步编程 # 父子进程间同步编程设计\n父进程等待子进程\n父进程使用 wait() 等待子进程的终止 子进程终止时执行 exit() 向父进程发终止信号 子进程等待父进程\n子进程使用 signal() 预置特定软中断信号的处理函数，并在该函数中编码设计影响自身运行逻辑流程的代码方案，然后在运行过程中接受/等待父进程利用 kill() 发出的软中断信号，进而触发软中断处理函数的执行和改变代码运行轨迹 wait() 与 exit() 用法\npid_t wait(int *status); 用于暂停主调进程的执行以等待其子进程终止 参数 status 用于存放子进程终止时的终止信号值 返回值为终止子进程的进程标识符，无则返回 -1 pid_t waitpid(pid_t pid, int *status, int options); 用于等待 pid 指定子进程的终止 void exit(int status); 用于终止主调进程，status \u0026amp; 0377 结果发给父进程 所需头文件 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; 软中断信号机制及用法\n操作系统用来通知进程有事件发生，是最基本的进程间通信机制，其提供了一种简单的处理异步事件的方法\n注意这种信号类似于中断总是在进程处于运行状态时才会去响应，故称之为软中断信号\n进程在接收软中断信号之前必须先使用 signal() 进行预置，以便将其与某处理函数关联；当信号发出并被对应进程接收后，系统就中断该进程执行，转而执行与相应信号关联的函数，待函数执行完毕后再返回被中断进程继续执行\n除了用户自定义信号 SIGUSR1 和 SIGUSR2 外，其它软中断信号都已经由操作系统预置了相应的处理函数；用户进程中如果对这些软中断信号进行预置，则会使有关信号与新的函数相关联；当相关软中断信号被接收时，被转去执行的将不再是操作系统预置的处理函数，而是用户对该软中断信号重新预置后的处理函数\n同一个软中断信号可以通过多个 signal() 系统调用，分别与不同的处理函数进行关联；系统在响应该软中断信号时，执行的是当前/最近预置的处理函数，从而实现了同一软中断信号在不同的情况下可转向不同的处理函数去执行\nsignal() 与 kill() 用法\nsighandler_t signal(int signum, sighandler_t handler);\n#include \u0026lt;signal.h\u0026gt; typedef void (*sighandler_t)(int); 用于建立软中断信号与其处理函数之间的关联 int kill(pid_t pid, int sig);\n#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;signal.h\u0026gt; 用于向 pid 指定进程或进程组发送 sig 指定的信号 pid\u0026gt;0 将信号发送给 pid 指定的进程； pid=0 将信号发送给同组的所有进程； pid=-1 将信号发送给进程用户标识符等于发送进程有效用户标识符的所有进程 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int nStopLoop=0; //定义循环变量 void soft_interrupt_handler(int sig) //定义软中断处理函数 { nStopLoop = 1; //修改循环变量的值为1\t} int main(void) { signal(SIGINT,soft_interrupt_handler);\t//预置软中断信号对应处理函数-位置1 //循环显示，等待键入Ctrl+C，获取该软中断信号后转软中断处理函数执行 while (!nStopLoop)\tprintf(\u0026#34;I\u0026#39;m running!\\t\u0026#34;); signal(SIGINT,soft_interrupt_handler);\t//预置软中断信号对应处理函数-位置2 printf(\u0026#34;\\n\u0026lt;======I stop running!======\u0026gt;\\n\u0026#34;); exit(0); return 0; } 第一种由于在循环前预置，所以可以被运行 第二种在循环后预置，相当于预置自己的失败，所以直接被系统 ctrl c 接管 父子进程对话同步实例\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;wait.h\u0026gt; int nStopLoop=0; //定义循环变量 void soft_interrupt_handler(int sig) { nStopLoop = 1; } int main(void) { int pid; signal(SIGUSR1, soft_interrupt_handler); while ((pid=fork())==-1); if (pid\u0026gt;0) { printf(\u0026#34;[FJC=%d]: How are you?\\n\u0026#34;, getpid()); kill(pid, SIGUSR1); wait(0); printf(\u0026#34;[FJC=%d]: I\u0026#39;m fine too.\\n\u0026#34;, getpid()); } else { while (!nStopLoop); printf(\u0026#34;[ZJC=%d]: Fine, thanks. And you?\\n\u0026#34;, getpid()); exit(0); } return 0; } Linux 内存管理 # 操作系统内存管理\n硬件【内存条（物理地址空间）+ 内存管理部件】 内存管理包括内存分配与回收、地址映射、内存保护、内存扩充四个方面 Linux 内存管理核心功能\n内存分配与回收、页表等内存管理结构及操作、缺页异常处理 Linux 内存管理探析技术路线\n从 Shell 命令看内存布局、从应用程序看进/线程内存管理模型、从内核源码看内存管理实现机制 Linux 内核镜像内存布局\n(深入理解计算机系统) bss段，data段、text段、堆(heap)和栈(stack) - 跑马灯的忧伤 - 博客园\n_bss_stop 内核镜像 BSS 段的起始地址和结束地址，包含了初始化为 0 的所有静态全局变量 bss 段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。 bss 是英文 Block Started by Symbol 的简称。 bss 段属于静态内存分配。 _edata 内核镜像数据段的起始地址和结束地址，包含了内核大部分已初始化的数据 数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。 数据段属于静态内存分配。 __init_begin 内核镜像初始化数据段的起始地址和结束地址，包含了大部分内核模块初始化数据 _etext or _text 内核镜像代码段的起始地址和结束地址，包含了编译后的内核代码 代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。 这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读 (某些架构也允许代码段为可写，即允许修改程序)。 在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 Linux 进程内存空间布局\nNULL 无效的节，也即没有关联的节 NOTE 包含提示信息的节 RELA 包含重定位表的节 PROGBITS 包含程序所需数据或代码且格式与含义由程序决定 NOBITS 不占用文件空间，仅提供地址偏移信息，用于存放那些未初始化的全局变量，譬如.bss 分段 INIT_ARRAY 函数指针数组，数组各元素对应函数执行初始化工作，在主函数 main 之前执行 FINI_ARRAY 函数指针数组，数组各元素对应函数执行善后扫尾工作，在主函数 main 之后执行 SYMTAB 符号表，链接时会用到 STRTAB 字符串表 .shstrtab Section Header String Table Linux 进程 -ELF 程序头\nLOAD 可加载的段 NOTE 与加载的相关系统环境信息 TLS Thread Local Storage C 标准库常用内存管理函数\nvoid *malloc(size_t size); void free(void *ptr); void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length); int getpagesize(void); int mprotect(void *addr, size_t len, int prot); int mlock(const void *addr, size_t len); int munlock(const void *addr, size_t len); int madvise(void *addr, size_t length, int advice); Linux 启动与内存空间布局 # UNIX 进程存储管理 # 进程空间可划分为核心态和用户态两部分\nUNIX 进程虚实地址映射机制\n两组内存管理寄存器：KISA 和 KISD 用于核心态，UISA 和 UISD 用于用户态；每组包含 8 对 16 位长的寄存器 程序状态字寄存器 PSW 包含有指示机器执行状态的位 KISA 和 UISA 用于存放逻辑页在内存的首地址 KISD 和 UISD 用于存放相应页面的属性，关键位域包括： 位 1~2 描述存取控制属性 ACF，譬如只读、可读写等； 位 3 描述页扩展方向 ED，0/1 指示由低/高址向高/低址扩展； 位 6 描述页面是否修改过 M 位 8~14 描述页面的实际使用大小 PLF，指向虚页可用的最后一块内存字符块号，具体采用补码表示，便于越界检查 若 ED＝0，表示页使用由低到高扩展，于是 PLF＝实际使用大小－1； 若 ED=1，PLF＝页面大小－实际使用大小 譬如，若 ED＝0 且已使用 32 块，则 PLF＝32－1=31；若 ED=1、页面大小为 128 个内存字符块且实际使用 100 块，则 PLF＝128－100=28。 假设页面大小为128个内存字符块，某进程的数据段使用了3个内存字符块，而用户栈使用了2个内存字符块，试分别给出它们的PLF值？ 数据段由低址向高址扩展，ED=0，故而PLF=3-1=2 栈由高址向低址扩展，ED=1，故而PLF=128-2=126 UNIX 进程核心态虚实地址映射\n核心态下，0~5 及 7#页面映射关系固定，系统生成后就固定不变了，即不随运行进程变化；但 6#页面及 KISA6、KISD6 是不固定的，会随当前运行进程而变化，也即总是指向当前运行进程的 ppda 区 地址映射过程如下： (1) 搜索 proc 表，根据调度策略选中当前进程的 proc[n] (2) 根据 proc[n].p-addr 找到 ppda (3) 建立 ppda 和进程核心态空间第 6 页之间的映射关系，即将 ppda 首址赋给 KISA[6] UNIX 进程用户态虚实地址映射\n假设某进程在用户态下访问的最大虚拟存储空间为 8 页，其中共享正文段占 2.5 页、数据段占 2.25 页、用户栈占 0.5 页。如果每页大小为 128 个内存字符块，则 0.5 页为 64 个字符块，0.25 页为 32 个字符块 假设该进程正文段内存始址为 ta、数据段内存始址为 da，那么该进程 0~5#页面的内存始址分别为 ta、ta+128、ta+256、da、da+128、da+256；用户栈紧靠数据段的下方且由高向低扩展，于是其始址为 da+256+32+64=da+352 UNIX 进程被调度时地址映射\n被调度进程 user 结构体内容加载到内存后，根据 u-uisa[] 的值相应地加上 x_caddr 或 p_addr 后赋给 UISA[]，而 UISD[] 和 u-uisd[] 的值相同\nLinux 进程 - 线程空间探析 # Linux 虚拟/物理地址空间映射\nLinux 内存管理 # 页面 struct page\n内存管理区 struct zone\n页面的分配与释放\nstatic inline struct page* alloc_pages(gfp_t gfp_mask, unsigned int order); void __free_pages(struct page *page, unsigned int order); 内存碎片化解决方案——伙伴算法\n小块内存分配机制\nslob 分配 SLOB（Simple List Of Blocks）分配器，设计小而高效，采用了首次适应算法，存在内部碎片问题；设立小、中、大三个链表分别用来记录管理当前的空闲链表（small list：0~256 字节；medium list：256~1024 字节；large list：1024~Pagesize）；超过页面大小的空间申请直接通过伙伴系统进行分配，无需经过 SLOB 分配器 slab 分配 slub 分配 Slub 内存分配器的特点是简化设计理念，并保留 slab 分配器的核心思想（也即每个缓冲区由多个小的 slab 组成且每个 slab 包含固定数量的对象）；Slub 分配器简化了 kmem_cache、slab 等相关管理型数据结构，摒弃了 slab 分配器中众多的队列概念，针对多处理器、NUMA 系统进行优化，以提高性能和可扩展性并降低内存空间开销 虚拟内存管理之进程地址空间\n内存描述符 struct mm_struct\n内存分配与释放\nmalloc(); mmap(); 缺页异常处理\ndo_page_fault(); 页面淘汰机制\nLRU 算法与页面缓存策略相结合 Linux 处理器及进程调度 # Linux 处理器调度概要 # 处理器调度类型\n长程调度、中程调度、短程调度 处理器调度算法\n先来先服务调度算法、最短时间优先调度算法、时间片轮转调度算法、高响应比优先调度算法、多级反馈队列调度算法、公平型调度算法 最早截止时间调度算法、最低松弛度优先调度算法 处理器调度评价指标\n用户角度、系统角度 Linux 内核基础设施\n进程控制块、进程状态转换 线程及其与进程之间的控制操作关系 Linux 处理器调度算法\nO(n) 调度算法 Linux2.4 内核及以前版本 O(1) 调度算法 Linux2.6 内核 CFS 调度算法 Linux2.6.23 内核 Linux 虚拟机进程调度\nLinux 处理器调度算法 # 基于优先级的时间片轮转调度算法——O(n) 调度算法\n设立一个全局性的就绪队列链表 runqueue（无序） 每个进程被赋予一个固定的时间片；当前运行进程的时间片使用完后，调度器会选择下一就绪进程运行；当所有进程的时间片都用完之后，才会对所有进程重新分配时间片 从中选取下一最佳就绪进程的时间开销与就绪队列所含进程数有关，时间复杂度为 O(n)；当就绪队列中的进程数很多时，选择调度下一就绪进程的过程会变得很慢，从而导致系统整体性能下降 O(1) 调度算法\n每个处理器维护独立的就绪队列，减少了锁竞争 拥有活跃型和过期型两类优先级就绪队列数组 每个优先级就绪队列数组包含 MAX_PRIO 也即 140 个优先级队列，其中前 100 个对应实时进程、后 40 个对应普通进程。这样调度器在调度时，只需在活跃型优先级就绪队列数组中选择优先级最高且非空队列中的队首就绪进程调度运行即可 CFS 调度算法\n抛弃以往固定时间片和固定调度周期的做法，采用进程权重比值来量化和计算实际运行时间 引入虚拟时钟概念，每个进程的虚拟时间是时间运行时间相对于 nice 值为 0 的权重的比例值 进程按照各自不同速率比在物理时钟节拍内前进： nice 值小的进程优先级高、权重大，且其虚拟时钟比真实时钟慢，但可获得较多的运行时间； nice 值大的进程优先级低、权重小，且其虚拟时钟比真实时钟快，所获运行时间少 CFS 调度器总是选择虚拟时钟跑得慢的进程，就像一个多级变速箱：nice 值为 0 的进程是基准齿轮，其它各个进程在不同的变速比下相互追赶，从而达到公平、公正 Linux VServer 虚拟机机制\n提供了一种控制虚拟机使用处理器时间的方式 其在 Linux 标准调度机制上面覆盖了一种令牌桶过滤器 TBF（Token Bucket Filter），以确定每个虚拟机应分配多少处理器执行时间（涵盖单处理器、多处理器、多核处理器） 令牌输入速率（每时间段 T 可传入的令牌数 R） 桶大小 S（达到该值，令牌输入无效） 虚拟机上进程运行，则消耗桶中令牌 最低阈值 M（触发重启和重新调度被停进程） UNIX 进程调度 # UNIX 进程调度功能框架\n确定调度时机 抢占式系统出现高优先权可运行进程，立即让其运行 非抢占式系统中即使出现高优先权可运行进程，也要等到调度时机（即当前运行进程自动放弃 CPU 或由核心态转入用户态）出现时，才让其运行 执行调度算法（确定调度策略、计算优先数），从而选定某一进程运行 完成调度的具体操作过程 让原运行进程退出 CPU 保护退出进程的运行现场 让选中进程占用 CPU 初始化或恢复选中进程的运行现场 进程占用 CPU 时间 p-cpu 统计\n每次时钟中断（20ms）使当前运行进程的 p-cpu 递增即 + 1 每隔一秒（50 次时钟中断）依次检查各进程的 p-cpu 如果 p-cpu ≤ 10，则 p-cpu = 0； 如果 p-cpu \u0026gt; 10，则 p-cpu 的值减 10 后写回 p-cpu p-cpu 与进程调度切换反馈过程 UNIX 进程调度策略\nUNIX 采用基于动态优先数的进程调度策略\n0≤pri≤127，核心态进程优先数∈[0,49]、用户态进程优先数∈[50,127] 核心态进程不可剥夺、用户态进程可剥夺\n例：进程 i 被阻塞时，将陷入睡眠状态，对应优先数 proc[i].p-pri∈[0,49]；其被唤醒时，该值小于用户态进程优先数，故可被优先执行 合作进程唤醒或中断处理程序唤醒 用户态进程优先数 p-pri 动态变化方式\n每秒重新计算一次：50 + ( p-cpu / a) + 2 * p-nice，其中 a = 2, 4, 8, 16 基于动态优先数的进程调度\nwhichqs 以位图方式描述了多级优先级就绪进程队列状况（0 空/1 不空），并选择调度第一非空队列队首进程 UNIX 进程调度操作过程——由两组寄存器进行联合实现\n当前运行进程 i =\u0026gt; 非运行状态【保护现场】\n填写 p-wchan、u-rsav[2] 修改 text 结构中共享正文段进程数 记录用户空间页地址寄存器内容：UISA → u-uisa 记录用户空间页描述符寄存器内容：UISD → u-uisd 所选进程 j 置换为运行状态【恢复现场】\n若映像不在内存：①如内存足够多，则直接调入；②否则根据淘汰策略换出某些内存页面并装入映像 KISA[6] → ppda proc[j].p-addr 写入 KISA[6] 根据 p-textp 找到 text 结构，若 text 不在内存，同样涉及调入和淘汰页面的处理 由 p-addr 或 KISA[6] 找到 user，并执行地址映射 "},{"id":9,"href":"/docs/Advanced-OS/class-notes/5-Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","title":"5 Linux文件管理","section":"Class Notes","content":" 文件及文件系统的引入 # 信息存储问题及要求\n进程运行时内存空间有相应一定量的信息 进程终止时，有关信息将随之消失 一方面有关信息受到内存空间大小的限制 另一方面部分信息需要长久甚至永久保存 常常会有多个进程需要存取同样的信息 信息应当独立于进程而存在 信息存储要求 能够存储大量信息 使用信息的进程终止时，有关信息仍旧存在 支持多个进程并发存取有关信息 信息存储解决方案\n把信息以某种单元即文件的形式存储在磁盘或其他外部介质上 文件是一个具有名字的存储在磁盘上的一组相关信息的集合体，是磁盘的最小逻辑分配单位 文件系统是操作系统中负责管理和存取文件信息的软件机构 管理文件所需的数据结构 实现文件管理的系统程序 文件操作相关系统调用 ls 命令及文件类型\nls -l hello.c -rw-rw-r-- 1 zgs zgs 561 Aug 24 07:31 hello.c d 目录 l 符号链接文件 s 套接字文件 b 块设备文件 c 字符设备文件 p 命名管道文件 - 普通文件 硬链接和软链接文件共享\n建立 DataFile.txt 的硬链接文件 ln DataFile.txt DataFileYLJw 建立 DataFile.txt 的软链接文件 ln -s DataFile.txt DataFileRLJ 删除原数据文件 DataFile.txt 硬连接依旧可行 软连接无法继续输出文件内容 lrwxrwxrwx 1 zhaigaoshou2018 zhaigaoshou2018 12 Nov 6 05:49 DataFileRLJ -\u0026gt; DataFile.txt -rw-rw-r-- 2 zhaigaoshou2018 zhaigaoshou2018 15 Nov 6 05:47 DataFile.txt -rw-rw-r-- 2 zhaigaoshou2018 zhaigaoshou2018 15 Nov 6 05:47 DataFileYLJ 文件基本操作与文件系统 # 创建文件 (creat)\n分配空间 在目录文件中创建新目录项并设置 打开文件 (open)\n写文件 (write) 读文件 (read) 文件检索\n文件存放位置 写入/读取指定信息 读写指针重定位 (relocation/fseek)\n实际上是个偏移量 不涉及 I/O 操作，只是将 r/w 指针定位到某个位置 删除文件 (delete)\n删除目录项 释放文件存储空间 文件内容清空操作 (truncate)\n清除文件内容 释放文件存储空间 文件长度为 0 用户与外设间接口\n用户可按文件名存取，可用虚拟 I/O 指令，而无需考虑文件如何存储或存储在什么地方 文件系统接口 = 文件操作相关系统调用 + 文件操作相关实用例程 文件系统接口向用户提供的抽象元素 文件（file） 目录（directory） 文件描述符（fd，即 file descriptor） 文件系统（支持多种文件系统时，需指明使用了哪种文件系统） 文件系统的系统解读\n统一管理文件的存储空间，实施存储空间的组织、分配与回收 实现文件的按名存取，实现名字空间向存储空间的映射 向用户提供简单方便的使用接口，提供文件系统操作命令以及文件检索与存取操作命令 实现文件信息的共享，并提供文件的保护和保密措施 系统维护及向用户提供有关信息 提供与 I/O 机构的统一接口 文件系统层次模型\n磁盘、分区和文件系统\n磁盘扇区为 512 字节，但输入输出则以更大的盘块为单位 早期 Unix 文件普遍偏小，故设置盘块大小为 1024 字节 4.3BSD 文件系统：一个文件若无索引块，即由 i-addr[ ] 直接索引，那么该文件由两种大小的盘块组成；大块如 8KB、小块如 1KB；文件最后一块为小块大小的整数倍，其余用大块；fileL ＝ n*block 大 ＋ m* block 小 Unix/Linux 文件系统体系结构\nUNIX 文件系统概述\n文件系统特点 采用引入索引结点的分级树型目录组织结构 文件物理结构为混合索引式文件结构 采用成组链接法管理空闲盘块 设立有根目录，并把文件看成字符流集合 支持多种文件系统且用户接口抽象元素相同 文件系统资源管理 目录项、磁盘索引结点项及若干盘块 内存索引结点项 （系统打开）文件表项、用户文件描述符表项 打开文件的系统调用 fd = open(path, mode); fd 通常是一个小整数，为进程打开文件表项的指针/索引 文件描述符表与文件表\n文件物理结构类型 # 文件的逻辑结构和物理结构\n文件的逻辑结构 包括字符流式文件和记录式文件 描述文件的逻辑结构时应包含对文件的存取方法的定义 文件的物理结构 连续文件 链接文件 索引文件 散列文件 文件物理结构——连续文件\n文件物理结构——连续文件 文件物理结构——链接文件 文件物理结构——索引文件 文件的结构组成\n一个文件由文件属性描述和文件体组成 文件属性描述⬄文件控制块 FCB⬄目录项 Unix 内存索引结点 vnode =\u0026gt;Linux 通用 inode 混合索引文件结构与寻址方式\n混合分配方式 (UNIX 系统)\n直接寻址 直接地址项存放对应文件数据的盘块的盘块号 盘块大小 4KB、盘块号占 4B，则支持长度在 4KB×10 = 40KB 以内的文件 一次间接寻址 i.addr(10) 指向对应文件的一级索引块 一级索引块可含 4KB/4B = 1K 个盘块号，故支持长度在 (4KB×1K=4MB)+40KB 以内的文件 多次间接寻址 i.addr(11)、 i.addr(12) 分别指向对应文件的两级索引块和三级索引块，所以支持文件长度可达 (4KB×1K×1K ×1K=4TB)+(4KB×1K×1K=4GB)+4MB+40KB UNIX 文件操作地址转换过程\n将字节偏移量转换为文件逻辑盘块号\nLogicBlk# = Offset / SizeOfBlk 将逻辑盘块号转换为物理盘块号\n确定物理盘块号所在地址项或索引盘块 确定物理盘块号所在索引盘块及位置 举例说明\nOffset 9000B =\u0026gt; LogicBlk# 8 =\u0026gt; i.addr(8) Offset 14000B =\u0026gt; LogicBlk# 13 =\u0026gt; 对应 i.addr(10) 的索引盘块中的第 3 个盘块号 索引结点管理\n超级块 记录磁盘盘块和磁盘索引结点使用情况 含空闲盘块号栈、空闲磁盘索引结点号栈及相应数目与锁字段、修改标志与时间等 磁盘索引结点分配与回收 分配过程 ialloc 回收过程 ifree 内存索引结点分配与回收 分配过程 iget 回收过程 iput UNIX 文件卷组织结构\n系统引导块 0# 用于系统引导或空闲 超级块 1# 文件系统结构信息 (盘块及磁盘索引结点) 磁盘索引结点块 2# ~ K# 存放磁盘索引结点 文件数据块 (K+1)# ~ N# 存放文件数据 假设盘块大小为1KB，索引结点占64字节，则讲索引结 点应位于的物理盘块号为： i*64B/1KB + 2 = [i/16](向下取整) + 2 虚拟文件系统 # Linux VFS\nLinux VFS 实现机制\n面向对象的框架\n基于 C 语言及其结构体类型实现 每个对象包括数据及指向数据操作功能函数的指针两部分组成 Linux VFS 主要对象类型\n超级块对象：表示特定挂载的文件系统 描述了特定文件系统的信息 挂载文件系统的设备、文件系统基本块大小、脏标志、文件系统类型、访问权限、指向文件系统目录根的指针、已打开文件列表、用于控制文件系统的信号量、超级块操作功能函数指针列表 通常对应存放在磁盘上特定扇区的文件系统超级块或文件系统控制块 read_inode、write_inode、put_inode、delete_inode、notify_change、put_super、write_super、statfs、remount_fs、clear_inode 索引结点对象：表示特定文件 描述了每个文件的除文件名和文件所含实际内容之外的所有关联信息 基本信息组成 所有者、用户组、访问权限、文件访问时间、所含数据量多少、链接数、索引结点操作功能函数指针列表 create：为普通文件创建索引结点以关联某目录的目录项对象 lookup：搜索目录以查找对应文件的索引结点 mkdir：创建新的目录型索引结点以关联某目录的目录项对象 目录项对象：表示特定的目录项 描述了文件路径中的特定部件，可为目录名、也可为文件名 可用于目录项缓冲中以方便对文件和目录的访问 基本信息组成 指向索引结点和超级块的指针、指向父目录项的指针、指向各子目录项的指针 d_hash、d_compare、d_delete、d_iput、d_dname、d_release、d_init 文件对象：表示与某进程关联的一个打开的文件 描述了进程打开的一个文件 该对象在执行 open() 系统调用时被创建，在执行 close() 系统调用时被销毁 基本信息组成 与文件关联的目录项对象、包含对应文件的文件系统、文件对象引用计数、用户的用户标识符、用户的组标识符、文件操作指针、文件对象操作功能函数指针列表 read、write、open、release、lock 目录管理及文件共享与保护 # 目录文件由对应目录下所有文件的目录项组成\n文件控制块 = 目录项（文件名 +i 结点编号）+ i-node\n特殊目录及路径名\n根目录 目录层次结构最顶层；无父目录；由根用户拥有 主目录（缩写方式“~”） 用户根目录、登陆时进入；由系统管理员创建 工作目录（缩写方式“.”） 当前目录，是用户会话过程所处的目录 绝对路径名与相对路径名 link 机制 =\u0026gt; 一个文件可以对应多个绝对路径名 文件合法命名规则 文件操作时通配符：“?”、“[…]”、“*” 目录管理\n构造目录过程 creat =\u0026gt; makenode ( ialloc =\u0026gt; wdir ) 删除目录过程 link \u0026amp; unlink 检索目录过程 namei 根据指定路径名顺序搜索各级目录 任一目录文件所有盘块均须查找 找到对应目录文件名后，应继续调入其盘块 检索成功与失败判断 文件共享 - 绕弯路法\n基于基本文件目录实现文件共享 ext2\n文件保护\n指根据不同的用户或进程对文件进行存取权限控制和保密控制\n支持合法用户执行所授权操作 禁止用户执行非授权操作 防止冒充其它用户非法存取文件 防止合法用户误操作/错误使用文件 关键在于访问控制描述及检查验证机制\n存放位置（集中专区、基本文件目录表项） 访问控制矩阵或其简化 访问矩阵的简化策略\n必要性与可行性 访问矩阵存储开销及其稀疏性特征 简化对策 访问控制表 访问权限表 兼有式实现机制 横向级别 文件主，同组用户，其他用户 文件内存映像及系统实现 # UNIX/Linux 文件卷组织结构 # 系统引导块 0# 用于系统引导或空闲 超级块 1#【struct super_block】 文件系统结构信息（分区总容量、空闲盘块数及索引结点数等） 磁盘索引结点块区 2# ~ K# 存放磁盘索引结点【struct ext2_inode】 文件数据块区 (K+1)# ~ N# 存放文件数据 UNIX/Linux 文件系统数据结构 # UNIX 超级块结构 filsys\nstruct filsys { int s-isize;\t//inode区占用盘块数 int s-fsize;\t//磁盘块数 int s-nfree;\t//直接管理的一般存储盘块空闲块数 int s-free[100];\t//空闲盘块索引表暨空闲盘块号栈 int s-ninode;\t//直接管理的空闲索引结点inode数 int s-inode[100];\t//空闲索引结点inode的索引表暨空闲索引结点号栈 char s-flock;\t//空闲盘块号栈的上锁标志 char s-ilock;\t//空闲索引结点号栈的上锁标志 char sfmod; //本信息块已被修改标志 char s-ronly;\t//本文件系统只能读出的标志 int s-time[2];\t//最近一次更新时间 int pad[50]; }; Linux 文件系统信息查看命令 # mount\n文件系统信息查看命令2-2B——考试着重考计算\n8192*256/4096 = 2^13 * 2^8 / 2^12 = 2^9 = 512 盘块组数： 12M/32768 = 12*2^20 / 2^15 = 12*2^5 = 384 Linux 目录项及索引结点结构 # 目录项【struct dentry】 文件名、索引结点指针 外存索引结点【struct ext2_inode】 文件主标识符、存取权限、访问时间、链接计数、物理盘块数、物理盘块号数组（混合索引结构） 内存索引结点 存取权限、访问时间、设备号、等等【struct inode】 外存索引结点的内容【struct ext2_inode_info】 Linux 进程控制块与文件打开表 # 进程控制块【struct task_struct】\n文件打开表指针、…… 文件打开表【struct files_struct】\n文件描述符表、文件描述符表指针、文件控制块指针数组、…\u0026hellip; 文件描述符表【 struct fd_struct】\n文件控制块二级指针 文件控制块【 struct file】\n文件名、索引结点指针、存取权限、文件读写指针、…… //zgs/linux-4.8.8/include/linux/sched.h //进程控制块 struct task_struct { volatile long state; atomic_t usage; unsigned int flags; unsigned int ptrace; …… struct fs_struct *fs; struct files_struct *files; …… }; //zgs/linux-4.8.8/include/linux/fdtable.h //每进程文件打开表 struct files_struct { …… struct fdtable __rcu *fdt; struct fdtable fdtab; …… int next_fd; unsigned long close_on_exec_init[1]; unsigned long open_fds_init[1];\tunsigned long full_fds_bits_init[1]; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; //zgs/linux-4.8.8/include/linux/fdtable.h //文件描述符表 struct fdtable { unsigned int max_fds; struct file __rcu **fd; unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu; }; //zgs/linux-4.8.8/include/linux/fs.h //文件控制块结构 struct file { union { struct llist_node\tfu_llist; struct rcu_head fu_rcuhead; } f_u; struct path\tf_path; struct inode\t*f_inode; const struct file_operations\t*f_op; spinlock_t\tf_lock; atomic_long_t\tf_count; unsigned int f_flags; fmode_t\tf_mode; struct mutex\tf_pos_lock; loff_t\tf_pos; struct fown_struct\tf_owner; const struct cred\t*f_cred; struct file_ra_state\tf_ra; u64\tf_version; #ifdef CONFIG_SECURITY void\t*f_security; #endif …… struct address_space\t*f_mapping; } __attribute__((aligned(4))); Linux 虚拟文件系统实现概要 # 基于 C 的面向对象实现方法\nLinux 文件操作相关系统调用 # 文件创建系统调用例程\ncreatProg.c #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int main() { int fd = creat(\u0026#34;FileCreated.txt\u0026#34;, 0777); return 0; } //文件FileCreated.txt存取权限：-rwxrwxr-x // \u0026lt;= 0777 \u0026amp; ~0002 creat 系统调用基本用法\nint creat(const char *pathName, mode_t mode); 返回值为文件描述符 fd（一般 \u0026gt;=3；失败 -1） mode 为所创建文件的存取权限期望设置 文件实际的存取权限 = (~mask \u0026amp; mode)\nmask 是由 umask 命令规定的文件掩码 mode 一共 12 个二进制位，前三位分别表示 SUID（设置用户标识符位）、SGID（设置用户组标识符位）、sticky（粘附位） 适用于特殊可执行文件（譬如密码修改程序/usr/bin/passwd）针对非授权用户临时提权执行的场合。若对文件设置了 SUID 或 SGID，则运行此文件的进程将拥有与文件所有者/属组相同的操作权限 进程的真实/有效用户标识符\n进程控制块 struct task_struct { …… const struct cred __rcu *real_cred; const struct cred __rcu *cred; …… struct nsproxy *nsproxy; …… }; 容器式轻量级虚拟化技术 基于命名空间来隔离资源 进程用户身份证书 浅谈linux suid提权 - 先知社区 struct cred { ...... kuid_t\tuid; kgid_t\tgid; kuid_t\tsuid; kgid_t\tsgid; kuid_t\teuid; kgid_t\tegid; kuid_t\tfsuid; kgid_t\tfsgid; ...... struct user_struct *user; struct user_namespace *user_ns; ...... }; umask 命令及使用效果\n无参方式用于显示当前掩码 一个三位八进制数 加选项 -S 则显示创建后所取得的操作权限 有参方式用于设置掩码 umask [三位八进制数] 缺省未指定存取权限下的掩码效果 所创建目录（mkdir）：~mask 所创建文件（touch）：~mask 并移除所有执行权 文件打开/关闭 - 系统调用\n关于文件打开的系统调用 存取模式：O_RDONLY、O_WRONLY、O_RDWR 文件创建标志：O_CLOEXEC、O_DIRECTORY、O_CREAT、O_EXCL、O_NOCTTY、O_NOFOLLOW、O_TMPFILE、O_TRUNC 文件状态标志：O_APPEND 没有指定任何模式，文件创建采用缺省存取模式，即 110 100 100 000 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); 关于文件关闭的系统调用 如果文件不存在，创建该文件并使用 mode 参数来限定文件的实际访问权限： ~umask \u0026amp; mode #include \u0026lt;unistd.h\u0026gt; int close(int fd); 文件硬链接 - 系统调用\n关于文件硬链接的系统调用 #include \u0026lt;unistd.h\u0026gt; int link(const char *pathnameS, const char *pathnameD); 关于文件链接移除的系统调用 #include \u0026lt;unistd.h\u0026gt; int unlink(int fd); 关于文件读/写的系统调用\n#include \u0026lt;unistd.h\u0026gt; ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, void *buf, size_t count); 文件读写指针移动 - 系统调用\n#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; off_t lseek(int fd, off_t offset, int whence); SEEK_SET 0 SEEK_CUR 1 SEEK_END 2 Linux 管道通信相关系统调用 # UNIX/Linux 管道通信\nUNIX 提供的进程通信方式\n核心态进程之间：使用 sleep/wakeup 实现同步 同一用户的进程之间：使用信号量 (P/V)、消息缓冲区、邮箱、共享存储区实现进程间通信 父子进程之间：通过系统调用 wait/exit 实现同步 任意两个进程之间：管道提供大量信息传输同步 管道通信\n有名管道：不同进程间，使用系统命令 mknod 无名管道：父/子进程之间，使用系统调用 pipe(fd) 管道通信：有名管道（FIFO） 和 无名管道（pipe）-CSDN博客 系统调用 pipe 及系统命令 mknod\n用于创建无名管道的系统调用 #include \u0026lt;unistd.h\u0026gt; int pipe(int pipefd[2]); pipefd[0]用于读管道，pipefd[1]用于写管道 成功返回0，出错返回-1 用于创建管道文件的系统命令 mknod 用于创建字符设备、块设备等特殊文件；p 则指定其创建 FIFO 管道文件。 mknod \u0026lt;管道文件名\u0026gt; p mknod zgsPipe p 管道文件读写同步与互斥 为了协调双方的通信，管道通信机制必须提供同步、互斥和判断对方是否存在等三方面的能力 从原理上讲，进程之间通信如果使用同一文件描述符，通信过程应由用户协调；但如果使用两个文件描述符，则通信过程可由系统协调 0777文件权限的解释 - 掘金\n关于linux下0666和0777权限所代表的意思_权限0777-CSDN博客\n//有名管道例程 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;limits.h\u0026gt; int main() { char zPipeName[10] = \u0026#34;zgs-pipe\u0026#34;; char zFileName[15] = \u0026#34;DataFile.txt\u0026#34;; char buf[PIPE_BUF + 1]; int fdPipe, fdData, zRead, zWrite, zSend = 0; if (access(zPipeName, F_OK) == -1) {if (mkfifo (zPipeName, S_IFIFO|0666) == -1) { printf(\u0026#34;Failed to create pipe[%s] by mkfifo()!\\n\u0026#34;, zPipeName); exit(0); }} fdPipe = open(zPipeName, O_WRONLY); fdData = open(zFileName, O_RDONLY); printf(\u0026#34;Process[%d] open pipe[%s] in WriteOnly mode\\n\u0026#34;, getpid(), zPipeName); if (fdPipe!=-1 \u0026amp;\u0026amp; fdData!=-1) {while ((zRead = read(fdData, buf, PIPE_BUF))\u0026gt;0) {buf[zRead] = \u0026#39;\\0\u0026#39;; if ((zWrite = write(fdPipe, buf, zRead))==-1) {printf(\u0026#34;Failed to write pipe[%s]!\\n\u0026#34;, zPipeName); exit(0); } zSend += zWrite; } close(fdPipe); close(fdData); } printf(\u0026#34;Process[%d] finished writting %d bytes.\\n\u0026#34;, getpid(), zSend); return 0; } int main() {char zPipeName[10] = \u0026#34;zgs-pipe\u0026#34;; char buf[PIPE_BUF + 1]; int fdPipe, zRead, zReceive = 0; memset(buf, \u0026#39;\\0\u0026#39;, sizeof(buf)); fdPipe = open(zPipeName, O_RDONLY); printf(\u0026#34;Process[%d] open pipe[%s] in ReadOnly mode\\n\u0026#34;, getpid(), zPipeName); printf(\u0026#34;The following are contents that Process[%d] have read:\\n\u0026#34;, getpid()); if (fdPipe!=-1) { while ((zRead = read(fdPipe, buf, PIPE_BUF))\u0026gt;0) { buf[zRead] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\u0026#34;, buf); zReceive += zRead; } close(fdPipe); } printf(\u0026#34;Process[%d] finished reading %d bytes.\\n\u0026#34;, getpid(), zReceive); return 0; } "},{"id":10,"href":"/docs/Advanced-OS/class-notes/6-Linux%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","title":"6 Linux设备管理","section":"Class Notes","content":" 设备管理概述 # 最复杂、最多样化的操作系统资源管理模块\n设备并行操作是提高设备利用率关键所在\n依赖于通道和中断机制、设备物理特性的支持 功能范畴\n对计算机系统中（除处理器和内存之外的）外部设备的管理（选择与分配输入输出设备） 实现多任务、多进程对多种设备的共享 对设备相关数据传输过程的控制 实现数据的高效传输（设备与处理器/设备并行） 设备分类\n存储设备（块设备） 计算机用来存储文件信息的设备，如磁/光盘/带 输入输出设备（字符设备） 输入设备，如键盘、鼠标、扫描仪 输出设备，如显示器、打印机、绘图仪 输入输出设备，如电传打字机 网络设备（通过套接字进行数据交换） 在 TCP/IP 协议网络通信中，套接字使用 IP 地址（32 位）和端口号（16 位）共计 48 位来唯一标识具有某个 IP 地址的计算机及其某个端口 设备管理模块功能\n提供进程使用设备的接口 一般为文件系统及文件操作相关系统调用 实施设备的分配与回收 实现设备与设备、设备与处理器之间的并行 依赖于硬件提供的输入输出控制方式 采取有效措施解决处理器与设备的速度差异矛盾、平衡计算机系统的输入输出负荷、提高设备的输入输出效率 缓冲技术、提前读、延迟写、异步写 设备独立性\n指用户在程序中所使用的设备与实际使用的设备无关 操作系统为同类设备设置一个逻辑设备名 当用户以逻辑设备名提出设备请求时，由操作系统的设备管理模块将逻辑设备名转化为具体的物理设备、实现物理设备的分配 优点 方便了用户 提高了系统效率 缓冲管理 # 缓冲及目的\n缓冲是在不同速度的部件之间传输信息时常用来平滑传输过程的技术手段 通常为内存缓冲区，用于暂存输入/输出数据 目的 解决设备与处理器之间以及设备与设备之间的速度不匹配的问题 解决系统中输入输出负荷的不均衡问题 有效减少输入输出（中断）次数，从而提高输入输出速度 分为单缓冲、双缓冲、循环缓冲和缓冲池 缓冲池\n三类缓冲区队列：空缓冲区队列、输入缓冲区队列、输出缓冲区队列 四类工作缓冲区：【收容/提取】【输入/输出】的工作缓冲区 缓冲池管理要旨 空缓冲区的分配与回收 输入/输出设备的输入/输出缓冲区队列管理 缓冲区与进程数据块之间的信息交换 采用内存块拷贝实现机制 缓冲区与设备（内存数据块与设备物理块）之间的信息交换（即设备输入输出） 基于中断的实现方式 中断服务程序实现设备的输入请求处理 对于设备输入过程而言，若还有数据输入请求，则申请空闲缓冲区、启动设备执行输入操作并将所输入的数据暂存到空闲缓冲区中，然后把该装满输入数据的缓冲区挂到设备的输入缓冲区队列上供用户进程拷贝和访问读取；若没有数据输入请求则通知设备结束输入操作，并将该设备重新分配给其他进程 中断服务程序实现设备的输出请求处理 对于设备输出过程而言，循环：若还有数据输出请求，则申请空闲缓冲区把所输出的数据拷贝和暂存其中并挂到设备的输出缓冲区队列上 待设备空闲时，系统从输出缓冲区队列队首缓冲区提取数据输出到设备上，然后把该缓冲区放回空缓冲区队列，循环执行这一过程直到输出缓冲区队列为空 设备分配 # 计算机系统中进程数总是多于设备数及由此导致的设备竞争的客观现实 设备分配须方便用户并有效规避死锁问题 设备分配方式 独占式分配及独占式设备（譬如打印机、绘图仪） 共享式分配及共享式设备（譬如磁盘） 虚拟式分配及假脱机技术（在共享式设备上实现独占式设备的虚拟和共享使用），可以提高输入输出速度、改善设备利用率和系统吞吐量，提高了进程的并发执行程度和执行效率 假脱机技术\n虚拟设备分配 采用共享式分配为进程分配一个共享式设备“井”，并将“井”与指定的独占式设备相关联 输入/输出控制方式及模块 # 程序查询方式\n实现简单、无需硬件支持 处理器和设备串行工作、处理器利用率低 多台设备之间也只能串行工作 依靠测试设备状态来控制数据传输过程，故而无法发现和处理由设备或其他硬件发生的错误 仅适用于处理器执行速度较慢且外设数量较少的系统 中断控制方式\n内存直接存取方式（DMA）\n通道方式\n输入输出模块： Unix 设备管理 # Unix 设备管理概要 # Unix 设备管理特点\n将设备作为特殊文件，由文件系统统一管理 支持系统中设备灵活、方便的配置 高效的缓冲区管理算法 Unix 设备管理数据结构\n设备控制表 设备开关表 控制器控制表（DMA 方式无此表） 通道控制表 Unix 设备驱动程序管控方式\n输入输出模块调用方式 Unix 设备管理数据结构 # 设备控制表 (DCT / 设备控制块 DCB)\n抽象的 I/O 调用函数 ⬄ 实际的 I/O 设备驱动 包含抽象设备描述、对应实际物理设备接口地址及相应的设备驱动函数模块入口地址 实现用户进程与物理设备无关性 ⬄ 设备独立性 设备标识包括主设备号和次设备号\n主设备号为设备类型的标识 次设备号为对应设备类型的不同设备的编号 设备开关表（函数指针结构体数组）\n同一型号物理设备完成各种操作的驱动函数入口 主设备号相同的所有设备共享一张设备开关表 struct devtab { int dvid;\t/*设备标识符*/ int dvadd; /*设备地址*/ int *dvec; /*设备中断向量*/ int *dvbuf; /*设备缓冲区指针*/ int *dvque; /*设备等待队列首址*/ int (*dvinit)(); /*设备驱动初始化函数*/ int(*dvopen)(); /*设备驱动打开函数*/ int(*dvclose)(); /*设备驱动关闭函数*/ int(*dvread)(); /*设备驱动读函数*/ int(*dvwrite)(); /*设备驱动写函数*/ int(*dvseek)(); /*设备驱动查询函数*/ int(*dvcntl)(); /*设备驱动控制操作函数*/ int(*dvgetc)(); /*设备驱动取字符函数*/ int(*dvputc)(); /*设备驱动送字符函数*/ }dct[]; Unix 设备请求及处理\n用户进程通过系统调用发出读访问设备请求 int read(int dvcrp, char *buf, int size) { struct devtab *devptr; /*定义指向设备表的指针*/ if (isbaddev(dvcrp)))\t/*确认设备标识符是否有效*/ return(SYSERR);\tdevptr = \u0026amp;dct[dvcrp]; /*有效则找到对应设备表项*/ return((*devptr-\u0026gt;dvread)(devptr, buf, size)); /*将参数传递给设备驱动程序*/ } 内核与设备驱动程序接口\nUnix 块设备控制器控制表 struct iobuf\nstruct iobuf { int b_flags;\t/*设备的状态标志 */ dev_t b_dev;\t/*设备名，即逻辑设备号*/ char b_active;\t/*设备正在执行一个I/O请求的标志*/ char b_errcnt;\t/*出错计数*/ struct buf *b_forw;\t/*指向本设备缓冲区散列队列下一个buf*/ struct buf *b_back;\t/*指向本设备缓冲区散列队列上一个buf*/ struct buf *b_actf;\t/*指向本设备I/O请求队列中第一个buf*/ struct buf *b_actl;\t/*指向本设备I/O请求队列中最后一个buf*/ struct eblock *io_erec;\t/*指向块设备错误记录块*/ int io_nreg;\t/*设备寄存器的个数*/ physadr io_addr;\t/*设备控制状态寄存器地址*/ physadr io_mba; /*MBA配置结构寄存器地址*/ struct iostart *io_stp; /*指向部件I/O统计块*/ time_t io_start;\t/*输入输出启动时间*/ int io_s1;\t/*驱动程序留用位置*/ int io_s2;\t/*驱动程序留用位置*/ }; Unix 块设备缓冲区管理 # 块设备缓冲池及其组成\n数据缓冲区与缓冲控制块物理上分离 Unix 缓冲区及块设备 I/O 管理\n三种队列及队列头 设备缓冲区散列队列（队列头 hbuf[i]） 空闲缓冲区队列（队列头 bfreelist） 每个物理设备的 I/O 请求队列（队列头 iobuf） 设备缓冲区散列队列 64 个双向队列：i = (b_dev + b_blkno) mod 64 各队列挂接了所有曾经分配给各类块设备使用过且被释放了的空闲的缓冲区（av_forw 和 av_back） b_dev 和 b_blkno 取值由进程在 I/O 请求中给出、并在 buf 结构中描述，可唯一确定一个物理数据块 盘块缓冲区的分配与回收\n盘块缓冲池互斥操作要求 盘块缓冲区获取过程 getblk() 返回任一空闲缓冲区，并设置 b-busy 标志 若有延迟写标志，调用 bdwrite 过程 盘块缓冲区获取过程 getblk(dev, blkno) 为指定设备和盘块号的盘块申请缓冲区 盘块缓冲区回收过程 brelse() 进程唤醒 视数据有效与否链入空闲链表末尾或首部 Unix 块设备缓冲管理要旨归纳\n基于 LRU 算法的缓冲区队列的管理 使已读到内存缓冲区的数据尽可能长时间地保留在缓冲区中，从而为数据的复用创造机会和条件 有效减少读写磁盘的次数，并提高磁盘 I/O 速度 数据复用及数据一致性和完整性的保证 每一个文件数据块在内存只有一个缓冲区与之对应，从而为实现数据的一致性和完整性提供保证 缓冲区由系统统一管理控制 防止了某进程因永远得不到缓冲区而无限期睡眠 防止任何进程无法永远霸占某个缓冲区，也即所有缓冲区都有可能被重新分配利用 Unix 设备驱动程序 # 基本功能任务\n设备初始化 设备\u0026lt;=数据=\u0026gt;内存/系统 检测和处理设备错误 管控对象为设备控制器（含三种寄存器）\n数据缓冲寄存器用于存放需要传输的数据 状态寄存器用于设备状态如就绪、忙、操作出错等不同状态的编程 控制寄存器用于控制设备的各种操作或指定设备的 I/O 地址 磁盘驱动程序\n磁盘驱动器打开过程 gdopen 输入参数为设备号 打开后设置 b-flag 为 B-ONCE 调用 gdtimer 启动对应控制器与设备闹钟 磁盘控制器启动过程 gdstart 设置磁盘控制器各寄存器值并启动 gdstrategy 把指定缓冲首部放至 I/O 队列末尾 磁盘中断处理过程 gdintr 输入参数为磁盘控制器号 磁盘读写程序\n一般读过程 bread 将盘块信息读入到缓冲区 提前读过程 breada 提前将下一盘块中的信息读入到缓冲区 一般写（同步写）过程 bwrite 真正把缓冲区中的数据写到磁盘上且须等待完成 异步写过程 bawrite 进程无需等待写操作完成便可返回 延迟写过程 bdwrite 缓冲首部设置延迟写标志，将缓冲区链至空缓冲尾 基于设备文件的管理方式\n底层物理特性视角（设备/普通文件不同） 设备文件在磁盘上无数据盘块，但在文件系统中却拥有一个永久的索引结点 设备文件的索引结点 无数据盘块号指针数组（=\u0026gt;混合索引物理结构） 有用来存放设备的主/次设备号的 i_dev 域 输入输出进程功能任务 根据用户命令中的设备文件名找到其索引结点，进而得到设备标识 i_dev，再由对应主设备号及用户提供的操作命令在系统设备开关表数组中查找映射到相应的设备驱动函数，并加以执行处理 Linux 内核模块及设备驱动 # Linux 内核架构及动态扩展机制 # Linux 采用了宏内核架构\n操作系统的大部分功能（包括进程管理、内存管理、进程调度、设备管理）在内核空间实现 Linux 内核动态扩展机制\nLinux 内核运行时加载一组目标代码来实现特定功能，从而使得 Linux 实际使用和运行过程中无需重新编译 Linux 内核（即核心模块）代码就能够实现内核的动态扩充 具体基于 LKM（Loadable Kernel Module）机制来实现特定内核功能的增加或删减 相对的 - 微内核架构：仅把最基本的功能放入内核，其他大部分功能（包括设备驱动）都放到非特权模式下，故而拥有天生的动态扩展性 Linux 是一个借鉴了微内核精髓的宏内核结构，Linux 支持模块化的设计、抢占式内核、对内核线程的支持以及动态加载内核模块的能力。不仅如此，Linux 还避免了其微内核设计的性能损失，允许一切运行在内核模式下，直接调用函数，无需消息传递。\n所以综合一点来讲，Linux 是一个模块化、多线程和内核可调度的操作系统。\n聊了聊宏内核和微内核，并吹了一波 Linux\nLinux用户抢占和内核抢占详解(概念, 实现和触发时机)\u0026ndash;Linux进程的管理与调度(二十）-腾讯云开发者社区-腾讯云\nLinux 最简内核模块 # #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; static int __init init_lkm1st_zgs(void) { printk(\u0026#34;Welcome to init() for 1st LKM of BJTU_ZGS\\n\u0026#34;); return 0; } static void __exit exit_lkm1st_zgs(void) { printk(\u0026#34;Goodbye from exit() for 1st LKM of BJTU_ZGS\\n\u0026#34;); } module_init(init_lkm1st_zgs); module_exit(exit_lkm1st_zgs); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;GaoshouZhai@BJTU\u0026#34;); MODULE_DESCRIPTION(\u0026#34;First LKM of BJTU_ZGS\u0026#34;); MODULE_ALIAS(\u0026#34;LKM1ST_ZGS\u0026#34;); //模块参数声明（可选） //模块导出符号声明（可选 BASEINCLUDE ?= /lib/modules/`uname -r`/build/ obj-m := FirstZgsLKM.o all: $(MAKE) -C $(BASEINCLUDE) M=$(PWD) modules clean: $(MAKE) -C $(BASEINCLUDE) M=$(PWD) clean retpoline 现代计算机系统 CPU 往往会提前执行 jmp 或 call 等指令的下一条指令，也即将其存到所谓 RSB（Return stack Buffer）的栈中，如果相关指令存在安全风险，就有可能被利用。为此，通常在 call 和 jmp 指令后面添加一段无用死循环代码，从而使 CPU 预测分支执行该无用代码。称为 Return trampoline 执行 sudo insmod、dmesg、lsmod 以及 tree 命令 sudo dmesg -c 清理内核输出显示内容 可执行与可链接格式 - 维基百科，自由的百科全书\nELF 文件格式 · Linux Inside 中文版\nLinux 传参内核模块 # Linux 内核模块参数传递\nLinux 内核提供了用以实现模块参数传递的宏 #define module_param(name, type, perm) module_param_named(name, name, type, perm) #define MODULE_PARM_DESC(_parm, desc) __MODULE_INFO(parm, _parm, #_parm \u0026quot;:\u0026quot; desc) /include/linux/moduleparam.h 指定 sysfs 中相应文件的访问权限： 0 文件不会出现在 sysfs 文件系统中 S_IRUGO 可被所有人读不可写 (0444) S_IRUGO| S_IWUSR 可被所有 (0644) 人读且可被 root 用户写 byte、short、ushort、int、uint、long、ulong、char、bool、…… #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; static int zDebug = 1; module_param(zDebug, int, 0644); MODULE_PARM_DESC(zDebug, \u0026#34;Enable to output debugging information\u0026#34;); #define printk_debug(args...) \\ if (zDebug) { \\ printk(KERN_DEBUG args); \\ } static int __init init_lkm2nd_zgs(void) { printk(\u0026#34;Welcome to init() for 2nd LKM of BJTU_ZGS\\n\u0026#34;); printk_debug(\u0026#34;Module parameter zDebug = %d\\n\u0026#34;, zDebug); return 0; } static void __exit exit_lkm2nd_zgs(void) { printk(\u0026#34;Goodbye from exit() for 2nd LKM of BJTU_ZGS\\n\u0026#34;); } module_init(init_lkm2nd_zgs); module_exit(exit_lkm2nd_zgs); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); MODULE_AUTHOR(\u0026#34;GaoshouZhai@BJTU\u0026#34;); MODULE_DESCRIPTION(\u0026#34;Second LKM of BJTU_ZGS\u0026#34;); MODULE_ALIAS(\u0026#34;LKM2ND_ZGS\u0026#34;); Linux 内核符号共享机制 # Linux 主体内核以及内核模块间符号联系\n譬如，设备驱动往往按功能划分为若干内核模块，这些模块间如何实现接口函数的相互调用，包括它们如何调用主体内核提供的内存管理等相关支撑接口函数 Linux 内核符号共享机制\nEXPORT_SYMBOL() EXPORT_SYMBOL_GPL() Linux 内核所导出的符号表查看方法\ncat /proc/kallsyms | grep sound Linux 字符设备驱动 # Linux 字符设备节点创建\nLinux 系统环境中访问设备的前提条件 对应于设备的特殊文件已经创建 ls -l /dev/ 可以查看系统已经生成的设备文件 Linux 创建设备特殊文件（节点）的两种方法 设备驱动中利用 device_create() 内核函数 Shell 命令：mknod sudo mknod /dev/FakeCharDev c 252 0 /* FakeCharDevDrv.h */ #ifndef FAKE_CDEV_DRV_H_INCLUDED #define FAKE_CDEV_DRV_H_INCLUDED /* **可创建的伪字符设备最多台数，缺省情况下为2台** */ #ifndef NUM_OF_FAKE_CDEVS #define NUM_OF_FAKE_CDEVS 2 #endif /* **用于数据存储的缓冲区大小** */ #ifndef SIZE_OF_BUFFER #define SIZE_OF_BUFFER 4096 #endif /* **每次操作可以读写的块大小** */ #ifndef SIZE_OF_BLOCK #define SIZE_OF_BLOCK 512 #endif /* **伪字符设备结构体类型** */ struct fake_cdev { unsigned char *data; unsigned long buffer_size; unsigned long block_size; struct mutex fake_cdev_mutex; struct cdev cdev; }; #endif /* FAKE_CDEV_DRV_H_INCLUDED */ Linux设备管理（二）_从cdev_add说起 - Abnor - 博客园\nchar_traits struct 初步学习-CSDN博客\nLinux内核驱动：cdev、misc以及device三者之间的联系和区别 - schips - 博客园\nLinux设备驱动程序 之 主次设备号 - AlexAlex - 博客园\n从/dev 目录说起\n从事 Linux 嵌入式驱动开发的人，都很熟悉下面的一些基础知识， 比如，对于一个 char 类型的设备，我想对其进行 read wirte 和 ioctl 操作，那么：\n1、我们通常会在内核驱动中实现一个 file_operations 结构体，然后分配主次设备号，调用 cdev_add 函数进行注册。\n2、从 /proc/devices 下面找到注册的设备的主次设备号，在用 mknod /dev/char_dev c major minor 命令行创建设备节点。\n3、在用户空间 open /dev/char_dev 这个设备，然后进行各种操作。\nOK，字符设备模型就这么简单，很多 ABC 教程都是一个类似的实现。\n然后我们去看内核代码时，突然一脸懵逼。。。怎么内核代码里很多常用的驱动的实现不是这个样子的？没看到有 file_operations 结构体，我怎么使用这些驱动？看到了 /dev 目录下有需要的 char 设备，可是怎么使用呢？\n"},{"id":11,"href":"/docs/Advanced-OS/class-notes/7-Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"7 Linux内核调试与性能优化","section":"Class Notes","content":" 计算机系统性能优化理论 # 描述了实际项目中性能优化的五个方面\nProfile——针对优化目标进行性能测试摸底\n不同应用场景不同的采样工具（perf、VTurn） Analyze——分析性能的瓶颈和焦点\nRoot——刨根问底，找出问题的根本原因\nOptimize——设法突破瓶颈和优化性能\nTest——测试验证性能优化成效\n上述过程是一个迭代循环过程\nprintk——简单强大调试工具 # 内核提供的格式化显示输出函数 [环形缓冲机制]\n输出级别——在终端或串口输出的判断依据\n输出级别不低于控制台输出级别的消息将会在控制台显示输出 系统运行时输出级别的查看与修改\ncat /proc/sys/kernel/printk 15\t4\t1\t7 分别对应控制台输出级别、消息默认输出级别、控制台输出级别最小取值和控制台默认输出级别 #echo 7 \u0026gt; /proc/sys/kernel/printk $ cat /proc/sys/kernel/printk 7\t4\t1\t7 函数名及代码行号的显示输出 printk(\u0026quot;FunctionName[%s] LineNo[%d]\\n\u0026quot;, __func__, __LINE__); debugfs 文件系统及动态输出 # 动态输出（Dynamic printk）\n由系统维护者动态选择打开内核输出 动态输出对应于内核代码中有关函数 pr_debug() 和 dev_debug() 的输出信息 可指定内核子系统或内核模块 要求在内核编译配置时打开宏 CONFIG_DYNAMIC_DEBUG 需要系统挂载 debugfs 文件系统，并在其 control 节点加以查看，具体记录了系统中所有使用动态输入输出技术的文件名路径、输出所在行号、模块名字以及要打印的信息描述 cat/more + grep 查看方式 proc 文件系统（系统及进程信息） # 内核和内核模块向用户空间发送消息的机制\n方便用户或用户进程访问内核数据结构以获取进程或系统的有关信息 本质上并非真正意义的文件系统，存在于内存，而不占用磁盘空间\n典型应用场景\n通过/proc/meminfo 查看内存管理信息 通过/proc/cpuinfo 查看处理器信息 查看进程信息 ps、top 等 Shell 命令 sys 文件系统及新型设备驱动模型 # 引入缘由\n包括设备驱动等在内的内核模块造成了/proc 文件系统目录的杂乱无章 Linux2.5 起建立了统一的设备驱动模型，也由此诞生了 sys 这一新的内存型虚拟文件系统 新型设备驱动模型\n对计算机系统中的所有设备进行统一的表示和操作，包括设备本身及设备之间的连接关系 建立在 PCI 和 USB 的总线枚举过程分析基础之上 CPU⬄PCI 总线设备⬄PCI 设备（USB 总线设备）⬄外部 USB 设备（譬如 USB 鼠标/键盘）关电与加电次序 OOPS 错误分析及示例 # OOPS（Out-of-Process Space）\n内核空间中，指针非法取值或访问 OOPS 内核模块示例（Makefile、OOPS_LKM.c）\n实验过程及工具\n编译生成内核模块 OOPS_LKM.ko 加载内核模块 OOPS_LKM.ko 执行 dmesg 命令检查内核空间输出信息 利用反汇编工具 objdump 检查汇编代码 decodecode 脚本程序（/usr/src/linux-headers-4.4.0-21/scripts/decodecode） 利用内核调试工具 gdb 内存检测工具及应用 # slub-debug\nslab/slub 分配器提供的内存错误访问检测功能 kmemleak\n用于检测内核内存泄露（只申请不释放）情况 kasan（kernel address sanitizer）\n用于检测内核内存越界/已释放访问等错误情况 valgrind\n用于检测应用程序的内存泄漏及越界访问情况 kdump\n用于系统崩溃时的内核空间内存内容的转移存储 基于 slub-debug 的内存检测\n内核编译配置 利用 slub_debug 选项打开 slub-debug 检测功能 slabinfo 工具 在 linux-4.8.8/tools/vm 目录下 make 编译生成 内存错误访问型 Linux 内核模块 Makefile、源程序 SlubDebugLKM.c 实验过程（QEMU 虚拟机上） 加载 SlubDebugLKM.ko 后，执行 slabinfo 命令 卸载 SlubDebugLKM.ko 后，执行 dmesg 命令 性能/功耗指标及 Linux 性能测试工具 # PnP（Performance And Power）\n性能与功耗是一对矛盾体\nKPI（Key Performance Indicator）\n性能指标\n包括处理器指标、GPU 指标、I/O 指标、网络指标等 功耗指标\n包括待机功耗、待机电流、播放 MP3 时长、观看视频时长等 功耗测试会牵涉到诸多硬件设备 Linux 性能测试工具\nkernel-selftests【linux-4.8.8/tools/testing/selftests】 perf-bench【linux-4.8.8/tools/perf/bench】 iperf【网络性能测试程序】 pmbench【内存性能测试程序】 sysbench【综合测试套件：CPU、内存、多线程】 DBENCH【I/O 性能测试程序】 GFXbenchmark/glbenchmark【GPU 性能测试程序】 iozone【文件系统性能测试程序】 vm-scalability【Linux 内核内存管理模块可扩展性测试程序】 "},{"id":12,"href":"/docs/Algo/0-Asymptopic-Analysis/","title":"0 Asymptopic Analysis","section":"Algo","content":"算法复杂度 ─ 直观定义\n算法复杂度是算法运行所需要的计算机资源的量，需要时间资源的量称为时 间复杂性，需要的空间资源的量称为 空间复杂性\n时间复杂度和空间复杂度是只依赖于算法求解的问题规模和算法输入的函数 𝑁、𝐼 分别表示算法求解的问题规模和算法输入，则算法的时间复杂度𝑇和空 间复杂度𝑆可以分别表示为: 𝑇 = 𝑇(𝑁, 𝐼) 𝑆 = 𝑆(𝑁, 𝐼) 算法复杂度分析 ─ 指令抽象\nT(N, I) 表示特定算法在一台抽象的计算机上运行所需要的时间\nK 个元运算，O1, O2, \u0026hellip;, Ok, 运行一次所需时间为 t1, t2, \u0026hellip;, tk; 统计 Oi 的调用次数为 ei，ei = ei(N, I); 因此，T(N, I) = ∑tiei(N, I)。 归纳逻辑: 从个别到一般 T(N) 的表达式比较复杂，需合理的简化!\n对于算法 A 的复杂度函数𝑇(𝑁)，如果存在𝑇′(𝑁) ，使得当𝑁 → ∞时有 (𝑇𝑁 −𝑇′(𝑁))⁄𝑇(𝑁)→0，那么就称𝑇′(𝑁) 为算法 A 当𝑁→∞的渐近复杂性\n𝑇′(𝑁) 是𝑇(𝑁) 略去低阶项所留下的主项，表达简单 如果两个算法的渐近复杂性的阶不相同，那么只要确定出各自的阶就可以判断哪一个算法效率高 阶跟𝑇′(𝑁) 中的常数因子没有关系，𝑇′(𝑁) 可进一步简化，省略常数因子 时间复杂度的记号包括:O Ω Θ\n时间复杂度记号 O # 设 f(N) 和 g(N) 是定义在正数集上的正函数，如果存在正的常数 C 和自然数 N0，使得当 N≥N0 时有 f(N) ≤Cg(N)，则称函数 f(N) 当 N 充分大时上有界，g(N) 是 f(N) 的一个上界， 记为 f(N)=O(g(N))，即 f(N) 的阶不高于 g(N) 的阶。\n注意 不是直接比较 f(N) 和 g(N) 的数值大小 O 表示的只是一个充分大的上界，上界的阶越低则评估越精确，结果越有价值! 运算法则\nO(f)+O(g)=O(max(f,g)); O(f)+O(g)=O(f+g); O(f)O(g)=O(fg); 如果 g(N)=O(f(N))，则 O(f)+O(g)=O(f); O(Cf(N))=O(f(N))，其中 C 是一个正的常数; f=O(f) 大 O 比率定理\n对于函数 f(N) 和 g(N)，如果极限 lim 𝑓(𝑁)/𝑔(𝑁) 存在，则𝑓(𝑁) = 𝑂(𝑔 𝑁 ) 当且仅当存在正的常数 C，使得 lim 𝑓(𝑁)/𝑔(𝑁) ≤ 𝐶\n时间复杂度记号 Ω # Ω的定义: 如果存在正的常数 C 和自然数 N0，使得当 N3N0 时有 f(N)3Cg(N)，则称 函数 f(N) 当 N 充分大时下有界，且 g(N) 是它的一个下界，记为 f(N) = Ω(g(N))， 即 f(N) 的阶不低于 g(N) 的阶。\n时间复杂度记号 Θ # Θ的定义: 定义 f(N) = Θ(g(N)) 当且仅当 f(N)=O(g(N)) 且 f(N)= Ω(g(N))，此 时称 f(N) 与 g(N) 同阶。\n定理 1: 对于多项式函数 𝑓 𝑁 = 𝑎+𝑁+ + 𝑎+,%𝑁+,% + ⋯ + 𝑎%𝑁 + 𝑎\u0026amp;，如果 𝑎+ \u0026gt; 0，则有: 𝑓 𝑁 =𝑂(𝑁+)，𝑓 𝑁 =𝛺(𝑁+)，𝑓 𝑁 =𝛩(𝑁+)\n时间复杂度类别\n时间复杂度分析 # 非递归算法 # 确定关键操作: 可以是高级程序设计语言中的赋值、比较、算术运算、逻辑 运算、读写单个常量或单个变量等操作 (一般被看作是基本操作，并约定所 用的时间都是一个单位); 也可以是由常数个基本操作构成的程序块 计算关键操作总的执行步数: 一般是数列和的形式。 求解其渐进阶: 并用 O(.) 表示 递归算法 # 分析递归程序的结构，确定每一逻辑块的时间复杂性， 非递归的程序块 (或者 子函数) 用非递归方法分析其复杂性; 递归函数的复杂性则跟据其输入规模递 归地表示。 构造复杂度函数的递推方程 求解递归方程和渐进阶，并用 O(.) 表示 "},{"id":13,"href":"/docs/Algo/1-E/","title":"1 E","section":"Algo","content":" Theory\u0026amp;Thinkings # 为什么要用枚举？ 解准确且全面 实现简单，通过循环或递归实现 执行效率提升空间通常较大 具体方法：\n枚举对象 枚举过程 验证解 不是所有问题都有巧妙的解决方案，没有想到就要进一步做优化，对于枚举来说：压缩枚举空间。\n枚举算法\n也称之为穷举算法，就是按照问题本身的性质，一 一列举出该问题所有可能的解， 并在列举的过程中，逐一检验每个可能解是否是问题的真正解。若是则采纳这个解; 否则抛弃它。\n不能遗漏，否则可能导致结果不正确 不要重复，否则可能导致效率比较低 枚举算法设计步骤\n确定枚举对象 枚举对象也可以理解为是问题解的表达形式，一般需要 用若干参数 (p1, p2, \u0026hellip;\u0026hellip;, pk) 来描述 参数之间需要相互独立，而且参数数目越少，问题解搜索空间的维度也相应地小 每个参数的取值范围越小，问题解的搜索空间也越小 优化模型 针对问题特征，优化对象模型 逐一列举可能解 根据枚举对象的参数构造循环 (也可以递归)，一一 列举其表达式的每一种取值情况。 优化过程 针对对象特征，优化列举和验证过程 逐一验证可能解 根据问题解的要求，一一验证枚举对象表达式的每一 个取值，如果满足条件，则采纳它; 否则，抛弃之。 e.g.s # 数组配对 # 给你一个长度为n的数组A和一个正整数k，问从数组中任选两个数使其和是k的倍数，有多少种选法？对于数组 a1=1 , a2=2 , a3=2 而言： (a1,a2) 和 (a2,a1)被认为是同一种选法； (a1,a2) 和 (a1,a3)被认为是不同的选法。 朴素方法 枚举对象：𝑂𝑏𝑗(𝑎𝑖,𝑎𝑗),1≤ 𝑖 \u0026lt; 𝑗≤ 𝑛 逐一列举 逐一验证 存在问题：时间复杂度较高：𝑂(𝑛2) 如果问题规模较大，求解问题需要的时间也呈指数级别增长 尝试改进：如何减少问题空间？如何更加有效的枚举？ 利用桶思路，将原问题之间用 mod 运算降低到一个非常低的解空间中再进行枚举 枚举对象：𝑂𝑏𝑗(𝑎𝑖,𝑎𝑗),1≤ 𝑖 \u0026lt; 𝑗≤ 𝑛 逐一列举： 预处理： (𝑎𝑖 + 𝑎𝑗)%𝑘 = 0 逐一验证：(𝑎𝑖%𝑘 + 𝑎𝑗%𝑘)%𝑘 = 0 求解细节： 会变成两个单独数字的配对问题，存在两种情况 两个数字在同一桶内：组合数公式 两数字不在同一桶内：直接相乘，相当于组合公式 void work() { LL ans = 0; for (int i = 0; i \u0026lt; k; i++) { int j = (k - i) % k; if (j \u0026lt; i) break; // 避免重复 else if (j == i) // 0或者k/2 ans += 1LL * b[i] * (b[i] - 1) / 2; else ans += 1LL * b[i] * b[j]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 绳子切割问题 # 有N条绳子，它们的长度分别为𝐿_𝑖 (≤1000)。如果从它们中切割出 K 条长度相同的绳子，这K条绳子每条最长能有多长？答案保留到小数点后2位。 枚举法的典型应用\n我要枚举出一个最长长度出来，可以直接套用二分枚举的算法进行实现\n枚举对象：绳子长度 枚举过程：二分枚举 验证方法：到每个已知绳子中验证其切割结果是否为 k int n, k; // 全局变量，数组长度和目标数值 int a[MAX_N]; //全局变量，待查找数组 int binarySearch() { int lb = 0; ub = n; // 初始化解的存在范围 while (ub - lb \u0026gt; 0) { int mid = (lb + ub) / 2; if (a[mid] \u0026gt;= k) ub = mid; // 解的范围更新为 [lb, mid] else lb = mid + 1; // 解的范围更新为 [mid + 1, ub] } return lb; // lb即为答案 } 关于二分法的边界问题及两种写法_二分法边界处理-CSDN博客\n二分枚举基本原理\n一般化模型：\n“求满足某个条件𝑪(𝒙) 的最小的𝒙”，其中𝐶(𝑥) 满足性质: 如果任意𝑥满足𝐶(𝑥)，则所有 的𝑥 ≥ 𝑥也满足𝐶(𝑥) “求满足某个条件𝑪(𝒙) 的最大的𝒙”，其中𝐶(𝑥) 满足性质: 如果任意𝑥满足𝐶(𝑥)，则所有 的𝑥 ≤ 𝑥也满足𝐶(𝑥) 算法(模型1) 1. 设置x的初始范围，即下界lb和上界ub 2. While (ub \u0026gt; lb) 1)𝑚𝑖𝑑 = (𝑙𝑏 + 𝑢𝑏)/2; 2)if (C(mid)) 更新上界: 𝑢𝑏 ← 𝑚𝑖𝑑; 3)else 更新下界:𝑙𝑏 ← 𝑚𝑖𝑑+1 算法(模型2) 1. 设置x的初始范围，即下界lb和上界ub 2. While (ub \u0026gt; lb) 1)𝑚𝑖𝑑 = (𝑙𝑏 + 𝑢𝑏)/2; 2)if (C(mid)) 更新下界: 𝑙𝑏 ← 𝑚𝑖𝑑; 3)else 更新上界:𝑢𝑏 ← 𝑚𝑖𝑑−1 移除石头——最重要枚举问题 # 有一条河，河中间有一些石头，石头的数量以及相邻两块石头之间的距离已知。现在可以移除一些石头，假设最多可以移除m块石头（注意：首尾两块石头不可以移除，且假定所有的石头都处于同一条直线），问最多移除m块石头后相邻两块石头之间的最小距离的最大值是多少？ 传统的贪心策略，二叉树搜索策略要么不可行，要么复杂度过高，需要一种高效的遍历算法——二分枚举 问题建模: 求满足条件𝑪(𝒅) 的最大值𝑑，其中𝑪(𝒅) 描述为:𝑪 𝒅 ≔ 最多移除 m 个石头后最近两个石头的距离不小于 d 问题转换： 求满足条件𝑪(𝒅) 的最大值𝑑，其中𝑪(𝒅) 描述为:𝑪 𝒅 ≔ 最多移除 m 个石头后任意相邻两个石头的距离不小于 d 算法思路： 应用贪心思想 循环依次考虑相邻石头，如果距离小于 d，则去掉一个石头; 如果任意相邻石头的距离都不小于 d，则返回 true; 如果移除的石头个数大于 m，则返回 false 函数求根问题 # 有形如：𝑎𝑥^3+𝑏𝑥^2+𝑐𝑥+𝑑=0 的一元三次方程。给出该方程中各项的系数(a，b，c，d 均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值≥1。请设计算法求解三个实根。 输入格式 多组输入(不超过20组数据，读入以EOF结尾) 每组输入四个数字，a，b，c，d (4个数绝对值小等于30) 输出格式 每组输出一行结果，由小到大输出3个根(保留两位有效数字) Problem A. 优美的立方质数 # 题目描述 如果一个质数能被表示为三个不同的质数的和的形式，那么我们称它为立方质数。现在给你一个数n，判断它是不是立方质数。 输入数据 正整数n，n\u0026lt;=1000 输出数据 Yes或者No Problem B. 课堂作业 -6-2 木棍切割问题 # Problem C. 李老师的幸运数字 # 题目描述 李老师的lucky number 是3，5和7，他爱屋及乌，还把所有质因数只有3，5，7的数字认定为lucky number，比如9, 15, 21, 25等等。请聪明的你帮忙算一算小于等于x的lucky number有多少个？ 输入数据 一个正整数x，3=\u0026lt;x\u0026lt;=1000000000000 输出数据 小于等于x的lucky number的个数。 Problem D. 思维之花 - 简单背包 # 题目描述 李老师正准备暑假旅行，他有一个容量为L的行李箱和n个物品（n不超过20），每个物品都有自己的体积，物品可以放入行李箱，但行李箱中物品的总体积不能超过行李箱容量，李老师现在想知道他有多少种携带物品的方案（一个物品都不带也算一种方案） 输入数据 第一行为两个正整数n和L，分别代表物品总数和行李箱容量，n\u0026lt;=20，L\u0026lt;=1e9 接下来一行为n个正整数vi，代表第i个物品的体积，vi\u0026lt;=1e8 输出数据 方案数 Problem E. 课堂作业 -7-2 石头移除问题 # 题目描述 有一条河，河中间有一些石头，已知石头的数量和相邻两块石头之间的距离。现在可以移除一些石头，问最多移除m块石头后（首尾两块石头不可以移除），相邻两块石头之间的距离的最小值最大是多少。 输入数据 第一行输入两个数字，n（2\u0026lt;=n\u0026lt;=1000）为石头的个数，m（0\u0026lt;=m\u0026lt;=n-2）为可移除的石头数目 随后n-1个数字，表示顺序和相邻两块石头的距离d（d\u0026lt;=1000） 输出数据 输出最小距离的最大值 Problem F. 数对选择 # 题目描述 给你一个长度为n的数组和一个正整数k，问从数组中任选两个数使其和是k的倍数，有多少种选法。 对于数组a1=1 , a2=2 , a3=2而言： (a1,a2)和(a2,a1)被认为是同一种选法； (a1,a2)和(a1,a3)被认为是不同的选法。 输入数据 第一行有两个正整数n，k。n\u0026lt;=1000000，k\u0026lt;=1000000 第二行有n个正整数，每个数的大小不超过1e9 输出数据 选出一对数使其和是k的倍数的选法个数 Q：为什么使用 1LL 进行处理？ 在这段代码中，乘以 LL 的目的是为了确保在进行乘法运算时使用长整型（long long）进行计算，避免整数溢出问题。 具体来说，1LL 是一个将数字 1 转换为长整型的方式。在这里，1LL * (bucket[i] * (bucket[i] - 1) / 2) 和 1LL * (bucket[i] * bucket[j]) 中的乘法运算都会使用长整型进行计算。 这是因为当进行乘法运算时，如果操作数中有一个是长整型，那么结果也将是长整型。在某些情况下，特别是当计算的结果可能超过整数范围时，使用长整型是很重要的，以防止溢出。如果不使用 1LL 进行转换，整个表达式的结果可能会被截断为普通整型，导致错误的结果。 "},{"id":14,"href":"/docs/Algo/2-Divide-and-Conquer/","title":"2 Divide and Conquer","section":"Algo","content":"分治算法最重要的就是如何确定好划分方式，以及划分的构造\nTheory\u0026amp;Thinkings # 分而治之 # 分解为性质相同的子问题，应该只是规模不同\n如果性质不同怎么办？ 进行预处理，转化为性质相同的子问题 归并排序\n分治的分：不同的划分方法\n黑盒划分：归并排序，逆序对 白盒划分：快速排序 平衡子问题\n减而治之\n当分出的子问题是完全相同时，避免重复递归调用 直到某个子问题不用递归求解 直接舍弃或者使用 减是精髓 快速排序中的划分 partition非常重要\n快速归并排序 #enlighten\n思考方法：先把题目降维，然后进行处理\n递归三要素：\n递归终止条件：递归需要一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递归，防止无限递归 终止处理办法：在递归的临界点对应一种简单的情景，这种情景下，应当直接给出问题的解决方案 递归处理方法：递归问题必须可以分解为若干个规模较小、与原问题 形式相同 的子问题，这些子问题可以用 相同的思路 来解决，并且合并得到原问题答案。 递归与循环\n递归也是一种特殊的迭代，但是在迭代前不知道还要迭代多少次 递归函数一定有参数，且参数会在迭代的过程中步步逼近某个值 递归函数中一定有处理终点，而这个点就是递归出口 递归 有去有回（回到之前的栈帧上） 也就是递归这两个字的含义 循环 有去无回 分治算法基本思想\n分 — 将大规模的原问题分割成 k 个更小规模的 子问题，如果子问题的规模仍然不 够小，则再划分为 k 个“子 子”问题，如此递归地进行下去，直到子问题规模足够 小 (基础问题)，很容易求出其解为止。 治 — 求解规模足够小的基础问题。 合 — 将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上 逐步求出原来问题的解。 分治策略算法细分为三个阶段: Divide 、 Conquer 、 Combine 。 Divide 阶 段是把原问题分割成小问题， Conquer 阶段是递归处理流程， Combine 阶段 是运用小问题的答案合成出原问题的解答。\n分治策略框架程序\n(1) if ( | P | \u0026lt;= n0) adhoc(P); //递归出口，用特定程序解决基础问题 (2) divide P into smaller subinstances P1,P2,...,Pk;//分解出子问题 (3) for(i=1,i\u0026lt;=k,i++) yi = divide-and-conquer(Pi); //递归求解各子问题 (4) return merge(y1,...,yk); //将各子问题的解合并为原问题的解 } 问题规模与递归出口：\n|P|表示问题 P 的规模，𝑛是一个预先定义的阈值，表示当问题 P 的规模不超过𝑛时，问题已 容易求解，不必要继续分解和递归调用。 adhoc(P) 是分治算法中的子程序，对应治过程 (或者说 conquer)，一般是常数时间复杂 度的子函数或者子过程。 划分策略：\n设计划分策略，把原问题 P 分解成 k 个规模较小的子问题，这个步骤是分治算法的基础和关键， 人们往往遵循两个原则: 平衡子问题原则，分割出的 k 个子问题其规模最好大致相当; 独立子问题原则，分割出的 k 个子问题之间重叠越少越好，最好 k 个子问题是相互独立，不存在重叠子问题。 合并：\nmerge 合并子程序，把 k 个子问题的解合并得到原问题的解。合并子程序因求解问题 而异，即使是同一个问题，如果第二步的划分策略不同，其合并子程序也往往不一样。 减而治之 # Master 定理 # e.g.s # Stirling 数 # n 个元素的集合{1,2,...,n }可以划分为若干个非空子集的集合。例如，当n=3 时， 集合{1，2，3}可以划分为5个不同的非空子集的集合如下: { {1}，{2}，{3} } { {1，2}，{3} } { {1，3}，{2} } { {2，3}，{1} } { {1，2，3} } 给定正整数n 和 m，计算出n个元素的集合{1,2,...,n }可以划分为多少个不同的由 m 个非空子集构成的集合。比如上例中含有1个子集的集合有1个，2个子集的集合有3个， 3个子集的集合有1个。 假定有𝑆(𝑛, 𝑚) 种不同方法把 n 个元素的集合划分成 m 个非空子集构成的集合， 𝑆(𝑛, 𝑚) 种不同划分方法可以分为以下两类:\n先把 n-1 个元素的集合划分成 m 个非空子集，按定义其划分数目为 𝑆(𝑛 − 1, 𝑚)， 再将剩下的一个元素插入到 m 个子集中的任意一个，最后把这两步合起来则 可构成 n 个元素集合的 m 划分，总共有𝑚 ∗ 𝑆(𝑛 − 1, 𝑚) 中划分 先把 n-1 个元素的集合划分成 m-1 个子集，再将剩下的一个元素独立构造成 子集，显然，这两步合起来也可以构成有 n 个元素集合的 m 划分，总共有𝑆(𝑛 − 1, 𝑚 − 1) 种划分。 $$𝑆(𝑛, 𝑚) = 𝑚 ∗ 𝑆(𝑛 − 1, 𝑚) + 𝑆(𝑛 − 1, 𝑚 − 1)$$\n逆序对问题 # 黑盒划分典型问题\n问题描述：设𝐴[1,⋯,𝑛]是一个包含𝑛个不同非负整数的数组。如果在𝑖\u0026lt;𝑗的情况下，有𝐴𝑖\u0026gt;𝐴[𝑗]，则（𝐴𝑖，𝐴[𝑗]）就称为A中的一个逆序对。例如，数组（3，1，4，5，2）的“逆序对”有\u0026lt;3,1\u0026gt;、\u0026lt;3,2\u0026gt;、\u0026lt;4,2\u0026gt;、\u0026lt;5,2\u0026gt;共4个。 思考流程：\n朴素方法：枚举 将全部的数对枚举出来，检查是否逆序 时间复杂度达到指数级别 继续思考：思考方法：降维 1 个元素：0 个逆序对 2 个元素：比较输出 1/0 大于 2 个元素：是否可以将其拆分为 1 个或 2 个元素的情况——分治思路 分——将整体元素分成 2 个部分 治——深入两个部分探究逆序对问题（递归直到归位 base 情况） 合——将处理好的问题合并计数（难点） 分割点左侧全部逆序对 分割点右侧全部逆序对 跨两个集合的逆序对（进一步的真正难点） 朴素方法：枚举——复杂度仍然为指数，没有减少搜索空间 排序——目的：减少比较次数（即搜索空间） 如何比较排序后的数组？左侧数组中从小到大比较右侧数组中的数，O(n) 时间生成逆序总数量 随后使用双指针思路遍历选取即可 棋盘覆盖 # 在一个2k×2k个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格，且称该棋盘为特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。 思考流程：\n朴素方法：枚举 枚举甚至都无法实现，因为变量太多，且要求不能重叠，导致无法枚举 进阶思考：分治 思考方法 - 降维 分解到最基础形态 - 即 2x2 方格 情况 1：方格内存在一个特殊点 直接用 4 种里的一个做匹配即可 情况 2：方格里没有特殊点 g 了——有一个空始终无法填满 目标：强制要求每个块内的那个不可覆盖的点组合起来，应该刚好就是 3 个方块组成的元素 把有特殊点的子块当作 indicator，其周围靠近的三个点设为虚拟的特殊点，围绕此展开覆盖，最后覆盖这中间三个特殊点 (或者首先) void ChessBoard(int tr, int tc, int dr, int dc, int size) { if (size = = 2) fill(tr, tc, dr, dc); //覆盖2×2的棋盘 s = size/2; // 划分棋盘 if (dr \u0026lt; tr + s \u0026amp;\u0026amp; dc \u0026lt; tc + s) { ChessBoard(tr, tc, dr, dc, s); //递归处理左上子棋盘 ChessBoard(tr+s, tc, tr+s, tc+s-1, s); //递归处理左下子棋盘 ChessBoard(tr, tc+s, tr+s-1, tc+s+1, s); //递归处理右上子棋盘 ChessBoard(tr+s, tc+s, tr+s+1, tc+s+1, s); //递归处理右下子棋盘 } if (dr \u0026lt; tr + s \u0026amp;\u0026amp; dc \u0026gt;= tc + s) { …… } // 特殊方格在右上角子棋盘中 if (dr \u0026gt;= tr + s \u0026amp;\u0026amp; dc \u0026lt; tc + s) { …… } // 特殊方格在左下角子棋盘中 if (dr \u0026gt;= tr + s \u0026amp;\u0026amp; dc \u0026gt;= tc + s) { …… } // 特殊方格在右下角子棋盘中 } 最近点对 # 任务描述：给定平面上n个点，找其中的一对点，使得在n个点组成的所有点对中，该点对间的距离最小。 思考流程：\n朴素方法：枚举 枚举对象：全部点对；枚举过程：逐个挑选；验证：出来后比大小 时间复杂度必然达到指数级别 继续思考： 思考方法 - 降维 一维数组情况处理方法：将点从小到大排序，逐个测量两点间距离 但是对于二维情况无法操作，因为存在两个轴，无法有一个正确的排序方法 进阶思考方法： 如何使用分治策略 一维情况：在左侧找到最近点对，右侧找到最近点对，处理中间跨区操作点对后进行对比 二维情况：左侧区域 + 右侧区域 + 跨两区域——又回到了经典的分治问题解决策略 跨区情况如何计算最近点对？ 朴素方法：枚举 时间复杂度一定还是指数级别 进阶思考： 目标：把已经计算过的内容，当前左右两侧的最近距离 d 利用起来 处在中间位置的最近点对如果存在，则一定小于等于 d，否则没有必要 以中心分割线为界，左右两侧划分长度为 d 的可能存在区域 进一步压缩计算区域：假设点 p 存在，则其所搜索的区域为一个半径为 d 的半圆 半圆无法方便地用程序表示，放宽条件：宽 d 长 2d 的矩形区域 这个矩形中最多只可能存在 6 个点——因为当前最短距离 d 的限制存在，因为一个 1/6 小矩形里如果存在两个点，其距离一定小于 d 则，只需考虑左侧区域中的点扩展为这个矩形后，所覆盖的右侧 6 个点即可——大幅压缩求解空间 线性时间选择 # 给定线性序集中n个元素和一个整数 j，1 ≤ j ≤ n，要求找出这n个元素中第 j 小的元素。 例:求数组A[1:9] = [65, 70, 75, 80, 85, 60, 55, 50, 45]第7小元素 partition[1:9]=[60,45,50,55,65,85,80,75,70] j = 7 k = 5 [6:9] = [85,80,75,70] j = 2 partition[6:9]=[70,80,75,85] j = 2 k = 4 [6:8] = [70,80,75] j = 2 partition[6:8]=[70,80,75] j = 2 k = 1 [7:8] = [80,75] j = 1 普通二分查找的问题：最好情况 O(n),最坏情况 O(n^2) 线性时间选择\n如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的 2 个子 数组的长度都至少为原数组长度的ε倍 (0 \u0026lt; ε \u0026lt; 1)，那么就可以在最坏情况 下用 O(n) 时间完成选择任务。 关键问题: 怎样找到一个合适的划分基准元素? Problem A. 集合划分 # 分治算法典型问题\n#### 题目描述 n个元素的集合{1,2,..., n }可以划分为若干个非空子集。例如，当n=4 时，集合{1，2，3，4}可以划分为15 个不同的非空子集如下： {{1}，{2}，{3}，{4}}， {{1，2}，{3}，{4}}， {{1，3}，{2}，{4}}， {{1，4}，{2}，{3}}， {{2，3}，{1}，{4}}， {{2，4}，{1}，{3}}， {{3，4}，{1}，{2}}， {{1，2}，{3，4}}， {{1，3}，{2，4}}， {{1，4}，{2，3}}， {{1，2，3}，{4}}， {{1，2，4}，{3}}， {{1，3，4}，{2}}， {{2，3，4}，{1}}， {{1，2，3，4}} 给定正整数n，计算出n 个元素的集合{1,2,..., n }可以划分为多少个不同的非空子集。 #### 输入数据 多组输入(\u0026lt;=10组数据，读入以EOF结尾) 每组一行输入一个数字，n(0\u0026lt;n\u0026lt;=18) #### 输出数据 每组输出一行结果。 一种方式是添加元素 一种方式是添加集合 F(n,m)——在有 n 个元素的集合 m 中进行插入\n同样目的都是为了插入一个元素——n-1 不同的两种方式 向已有集合中添加新元素：m * F(n-1,m) 向已有结果中添加新集合：1 * F(n-1,m-1) Problem B. 二叉树的后序遍历 # #### 题目描述 给你一个二叉树，按照后序遍历的顺序输出这棵树。 #### 输入数据 第一行一个整数 n (1≤n≤1e4) ，表示这棵树的节点数。 接下来有 n-1 行，每行有两个整数 u,v ，表示节点 u 到节点 v 有一条边，输入保证树以 1 为根，且 u 为 v 的父节点。对于一个节点的多个子节点，将更早输入的那一个子节点的视为他的左子节点。 #### 输出数据 输出该树的后序遍历，节点编号之间用一个空格分隔。 构造树的方法——效果差，代码复杂 直接通过数组对树作快速处理 2 Problem C. 整数的幂次方表示 # Problem D. 最近点对 # #### 题目描述 有n个坐标点，问这些点之间最近的一对点的距离是多少？ #### 输入数据 多组输入(\u0026lt;=10组数据，读入以EOF结尾)。 每组第一行输入一个数字，n(1\u0026lt;=n\u0026lt;=100000) 表示坐标点的个数。 随后n行，为两个整数，表示对应的坐标点。 #### 输出数据 每组输出一行结果，保留两位有效数字 Problem E. 小明的散步路径 # 跟之前的方块问题一样，是非常标准非常漂亮的分治算法\nProblem F. 气球游戏 # #### 题目描述 刚刚今天去游乐场玩，发现了一个新的游戏项目，游戏是这样的，场上一共有 n 个气球，它们的编号是0到n-1，然后每个气球上还有一个数字，我们使用数组nums来保存这些数字。 现在游戏要求刚刚戳破所有的气球。每当刚刚戳破一个气球i时，刚刚可以获得nums[left] * nums[i] * nums[right]个积分。这里的left和right指的是和i相邻的两个气球的序号。（注意每当刚刚戳破了气球i后，气球left和气球right就变成了相邻的气球。） 求所能获得积分的最大值。 #### 输入数据 输入中有若干组测试样例，第一行为一个正整数T(T≤1000)，表示测试样例组数。每组测试样例包含2部分： 第一部分有一行，包含1个正整数n（0≤n≤500），第二部分为一行，有n个数，第i个数表示num[i],(0≤num[i]≤100)。 #### 输出数据 对每组测试数据，单独输出一行答案，表示最大的积分值 利用递归分治算法的典型：结合必要的备忘录机制用于减少搜索/计算空间\n"},{"id":15,"href":"/docs/Algo/3-DP/","title":"3 Dp","section":"Algo","content":" Theory\u0026amp;Thinkings # 重叠子问题\n状态表示与递推方程 状态转移：状态转移方程\n状态无后效性： 最优性原理：\n找桥梁\n找这个大的最优化问题如何由很多子问题组合而成\n由易至难，自底向上\nT：矩阵连乘积 最优子结构性质 用最外层的循环实现由易至难\n最优子结构：问题的最优解包含其子问题的最优解 隐含了问题最优解和子问题最优解之间的一种递推关系 重叠子问题：对于每个子问题只会计算一次 动态规划算法设计步骤：\n分析最优解性质，刻画最优子结构性质 确定状态表示和状态递推方程，递归地定义最优值 确定状态转移顺序，自底向上计算最优值 根据计算最优值时得到的信息，自顶向下构造最优解 循环变量一定是问题难易程度的量化指标\n真实求解过程中的 DP 解决问题思路：\n明确 dp 数组下标的含义 定义 base case 确定状态转移方程 DP 算法最重要的是状态（阶段）的寻找，状态转移方程和推理方式的确定\n动态规划 (dynamic programming) 是运筹学的一个 分支，是求解决策过程 (decision process) 最优化的 数学方法。20 世纪 50 年代初美国数学家 R.E.Bellman 等 人在研究多阶段决策过程 (multistep decision process) 的优化问题时，提出了著名的最优化原理 (principle of optimality)，把多阶段过程转化为一 系列单阶段问题，利用各阶段之间的关系，逐个求解， 创立了解决这类过程优化问题的新方法—动态规划。\n基本概念\n状态和状态表示: 表示每个阶段开始时，问题或系统所处的客观状况。状态既是该 阶段的某个起点，又是前一个阶段的某个终点。通常一个阶段有若干个状态，每个状态用多元组𝑆(𝑝1, 𝑝2, \u0026hellip; , 𝑝𝑘) 表示，值域表示状态值，或者对应子问题的答案。 状态转移: 在动态规划的多阶段决策过程中，决策序列对应状态序列，每一次决策 对应一次状态转移，状态转移用递推方程来描述，称之为状态转移方程。 状态无后效性: 如果某个阶段状态给定后，则该阶段以后过程的发展不受该阶段以前 各阶段状态的影响。 最优性原理: 求解问题的一个最优策略序列的子策略序列总是最优的，则称该问题满足最优性原理。 构建原问题最优解与子问题最优解之间的关系\n状态表示\n状态表示本质上是子问题的参数化描述: 每一个子矩阵链𝐴\u0026amp; ⋯ 𝐴4 对应一个子问题，它由 开始矩阵和结束矩阵的下标决定，记为𝐴[𝑖: 𝑗]。\n𝐴[𝑖: 𝑗] 的最优计算次序对应的乘法次数表示为𝒎 𝒊, 𝒋 , 1 ≤ 𝑖, 𝑗 ≤n，\n状态转移方程\n子问题个数及求解顺序\n自底向上的顺序进行求解，或者说从易至难的顺序求解各个子问题。\n构造最优解\n基本策略 # 非递归策略 # 由易至难，依次通过\n递归策略——备忘录策略 # 在递归过程中保存每一步的计算内容\n备忘录方法用表格保存已解决的子问题的答案，在下次需要解决此问题时，只 要从表格中提取答案即可，而不需要重新计算; 如果没有求解，则递归调用求 解过程进行计算。\n备忘录方法的控制结构与直接递归方法的控制结构相同，自顶向下的处理，程 序简单; 区别在于备忘录方法为每个求解过的子问题建立了备忘录以备需要时 查看，避免了相同子问题的重复求解。\nDP 基本要素 # 最优子结构 # 最优子结构性质，通俗地讲就是问题的最优解包含其子问题的最优解。也就是说，如果把问题的最优 解分解 (比如划分为两个或者多个部分，或者删除第一个或者最后一个分量)，得到一个子解，那么 这个子解是其相应子问题的最优解。\n最优子结构性质隐含了问题最优解和子问题最优解之间的一种递推关系。它是动态规划的基础，递推方程是最优子结构性质的体现。\n在分析问题的最优子结构性质时，人们一般采用反证法: 首先假设由问题最优解 S 导出的子问题的解不是最优的，然后再推导在这个假设下可构造出比 S 更好的解 S’，从而得到矛盾。\n注意: 同一个问题可以有多种方式刻画它的最优子结构\n重叠子问题 # 递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称 为子问题的重叠性质。\n动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时， 只是简单地用常数时间查看结果。\n通常不同的子问题数目随问题的大小呈多项式增长。因此用动态规划算法只需要多项式时间，从而获得较高的解题效率。\n算法设计步骤 # 分析最优解的性质，并刻划其最优子结构特征; 确定状态表示 S(x1,x2,\u0026hellip;) 和状态递推方程，递归地定义最优值; 确定状态转移顺序，以自底向上的方式计算出最优值; 根据计算最优值时得到的信息，自顶向下构造最优解。 小结 # 动态规划基本原理\n设计多阶段决策过程 分析最优子结构性质 建立状态表示和状态转移方程 最优子结构性质\n问题的最优解包含其子问题的最优解。也就 是说，如果把问题的最优解分解 (比如划分 为两个或者多个部分，或者删除第一个或者 最后一个分量)，得到一个子解，那么这个 子解是其相应子问题的最优解。 证明方法（反证法） 假设子解不是子问题最优解 基于子解构造原问题的一个新解 证明新解是原问题的更好答案，与前提矛盾! 最优值计算\n状态表示和状态转移方程确定问题解之 间的递推关系 有限个 (多项式级别) 状态/子问题 自底向上 (由易至难) 求解各状态值 构造状态转移方程 原问题最优解划分为多个子解: 矩阵连乘 原问题最优解约简为一个子解: 多段图最短路径、0-1 背包 对间接目标设计状态转移方程: 最大上升子序列 e.g. s # 数字三角路径问题 # 给定等腰直角数字三角形，请编一个程序计算从顶至底的某个位置的一条路径，使该路径所经过的数字的总和最大。假设每一步可延直线向下或右斜线向下走。 矩阵加括号 # 任意给定n个可乘的数字矩阵A1，A2，···，An，以及矩阵的维度p0×p1，p1×p2，…, p_(n-1)×p_n，求解给定矩阵链的最优计算次序使得所需要的数乘次数最少。 多段图最短路径 # 设G=(V, E）是一个赋权有向图，其顶点集 V 被划分成 k(k\u0026gt;2)个不相交的子集V_i (1≤i≤k），其中V1 和Vk 分别只有一个顶点 s（称为源）和一个顶点 t（称为汇），所有的边(u,v)的始点和终点都在相邻的两个子集Vi 和V_(i+1) 中：u∈Vi, v∈V_(i+1)，且边(u, v)有一个正权重，记为w(u,v)。请设计一个算法，求解从源 s 到汇 t 的权重之和最小的路径。 最长公共子序列 # 若给定序列 X=｛x_1,x_2,…,x_m｝、 Z=｛z_1,z_2,…,z_k｝，若 Z 是 X 的子序列，当且仅当存在一个严递增下标序列｛i_1,i_2,…,i_k｝，使得对于所有j=1, 2,…,k有：z_j=x_ij。例如，序列 Z=｛B，C，D，B｝是序列 X=｛A，B，C，B，D，A，B｝的子序列，相应的递增下标序列为｛2，3，5，7｝。 0-1 背包问题 # 给定n种物品和一个背包，物品i的重量是w_i，其价值为v_i，背包的容量为C，问应如何选择装入背包的物品，使得装入背包中物品的总价值最大？ double binaryKnapsack(int numItems, int *w, double *v, int capacity){ int i, j; double Val[MaxN][MaxC]; memset(Val, 0, sizeof(Val)); //初始化状态数组 for(i=0; i\u0026lt;numItems; i++) //自底向上迭代求解每一个状态 for(j=0; j\u0026lt;=capacity; j++){ Val[i][j] = Val[i-1][j]; // 第i个物品装不下 或者 放弃\tif(j \u0026gt;= w[i] \u0026amp;\u0026amp; Val[i-1][j] \u0026lt; Val[i-1][j-w[i]]+v[i] ) Val[i][j] = Val[i][j-w[i]] + v[i] ; } return Val[numItems-1][capacity]; } Input: 物品数目 n， 背包容量 C，状态矩阵 Val[n, C]，物品重量数组W[n] Output: 决策数组 X[n] Description: p = C; for i ← n to 1 if (val[i, p] != val[i-1, p]) then X[i]=1; //装入背包 p = p - W[i]; else X[i] = 0; // 未装入背包 算法改进 1：降低空间复杂度\n计算 𝑣𝑎𝑙(𝑖, 𝑝) 的值只需要 Val 数组中第 𝒊 − 𝟏 行中第𝑝个分量之前的数值。如果计算𝑣𝑎𝑙(𝑖, 𝑝) 时按照 p 的 值从大到小计算，那么只需要 Val 数组的一行即可。\n两个缺点:\n算法要求所给物品的重量是整数 当背包容量 C 很大时，算法需要的时间和空间都比较大 算法改进 2：跳跃点\n跳跃点：\n由𝑣𝑎𝑙(𝑖, 𝑝) 的递归公式容易证明，在一般情况下，对每一个确定的 𝑖, 1 ≤ 𝑖 ≤ 𝑛， 函数𝑣𝑎𝑙(𝑖, 𝑝) 是关于变量 𝑝 的阶梯状单调不减函数。 跳跃点是指在函数𝑣𝑎𝑙(𝑖, 𝑝) 中函数值发生跃迁的点，可以用一个实数序偶 (𝒙, 𝒗𝒂𝒍(𝒊,𝒙)) 描述。跳跃点是阶梯函数的描述特征，函数𝑣𝑎𝑙(𝑖,𝑝) 可由其全部跳跃点惟一确定。 对每一个确定的𝑖, 1 ≤ 𝑖 ≤ 𝑛，用一个表 𝒑[𝒊] 存储函数𝒗𝒂𝒍(𝒊, 𝒑) 的全部跳跃点; 类似地，整个状态矩阵𝑣𝑎𝑙(𝑖, 𝑝) 则可用跳跃点集合来表示。\n跳跃点递归求解\n函数𝑣𝑎𝑙(𝑖, 𝑝) 的递归定义:\n𝑣𝑎𝑙 𝑖,𝑝 =max(𝑣𝑎𝑙 𝑖−1,𝑝 ,𝑣𝑎𝑙 𝑖−1,𝑝−𝑤\u0026amp; +𝑣\u0026amp;) 𝒗𝒂𝒍(𝒊, 𝒑) 的跳跃点集合𝒑(𝒊) 是否可以由𝒑(𝒊 − 𝟏) 构造？ 构造过程：\n𝐩𝟎 ={(𝟎,𝟎)}\n先由𝑝[𝑖−1] 计算出𝑞[i-1]\n合并𝑝[𝑖−1] 和𝑞[𝑖−1]，并清除其中的受控跳跃点\n跳跃点集𝒑(𝒊 − 𝟏): 由函数𝑣𝑎𝑙 𝑖 − 1, 𝑝 决定，对应于不装第𝒊个物品的所有装包情形\n跳跃点集𝒒(𝒊 − 𝟏): 由函数𝑣𝑎𝑙 𝑖 − 1, 𝑝 − 𝑤\u0026amp; + 𝑣\u0026amp;决定，对应于装上第𝑖个物品的所有情形，即𝑞𝑖−1=𝑝𝑖−1 Å 𝑤\u0026amp;,𝑣\u0026amp;={(𝑝+𝑤\u0026amp;,𝑣𝑎𝑙(𝑖−1,𝑝)+𝑣\u0026amp;)|𝑝,𝑣𝑎𝑙𝑖−1,𝑝 Î𝑝𝑖−1,𝒑+𝒘𝒊≤𝑪}\n受控跳跃点\nInput: 物品数目 n， 背包容量 C，物品重量数组W[n]，物品价值数组V[n] Output: 跳跃点集合 P[n] Description: #define PD pair\u0026lt;double, double\u0026gt; // 定义跳跃点 vector\u0026lt;PD\u0026gt; setP, setPT; // 跳跃点集合p和临时集合 vector\u0026lt;PD\u0026gt; setQ; // 跳跃点集合q clear setP, setPT, setQ; setP.push_back(make_pair(0.0, 0.0)); // 初始化p[0] fori← 0ton for j ← 0 to setP.size() generate setQ; // 按照规则生成跳跃点集合q while (posP \u0026lt; setP.size()) || (posQ \u0026lt; setQ.size()) merge setP, setQ to setPT; // 合并p[i] 和 q[i]，注意setPT要删除受控跳跃点 copy setPT to setP; clear setQ; 最大上升子序列 # 问题描述: 给出一个整数序列 𝑆 = 𝑠\u0026#39;, 𝑠0, ⋯ , 𝑠$ ，假定每个数字互相不相同 如果其子序列 𝑠 𝑖\u0026#39; , 𝑠 𝑖0 , ⋯ , 𝑠 𝑖#.\u0026#39; ，满足1\u0026lt;=𝑖\u0026#39;\u0026lt;𝑖0 \u0026lt;··· \u0026lt;𝑖# \u0026lt;=n， 𝑠 𝑖\u0026#39; \u0026lt;𝑠 𝑖0 \u0026lt;⋯\u0026lt;𝑠 𝑖# ，则称之为上升子序列。 请设计算法求解任意给定序列的最大上升子序列，即 k 最大的子序列。 如果直接把最大上升子序列的长度作为规划目标，那么该问题不具备最优子结构性质。 只能采用间接的办法，引入一些 中间目标 作为动态规划的对象。\n限界上升子序列\n给定序列𝑆 = [𝑠$, 𝑠(, ⋯ , 𝑠% ]，所有以𝒔𝒎为上界的上升子序列定义为限界上升子序列，描述为 [𝑆 𝑖$ ,𝑆 𝑖( ,⋯,𝑆 𝑖4 , 𝑆(𝑚)]，满足: 1≤𝑖$ \u0026lt;𝑖( \u0026lt;⋯\u0026lt;𝑖4 \u0026lt;𝑚，𝑆 𝑖$ \u0026lt;𝑆 𝑖( \u0026lt;⋯\u0026lt;𝑆 𝑖4 \u0026lt;𝑆(𝑚)。 𝑆的限界上升子序列中最长的称之为最大限界上升子序列。 最大限界上升子序列 与 最大上升子序列具有什么样的关系?\n得到所有𝑠$,𝑠(,⋯,𝑠% 为上界的最大限界上升子序列后，取其中的最大值即可得到输入序列 S 的最大上升子序 从最大限界上升子序列计算最大上升子序列的时间复杂性为 O(n)。 状态表示与递推方程\n算法改进：取小值作为开头\n对于𝐿𝑒𝑛[𝑖], 假设有 x, y \u0026lt; i，其中 S[x] \u0026lt; S[y] \u0026lt; S[i]，并且 𝐿𝑒𝑛 𝑥 = 𝐿𝑒𝑛[𝑦]， 即选择 x 或 选择 y 可以构造得到相同的𝐿𝑒𝑛[𝑖]。\n那么在这个位置上选择哪个更好呢?\n显然，选 x 位置更好些，因为选 x 的话，有得到更长序列的可能性!\n启示: 对于值相等的𝑳𝒆𝒏[𝒊]，我们可以保留所有 S[i] 中最小的值， 然后基于该值去构造更长的上升子序列。\nT[k] 存储所有 Len[i] = k 中最小的𝑺[𝒊]，即: 𝑇[𝑘] = min{𝑆 𝑖 | Len[𝑖] = 𝑘}\nProblem A. 晴天小猪历险记之 Hill # #### 题目描述 这一天，他来到了一座深山的山脚下，因为只有这座深山中的一位隐者才知道这种药草的所在。但是上山的路错综复杂，由于小小猪的病情，晴天小猪想找一条需时最少的路到达山顶，但现在它一头雾水，所以向你求助。 山用一个三角形表示，从山顶依次向下有1段、2段、3段等山路，每一段用一个数字T（1\u0026lt; =T\u0026lt; =100）表示，代表晴天小猪在这一段山路上需要爬的时间，每一次它都可以朝左、右、左上、右上四个方向走（**注意**：在任意一层的第一段也可以走到本层的最后一段或上一层的最后一段）。 晴天小猪从山的左下角出发，目的地为山顶，即隐者的小屋。 #### 输入数据 第一行有一个数 n (2≤n≤1000)，� (2≤�≤1000)， 表示山的高度。 从第二行至第 n+1�+1 行，第 i+1�+1 行有 i� 个数，每个数表示晴天小猪在这一段山路上需要爬的时间。 #### 输出数据 一个数，即晴天小猪所需要的最短时间。 不好划分阶段怎么办？——抛弃阶段概念\nProblem B. 清帝之惑之顺治 # #### 题目描述 顺治喜欢滑雪，这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待太监们来载你。顺治想知道载一个区域中最长的滑坡。 区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 顺治可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。 #### 输入数据 输入的第一行表示区域的行数 R� 和列数 C (1≤R,C≤500)� (1≤�,�≤500) 。下面是 R� 行，每行有 C� 个整数，代表高度 h,0≤h\u0026lt;103ℎ,0≤ℎ\u0026lt;103 。 #### 输出数据 输出最长区域的长度。 同样，直接抛弃掉阶段的概念，直接作为类似坐标的点刻画\nProblem C. 积木城堡 # #### 题目描述 XC的儿子小XC最喜欢玩的游戏用积木垒漂亮的城堡。城堡是用一些立方体的积木垒成的，城堡的每一层是一块积木。小XC是一个比他爸爸XC还聪明的孩子，他发现垒城堡的时候，如果下面的积木比上面的积木大，那么城堡便不容易倒。所以他在垒城堡的时候总是遵循这样的规则。 小XC想把自己垒的城堡送给幼儿园里漂亮的女孩子们，这样可以增加他的好感度。为了公平起见，他决定把送给每个女孩子一样高的城堡，这样可以避免女孩子们为了获得更漂亮的城堡而引起争执。可是他发现自己在垒城堡的时候并没有预先考虑到这一点。所以他现在要改造城堡。由于他没有多余的积木了，他灵机一动，想出了一个巧妙的改造方案。他决定从每一个城堡中挪去一些积木，使得最终每座城堡都一样高。为了使他的城堡更雄伟，他觉得应该使最后的城堡都尽可能的高。 任务： 请你帮助小XC编一个程序，根据他垒的所有城堡的信息，决定应该移去哪些积木才能获得最佳的效果。 #### 输入数据 第一行是一个整数 N (N≤100)，� (�≤100)， 表示一共有几座城堡。以下 N� 行每行是一系列非负整数，用一个空格分隔，按从下往上的顺序依次给出一座城堡中所有积木的棱长。用`-1`结束。一座城堡中的积木不超过100块，每块积木的棱长不超过100。 #### 输出数据 一个整数，表示最后城堡的最大可能的高度。如果找不到合适的方案，则输出 00 。 0-1 背包问题变种——非常好的一道题\nProblem D. Warcraft III 守望者的烦恼 # #### 题目描述 头脑并不发达的warden最近在思考一个问题，她的闪烁技能是可以升级的，k级的闪烁技能最多可以向前移动k个监狱，一共有n个监狱要视察，她从入口进去，一路上有n个监狱，而且不会往回走，当然她并不用每个监狱都视察，但是她最后一定要到第n个监狱里去，因为监狱的出口在那里，但是她并不一定要到第1个监狱。 守望者warden现在想知道，她在拥有k级闪烁技能时视察n个监狱一共有多少种方案？ #### 输入数据 第一行是闪烁技能的等级 k (1≤k≤10)� (1≤�≤10) 第二行是监狱的个数 n (1≤n≤231−1)� (1≤�≤231−1) #### 输出数据 由于方案个数会很多，所以输出它 mod 7777777后的结果就行了 Problem E. 加分二叉树 # #### 题目描述 设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数 若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出； （1）tree的最高加分 （2）tree的前序遍历 #### 输入数据 第 11 行：一个整数 n (n＜30)，� (�＜30)， 为节点个数。 第 22 行 ：n：� 个用空格隔开的整数，为每个节点的分数（分数 ＜100）＜100） 。 #### 输出数据 第 11 行：一个整数，为最高加分（结果不会超过 4,000,000,000）4,000,000,000） 。 第 22 行 ：n：� 个用空格隔开的整数，为该树的前序遍历。 若存在多种前序遍历均为最高加分，则输出字典序最小的前序遍历 双线程 dp # 题解 P1004 【方格取数】 - Born to be a miracle - 洛谷博客\n"},{"id":16,"href":"/docs/Algo/4-Greedy/","title":"4 Greedy","section":"Algo","content":" Method # 基本思想 # 贪心算法基本思想\n贪心算法是一个分阶段决策过程，在每个局部阶段，贪心法都做出一个当前 最优的局部决策，并期望通过每次所做的局部最优决策产生一个全局最优解。\n贪心算法类似于分治算法和动态规划，也是一种基于子问题思想的策略。\n贪心算法求解步骤\n分解，将原问题求解过程划分为连续的若干个决策阶段 决策，在每一个阶段依据贪心策略进行贪心决策，得到局部的最优解，并缩小待求解问题的规模 合并，将各个阶段的局部解合并为原问题的一个全局最优解 Greedy(C) { // C是问题的输入集合即候选集合 S = {}; // 初始解集合为空集 while (not Solution(S)) { // 集合S没有构成问题的一个可行解 x = Select(C); // 在候选集合C中做贪心决策 S = S + {x}; C = C - {Collection(x)}; // 减去一个与x关联的集合，缩小问题规模 } return S; } 候选集合 C 是构造问题的解 (包括最优解) 的对象集合 解集合 S 表示问题的解，它随着贪心选择的进行不断扩展，直到构成一个满足问题的完整解 选择函数 Select 是贪心策略的实现过程，这是贪心法的关键，它指出哪个候 选对象最有希望构成问题的最优解，选择函数通常和目标函数有关 正确性证明 # 数学归纳法\n证明目标 ∀ 𝒏 𝒑(𝒏) 为真 / / n 的论域为正整数集合 证明框架 基础步骤: p(1) 为真 归纳步骤: 证明∀k(p(k) →p(k+1)) //对任意正整数 k, 给出 p(k)├ P(k+1) 的论证步骤 结论: 对任意正整数 n，p(n) 成立 交换论证法\n交换论证法 (Exchange Argument ): 从任意一个最优解出发，经过不断用新的要素 (符合贪心准则) 替换解中的原有要素来改变这个解。通过有限步替换，把这个最优解改造成贪心算法的解。如果替换过程中的每一步能保证解的最优值不发生变化，则证明了贪心算法的解也是最优的。\n具体步骤：\n给出贪心算法解 A 的描述 假设 O 是一个最优算法解 (如果有多个则随机选) 找出 O 和 A 中的一个不同要素 (可以是一个元素在 O 不在 A 或者反之，或者是一个子序列的顺序 A 和 O 不一样) 交换 (Exchange)*上述不同的要素，然后论证 (Argue) 得到的新解 O 不比 O 差 论证类似的不同要素为有限个 (多项式量级)，然后交换有限次 (多项式量级) 可以消除所有的不同，同时保证了算法的质量不比 O 差 e.g.s # 活动安排问题 # 假设某社团某一天要组织𝑛个活动𝐸={1,2,⋯,𝑛} ，其中每个活动都要求使用同一礼堂，而且 在同一时间内只有一个活动能使用这个礼堂。每个活动𝑖都有一个要求使用礼堂的起始时间𝑠𝑖 和结束时间 𝑓 ，且有𝑠 \u0026lt; 𝑓 。如果选择了活动𝑖，则它在半开时间区间[𝑠 , 𝑓 ) 内占用资源。若区间[𝒔𝒊, 𝒇𝒊) 与区间[𝒔𝒋, 𝒇𝒋) 不相交，则称活动𝐢与活动𝐣是相容的。现在给定𝑛个活动的开始时 间和结束时间，请设计一个活动安排方案，使得安排的相容活动数目最多。 策略思考\n策略一: 选择具有最早开始时间，而 且不与已安排的活动冲突的活动。 策略二: 选择具有最短使用时间，而且 不与已安排的活动冲突的活动。 策略三: 选择具有最早结束时间，而且不与已安排的活动冲突的活动。 算法思路\n预处理 把所有的活动按照结束时间进行升序排列，有𝑓[1] ≤ 𝑓[2] ≤ ⋯ ≤ 𝑓[𝑛] 选择第一个活动 选择结束时间最早的活动 𝐸[1]，当前决策𝑠𝑒𝑙𝑒𝑐𝑡𝑒𝑑 = 1 贪心选择后续活动 依次扫描后续的每一个活动𝐸[𝑖]，如果𝐸[𝑖] 的开始时间晚于上一个 选择的活动 E[selected ] 的结束时间，则安排当前活动𝐸[𝑖]，令𝑠𝑒𝑙𝑒𝑐𝑡𝑒𝑑 = 𝑖; 否则放弃 𝐸[𝑖]。 int greedyEventSchedule(int n,int *timeStart,int *timeFinish) { int i,j,selected,ans=0; //冒泡排序，使得活动按结束时间升序排列 for(i=0; i\u0026lt;n; i++) for(j=0; j+1\u0026lt;n; j++) if(timeFinish[j]\u0026gt;timeFinish[j+1]) { swap(timeFinish[j],timeFinish[j+1]); swap(timeStart[j],timeStart[j+1]); //注意开始时间也需一致移动 } ans = 1; selected = 0; //选择第一个活动 for(i=1; i\u0026lt;n; i++) if(timeStart[i]\u0026gt;= timeFinish[selected]) { selected = i; //选择相容的最早结束活动 ans++; } return ans; } 算法正确性证明\n小数背包问题 # 问题描述:给定𝑛种物品和一个背包。物品𝑖的重量是𝑊𝑖，其价值为𝑉𝑖，背包的容量为C，应如何 选择装入背包的物品使得装入背包中物品的总价值最大? 这里，在选择物品𝑖装入背包时，可以选 择物品𝑖的一部分，而不一定要全部装入背包。 输入:多组测试数据。每组测试包括三行:第一行输入物品的总数𝑛(𝑛 \u0026lt; 1000)和背包的容量 𝐶(𝐶 \u0026lt; 1000)。第二行输入𝑛个整数，表示物品的重量。第三行输入物品的价值。 输出:输出装入背包的总价值，每组测试数据输出一行。 输入样例: 3 50 10 20 30 60 100 120 输出样例: 240 策略思考\n策略一: 在不超出当前背包的剩余容量前提下，优先选择价值最大的物品，这样使得装 入价值增长最快。 策略二: 在不超出当前背包的剩余容量前提下，优先选择重量最轻的物品，这样使得背包 容量增长最慢。 策略三: 在不超出当前背包的剩余容量前提下，优先选择价值率 (价值除以重量) 最 大的物品，这样使得背包中单位重量价值增长最快。 算法思路\n预处理，把物品按照价值率进行降序排列 选择第一个物品 根据贪心策略，首先选择价值率最大的物品，并记录该物 品装入的重量。 贪心选择后续活动 依次扫描每一个物品，在没有超出背包容量的条件下， 尽可能多地装入当前价值率最高的物品，并记录该物品装入的重量。 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; #defineMaxItems 1000 struct item{ int weight; int value; bool operator \u0026lt;(const item\u0026amp; bb) const { //定义比较函数(小于号) return value/(1.0*weight) \u0026gt; (1.0*bb.value)/bb.weight; //为什么乘以1.0? } }; //定义物品的结构体 double greedyKnapsack(int n,int capacity,item* itemSet) { double ans = 0; sort(itemSet,itemSet+n); //STL中的快速排序算法 for(int i=0; i\u0026lt;n; i++) if(itemSet[i].weight \u0026lt;= capacity){ ans += itemSet[i].value;//选择单价最大的物品 capacity -= itemSet[i].weight; capacity-=itemSet[i].weight; } else { ans += capacity*(itemSet[i].value*1.0)/itemSet[i].weight;//最后一个物品只能装部分 break; } return ans; } 在这段代码中，乘以 1.0 主要是为了确保在进行除法运算时，使用浮点数而不是整数。在 C++ 中，如果两个整数进行除法运算，结果会被截断为整数部分，这可能导致不准确的比较结果。\n通过乘以 1.0，将其中一个操作数转换为浮点数，整个表达式就会被当作浮点数运算，确保得到的结果是浮点数而不是整数。这样可以避免由于整数截断而导致的错误比较。\n字符编码 # 一个包含100,000个字符的文件，各字符出现频率不同，如下表所示。请设 计一个编码算法，把每一个字符转换为二进制编码。 不同的字符 二元前缀码 在一个字符集的编码表 (每一个编码都表示为 0-1 字符串) 中，如果任何一个字符编码 都不是其它字符编码的前缀，则该编码称为二元前缀码。\n编码: 把字符转换为二元前缀码的过程 解码: 把二元前缀码 (0-1 符号串) 映射为字符的过程。从第一个字符开始依次读入每个字符 (0 或者 1)，如果发现读到的子串与某个代码相等，就将这个字串译作相应代码的字符。 二元前缀码的存储通常采用二叉树结构，令字符保存在叶节点，则该字符的前缀码对 应根到该叶节点的一条路径。规定每个节点通向左儿子的边记为 0，通向右儿子的边 记为 1，则根到叶节点的路径则可以转换为一个 0-1 串，映射为二元前缀码。\n一个字符集可以构造多个二元前缀码。\n哈夫曼编码\n哈夫曼编码算法的贪心策略是: 给频率高的字符较短的代码; 频率低的字符较长的代码\n把编码映射成二叉树，则其贪心策略可表述为: 把频率高的字符分配给靠近根结点 (较浅) 的叶结点，把频率低的字符放置在远离根结点 (较深) 的叶结点\n自底向上构造二叉编码树，由森林不断合并得到一棵二叉树\n算法思路 为了便于找到频次最低的字符，哈夫曼算法建立一个以𝐟为键值的优先队列 Q，假设 编码字符集中每一字符𝐜的频率是𝐟(𝐜)。哈夫曼编码算法以自底向上的方式构造最优 编码树 T。 每个字符构成一棵只包含一个结点的树，总共有ȁ𝐶ȁ棵构成一个森林。 合并频率最低的两棵树，并产生一棵新树，其频率为合并的 2 棵树的频率之和，并将新树插入优先队列 Q。 循环此过程，经过𝑛-1 次这样的合并后，优先队列中只剩下一棵树，即最优二叉编码树 T。 struct cmp { bool operator () (const int \u0026amp;x,const int \u0026amp;y) { return x \u0026gt; y; } }; //定义优先队列需要的比较函数 double haffmanCoding(int n, int* freq) { int i, total = 0, sumFreq = 0, jointFreq; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; heap; // 优先队列，最小值优先 for(int i=0;i\u0026lt;n;i++){ total += freq[i]; heap.push(freq[i]); } while (heap.size() \u0026gt; 1) { // 循环选择队列中频次最少的两个元素合并 jointFreq = 0; // 合并后结点的频次 for (i = 0; i \u0026lt; 2; i++) { // 删除频次最少的两元素 jointFreq += heap.top(); heap.pop(); } sumFreq += jointFreq; heap.push(jointFreq); // 优先队列中插入合并结点 } return sumFreq / (1.0 * total); // 返回平均码长 } 正确性证明 交换论证法原理: 从任意一个最优解出发，经过不断用新的要素 (符合贪心准则) 替 换解中的原有要素来改造这个解。通过有限步替换，把这个最优解改变成贪心算法的 解。如果替换过程中的每一步能保证解的最优值不发生变化，则证明了贪心算法的解 也是最优的。 基础步: 给定任意一个最优解，根据贪心准则对最优解进行改造，也就是把第一步 贪心选择的对象替换最优解中的特定要素，然后证明替换后的新解也是最优解 递归步: 证明上述交换过程可以循环进行。也就是说，依次替换最优解的其他要素， 直到新解的每个分量都符合贪心准则，并且证明新解也是最优的。 证明方法一般是: 最优子结构性质 + 基础步结论 设一个任意一个，假设谈心算法得到的解不是最优解（本题中是和普通情况一样） 每一步进行贪心调整，若结果发现是最优解，证明假设不成立，则能够证明谈心算法的正确性 单源最短路径问题 # 给定带权有向图G = (V, E)，其中每条边的权是非负实数。另外，还给定V中的一个顶点，称 为源。现在要计算从源到所有其它各顶点的最短路径长度，假设从源可以到达任何一个顶点。 这里路径的长度是指路径上各边权之和。这个问题通常称为单源最短路径问题。 从源到任意顶点的最短路径具有类似于最优子结构性质的特征: 即最短路径的子 路径也是源到相应顶点的最短路径。\n汇集所有顶点的最短路径就可以得到一棵最短路径树。在最短路径树中，从 源到任意顶点的路径就是图 G 中从源到该顶点的最短路径。 求解单源最短路径问题就可以转换为构造图 G 的一棵最短路径树𝐓。 Dijkstra 算法\nDijkstra 算法的贪心策略是选择集合𝐕 − 𝐒中受限路径长度最短的顶点，并把相应顶点加 入 𝑆 中，相应地最短路径树 𝑇 也增加一条边。\n算法思路 设计合适的数据结构: 带权邻接矩阵 linkMatrix，记录输入有向图的权值 数组 lowLR 记录从源到其它顶点的最短受限路径长度 数组 preV 记录最短路径中的前驱顶点，假设 preV[x] = u，则在 x 的最短路径中，u 是 x 的前驱顶点 初始化: 把源加入集合 S 中，即 S = {v}，对于 V-S 中的所有顶点 x，设置 lowLR[x] =linkMatrix[v][x]，preV[x] = v(如果有边相连) 贪心选择: 在集合 V-S 中依照贪心策略寻找 lowLR[x] 最小的顶点 t ，即 lowLR[t]=min{lowLR[x] x 属于 (V −S)} 更新过程: 将顶点 t 加入 S 中，同时更新集合 V-S，以及集合中顶点的最短受限路径: lowLR[x] = lowLR[t]+ linkMatrix[t][x] st. lowLR[x] \u0026gt; lowLR[t]+ linkMatrix[t][x] #include \u0026lt;iostream\u0026gt; #define INF 0x03F3F3F3F #define MaxV 100 int preV[MaxV]; // 最短路径树中的前驱结点信息表 int visited[MaxV]; // 结点是否加入S的标记表，0 是未加入，1 为已加入 void Dijkstra(int linkMatrix[][MaxV], int lowLR[MaxV], int numV, int beginV) { int i, j, min, newCost; memset(visited, 0, sizeof(visited)); // 初始化，所有节点未加入 visited[beginV] = 1; // 开始节点 beginV加入列表中 for (int i = 0; i \u0026lt; numV; i++) { lowLR[i] = linkMatrix[beginV][i]; preV[i] = beginV; } // 准备正式开始Dijkstra算法流程 lowLR[beginV] = 0; preV[beginV] = -1; int selectV = beginV; for (int i = 0; i \u0026lt; numV; i++) { for (int j = 0; j \u0026lt; numV; j++) { newCost = lowLR[selectV] + linkMatrix[selectV][j]; if (visited[j] == 0 \u0026amp;\u0026amp; newCost \u0026lt; lowLR[j]) { lowLR[j] = newCost; preV[j] = selectV; } } min = INF; // 贪心选择最短路径 for (int j = 0; j \u0026lt; numV; j++) { if (visited[j] == 0 \u0026amp;\u0026amp; lowLR[j] \u0026lt; min) { min = lowLR[j]; selectV = j; } } visited[selectV] = 1; } } 正确性证明\n最小生成树问题 # 问题描述:设𝐺 =(𝑉,𝐸)是无向连通带权图。E中每条边(𝑣,𝑤)的权为𝐶(𝑣,𝑤)。如果𝐺的子图𝐺’是 一棵包含𝐺的所有顶点的树，则称𝐺’为𝐺的生成树。生成树上各边权的总和称为该生成树的耗费。 在G的所有生成树中，耗费最小的生成树称为G的最小生成树。请设计算法计算G的最小生成树的 权重总和。 图的生成树\n定义: 如果连通图 G 的一个子图是一棵包含 G 的所有顶点的树，则该子图称为 G 的生 成树 (Spanning Tree)。\n生成树是连通图的包含图中的所有顶点的 极小连通子图 图的生成树不惟一，从不同的顶点出发进行遍历，可以得到不同的生成树 常用的生成树算法有 DFS 生成树、BFS 生成树、PRIM 最小生成树和 Kruskal 最小生成树算法 最小生成树\n定义: 对于连通的带权图 G=(V, E)，其生成树也是带权的，生成树 T=(V, TE) 各 边的权值总和称为该树的权 W(T)， TE 表示 T 的边集，𝐶(𝑢,𝑣) 表示边 (u,v) 的权重。 权最小的生成树称为 G 的最小生成树 (Minimum Spanning Tree, MST)。\n最小生成树性质 生成树有 |V| 个顶点，|V|-1 条边 生成树中增加一条边则得到一个回路，回路中删除任何一条边又得到一棵生成树 设𝐺 = (𝑉, 𝐸) 是连通带权图，U 是 V 的真子集。如果 (𝑢, 𝑣) ∈ 𝐸，其中𝑢 ∈ 𝑈, 𝑣 ∈ (𝑉 − 𝑈) ，称之为 跨边，且在所有这样的边中，(𝒖, 𝒗) 的权𝑪(𝒖, 𝒗) 最小，那么一定存在𝐺的一 棵最小生成树，它包含边 (𝑢, 𝑣)。 Prim 算法\n针对图中的顶点设计贪心策略，逐步 添加顶点/边构造最小生成树\n策略: 选择最短跨边\n策略思考\n给定无向带权图 G=\u0026lt;V, E\u0026gt;，逐步构造最小生成树:MST = (U, TE)，其中 U⊆V, TE⊆E。图 G 中的顶点集合 V 划分为两部分: 集合 U 和 V-U，其中 U 是已加入 MST 中 的顶点集合，而 V-U 是 MST 之外的顶点集合。 初始化:U={x}，其中 x 为集合 V 中的任一结点 (起始点)，TE={}; 循环直到 U=V: 贪心选择:𝒊 ∈ U, j ∈ V − U，且边 (i, j) 是连接 U 和 V-U 的所有边中的最短 边 把顶点 j 加入集合 U ➢ 边 (i, j) 加入集合 TE 算法思路\n设计合适的数据结构: 带权邻接矩阵 linkMatrix，记录输入有向图的权值 数组 lowCost 最短跨边， lowCost[ j] 表示满足𝑗 ∈ 𝑉 − 𝑈, 𝑖 ∈ 𝑈的所有边 (𝑖, 𝑗) 中的最小值 数组 closest 记录上述最短边 (𝑖, 𝑗) 中的顶点标号 i ，它们满足 𝑙𝑜𝑤𝐶𝑜𝑠𝑡[𝑗] = 𝐶(𝑗, 𝑐𝑙𝑜𝑠𝑒𝑠𝑡[𝑗]) 。 初始化: 把顶点 1 加入 U 中，得 U = {1}，𝑇𝐸 = { }， 并初始化数组 closest 和 lowCost 贪心选择: 在集合𝑉 − 𝑈中寻找使得 lowCost 最小的顶点 t， 将 t 加入集合 U，边 (t, cloest[t]) 加入集合 TE 更新过程: 对 𝑉 − 𝑈 中的所有顶点 𝑘，按下述规则更新数组 closest 和 lowCost: if (linkMatrix[t][k] \u0026lt; lowCost[k]) lowCost[k] = linkMatrix[t][k]; closest[k] = t #include \u0026lt;iostream\u0026gt; #define INF 0x03F3F3F3F #define MaxV 1000 int prim(int linkMatrix[][MaxV], int numV) { int visited[MaxV] = {0}; int lowCost[MaxV], closet[MaxV]; int i, k; int min, costMST = 0; visited[0] = 1; closet[0] = -1; for (int i = 0; i \u0026lt; numV; i++) { lowCost[i] = linkMatrix[0][i]; closet[i] = 0; } for (int i = 0; i \u0026lt; numV - 1; i++) { min = INF; int selectV = 0; for (int k = 0; k \u0026lt; numV; k++) { if (!visited[k] \u0026amp;\u0026amp; lowCost[k] \u0026lt; min) { min = lowCost[k]; selectV = k; } } costMST += min; visited[selectV] = 1; for (int k = 1; k \u0026lt; numV; k++) { if (!visited[k] \u0026amp;\u0026amp; linkMatrix[selectV][k] \u0026lt; lowCost[k]) { lowCost[k] = linkMatrix[selectV][k]; closet[k] = selectV; } } } return costMST; } 正确性证明\n并查集 # 并查集 (Disjoint set 或者 Union-find set) 是一种树型的数据结构，常用于处理一些不相交集 合 (Disjoint Sets) 的合并及查询问题。它包含两种基本操作:\n查询 (Find): 查询某个元素在哪个集合里\n合并 (Union): 合并两个集合\n每个集合选定一个固定的元素作为该集合的代表， 称为代表元素，代表元素则用于标识整个集合\n每一个集合用树表示，树中的每一个节点保存着 到其父节点的引用，每个集合的代表元素即是集 合的根节点。\n双亲表示法: 用数组 father[] 存储整个并查集\n查询\n合并\n并查集优化策略一——路径压缩\n路径压缩是一种在执行“查询”时扁平化树结构的方法，为后续查询操作加速。\n路径上的每个节点都直接连接到根上; 递归地访问当前结点到树根的路径，改变每一个结点的引用到根节点。 并查集优化策略二——按秩合并\n按秩合并即总是将更浅的树连接至更深的树上，避免增加合并树的秩\n“秩”表示集合对应树的深度，单个元素的树的秩定义为 0; 当两棵秩同为𝑟的树联合时，它们的秩变为𝑟 + 1; 为了方便比较，把集合秩的相反数存储在根节点 father[root] 。 Kruskal 算法 # 给定无向带权图𝐺=(𝑉,𝐸)，𝑉={1,2,\u0026hellip;,𝑛}。设最小生成树𝑀𝑆𝑇 = (𝑉, 𝑇𝐸)，该树的 初始状态为只有𝐧个顶点而无边的非连通图𝑇 = (𝑉, {} )， Kruskal 算法将这𝑛个顶点看成 是𝑛个孤立的连通分支;\n贪心选择: 在边集𝐸中选择权值最小的边 (𝑖, 𝑗)，如果将边 (𝑖, 𝑗) 加入 TE 中不产生回路，则 将边 (𝑖, 𝑗) 加入 TE，即用边 (𝑖, 𝑗) 将 T 中的两个连通分支合并成一个联通分支; 否则舍弃它。 循环此过程，直至所有顶点都在一个联通分支。\nKruskal 算法俗称避环法，该算法的实现关键是在加入边时避免出现环路 用并查集来实现连通分支查找和合并的相关操作\n算法步骤 初始化: 把图 G 中的所有边按照权值从小到大排序，MST 的边集 TE 初始化为空集。 每一个顶点初始化为一个孤立的连通分支，对应并查集中的一个子集合。 在 E 中寻找权值最小的边 (𝑖,𝑗)。 如果顶点𝑖和𝑗位于两个不同的集合 则将边 (𝑖, 𝑗) 加入边集 TE 并把顶点𝑖和𝑗所在的两个子集合并成一个子集 将边 (𝑖, 𝑗) 从 E 中删除 如果连通分支的数目大于 1，则转步骤 2; 否则，算法结束。 int kruskal(node juSet[MaxV], int numV, edge edgeSet[MaxE], int numE) { qsort(edgeSet, numE, sizeof(struct edge), cmp); for (int i = 0; i \u0026lt; numE; i++) { fatherX = Find_Set(edgeSet[i].x); fatherY = Find_Set(edgeSet[i].y); if (fatherX == faterY) { totalCost += edgeSet[i].w; cntW++; } if (cntE == numV - 1) { return totalCost; } } return totalCost; } 算法正确性证明 给出贪心算法解 A 的描述 假设 O 是一个最优算法解 (如果有多个则随机选) 找出 O 和 A 中的一个不同要素 (可以是一个元素在 O 不在 A 或者反之，或者是一个子序列的顺序 A 和 O 不一样) 交换 (Exchange) 上述不同的要素，然后论证 (Argue) 得到的新解 O* 不比 O 差 论证类似的不同要素为有限个 (多项式量级)，然后交换有限次 (多项式量级) 可以消除所有的不同，同时保证了算法的质量不比 O 差 小结 # 贪心算法的正确性证明\n数学归纳法 针对贪心选择的步骤 (k) 进行归纳，比如活动安排问题，Dijkstra 算法，Prim 算法。 交换论证法 从原问题最优解开始，用贪心策略对最优解进行改造 (或者交换最优解与贪心解的不同要素)，有限步后把最 优解改造为贪心解，而且最优性保持不变。比如哈夫曼编 码，Kruskal 算法。 "},{"id":17,"href":"/docs/Algo/5-Search/","title":"5 Search","section":"Algo","content":" Intro # 问题求解与搜索算法 # 问题求解涉及到两个方面:\n问题的表示，比如枚举对象、状态表示 求解的方法，比如自顶向下的递归，自底向上的动态规划 搜索算法是一种通用的问题求解方法: 首先把问题表示 转换为一个状态空间图，然后设计特定的图遍历方法在状态空间中搜索问题的答案。\n为了提高搜索的效率，在遍历状态空间时需要添加优化技术，比如剪枝策略用于尽可能避免无效搜索，启发式信息用来加速朝目标状态逼近的速度。\n状态空间图 # 一个问题用搜索算法求解时，往往需要把问题描述为状态空间图，包括以下要素\n状态 (State): 是为描述某类不同事物间的差别而引入的一组最少变量的有序集合，其矢量 形式为: 1 2 n ，其中每个分量 i 称为状态分量。 操作符 (运算符): 是指把一个状态转换为另外一个状态的操作或者运算。操作符可以是规划、数学运算和问题场景中行为等。 状态图: 如果把状态定义为图的结点，操作符定义为图的边，一个问题的全部可能状态则可 以表示为一个图，即状态图。 路径: 通过操作符序列连接起来的状态图中的一个状态序列。 路径耗散函数: 定义在路径上的一个数值函数，它反映了一条路径的性能度量或者求解问题 的代价。在求解最优化问题时，路径耗散函数往往与优化目标相关联。 状态空间图可以形式化地定义为一个四元组 (S，A，G，F)\nS 表示问题的初始状态，它是搜索的起点。 A 是采取的操作符集合，初始状态和操作符隐含地定义了问题的状态图。 G 表示目标测试，它判断给定的状态是否为目标状态。它可以是表示目标状态的一个状态集合，也可以是一个判定函数。 F 代表路径耗散函数，它的定义需要具体问题具体分析。 搜索就是在状态空间图中从初始状态出发，执行特定的操作，试探地寻找目标状态的过 程。当然，也可以从目标结点到初始结点反向进行。状态空间图中从初始状态到目标状 态的路径则代表问题的解。解的优劣由路径耗散函数量度，最优解就是路径耗散函数值 最小的路径。\n搜索算法类型 # 基于枚举的通用搜索 # DFS # 深度优先搜索 (Depth First Search, DFS) 是一种通用的图和树的遍历方法，给 定图𝐺 = (𝑉, 𝐸)，深度优先搜索的基本思想为:\n初始化 任选一个结点𝑣作为源结点，DFS 访问源结点𝑣，并将其标记为已访问过 能进则进，不进则退 递归遍历 扩展结点𝑣，即访问𝑣的下一个未访问邻接结点𝑤; 递归处理以𝑤为根的所有子结点; 退回到结点𝑣，继续扩展𝑣的其它未曾访问的邻接结点，直到𝑣的所有子结点均已访问过为止。 循环处理 若图𝐺中仍然存在未访问的结点，则另选一个未访问的结点作为新的源 结点重复上述过程，直到图中所有结点均被访问过为止。 基于栈的 DFS 算法框架:\nfunction DFS(problem,stack){ node = Make-node(Initial-State[problem]); stack \u0026lt;- insert(node,stack); while(1){ if(stack == empty){ return; } node = pop(stack); visit(node); if(state[node]== GOAL){ return Solution(node); } sonNodes = Expand(node,problem); stack \u0026lt;- InsertAll(sonNodes,stack); } } 基于递归的 DFS 算法框架：\nfunction DFS(problem, node) if State[node] == Goal/Failure // 递归出口 return Solution(node); else visit(node); // 访问当前结点 for(iterator sonNode = Init(node); sonNode \u0026lt;= Last(node); sonNode++) if notVisited(sonNode) DFS(sonNode); // 递归遍历其子树 return; //注解:for循环用于扩展node的所有未访问子结点，并依次递归 调用，其中Init表示node的第一个子结点，Last表示最后一个子结点。 BFS # 广度优先搜索 (Breadth First Search, BFS) 类似于树的按层次遍历的过程，是 另外一种通用的图和树的遍历方法。给定图𝐺 = (𝑉, 𝐸)，BFS 基本思想为\n初始化 任选一个结点𝑣作为源结点， BFS 先访问源结点𝑣，并将其标记为已访问 由近及远，按层展开 层次遍历 从𝑣出发，依次访问𝑣的邻接点:𝑤1,𝑤2,\u0026hellip;,𝑤𝑡，如果𝑤𝑖(𝑖 = 1,2,\u0026hellip;,𝑡) 未访 问过，则标记𝑤𝑖为已访问，并插入到先进先出的队列; 取出并扩展队列的头结点，把它未访问的子结点插入队列; 依此类推，直到图中所有和源结点𝑣有路径相通的结点均已访问过为止。 function BFS(problem,queue) node = Make-Node(Initial-State[problem]); queue ← Insert(node, queue); do while(1) if queue == Empty return failure node ← Remove-First(queue) visit(node); if State[node] == Goal return Solution(node) sonNodes = Expend(node, problem); queue ← Insert-All(sonNodes, queue) //依次插入所有子状态 枚举 + 优化的通用搜索 # 回溯算法 # 深度优先搜索是一种依照“能进则进，不进则退”的策略进行的枚举算法，也就 意味着它可能遍历整个状态空间图，导致算法效率不高。给定一个问题的状态空 间表示，设计搜索算法时需要考虑以下两个事实:\n并不是所有的状态都是合法状态 并不是所有的状态都能达到目标状态 回溯算法 = 深度优先搜索 + 剪枝策略\n回溯算法需要定义问题的状态空间图，包括以下四个方面:\n问题的状态表示: 一般用 k 元组表示，即𝑋 = [𝑥1, 𝑥2, ⋯ , 𝑥𝑘]，其中向量的维度，以及每一个分量的值域是状态表示的关键问题 约束条件:X 中每一个分量自身的取值约束; 分量之间的取值约束。注意: 约束条件是 剪枝策略的基础，需要深入分析和挖掘 操作符集合: 从一个状态转换到另外一个状态的操作，在状态空间图中它构成边集。 问题解和解空间: 问题的解可以认为是一类特殊的状态，即目标状态。对于问题的一个 实例，所有满足约束条件的解向量就构成该问题实例的解空间。 注意: 在回溯算法中，状态空间图并不是显式地构造，也就是说，并没有在内存中生成一个完整的状态空间图。实际上，回溯算法只是根据初始状态，目标状态和操作符集合 (它产生后续状态)，隐式地构造状态空间图。\n剪枝策略\n回溯算法需要设计合适的剪枝策略，尽量避免不必要的搜索。常用的剪枝策略包括两大类:\n约束函数剪枝: 根据约束条件，状态空间图中的部分状态可能是不合法 的。因此，在状态空间图中以不合法状态为根的子图/子树是不可能包 含可行解的，故其子空间不需要搜索。 限界函数剪枝: 这种策略一般应用于最优化问题。假设搜索算法当前访 问的状态为𝑆，且存在一个判定函数: 它能判定以𝑺为根的子图/子树不 可能包含最优解，因此该子图/子树可以剪除而无需搜索 约束函数剪枝 可以剪除状态空间图中的不可行解\n限界函数剪枝 用于剪除状态空间图中的可行但是非最优的解\nDFS 回溯算法 搜索视角 遍历整棵完全二叉树 添加剪枝策略，尽量避免不必要的搜索 枚举视角 全局判定 [𝑥1,𝑥2,⋯,𝑥n] 局部预判 [𝑥1,?,?, ⋯] [𝑥1,𝑥2,?, ⋯] 回溯算法程序框架：\n回溯算法设计通常包含以下 2 个主要步骤:\n针对所给问题，定义问题的状态空间图。 以深度优先方式搜索状态图，并用剪枝策略避免无效搜索。 void backtrack(int t) { if (t \u0026gt; n) output(x); else { for (int i = Init(n, t); i \u0026lt;= Last(n, t); i++) { x[t] = Node(i); if (constraint(x) \u0026amp;\u0026amp; bound(x)) { backtrack(t + 1); } } } 注解:for 循环体依次扩展当前结点的所有子结点，Init() 和 Last() 是一种抽象表示，返回开始子结点和末尾子结点的编号。for 循环执行完毕则回溯到父结点。\n分支限界法 # 广度优先搜索是一种依照“由近及远，按层展开”的策略进行的枚举算法，也就 意味着它需要遍历整个状态空间图，导致算法效率不高。给定一个问题的状态空 间表示，设计搜索算法时需要考虑以下两个事实：\n并不是所有的分支都包含可行解 并不是所有的分支都包含最优解 扩展子结点时，一次性生成它的 所有孩子结点，判断孩子结点是 舍弃还是保存?舍弃那些不可能 导致可行解或最优解的孩子结点， 其余的结点进入队列中\n分支限界算法 = 广度优先搜索 + 剪枝策略\n分支限界算法需要定义问题的状态空间图，包括以下四个方面:\n问题的状态表示: 逻辑上用 k 元组表示，即𝑋 = [𝑥1, 𝑥2, ⋯ , 𝑥𝑘]，其中向量的维度，以及每 一个分量的值域是状态表示的关键问题 约束条件:X 中每一个分量自身的取值约束; 分量之间的取值约束。注意: 约束条件是 剪枝策略的基础，需要深入分析和挖掘 操作符集合: 从一个状态转换到另外一个状态的操作，在状态空间图中它构成边集。 问题解和解空间: 问题的解可以认为是一类特殊的状态，即目标状态。对于问题的一个 实例，所有满足约束条件的解向量就构成该问题实例的解空间。 注意: 在分支限界算法中，状态空间图并不是显式地构造，也就是说，并没有在内存中生成一个完整的状态空间图。实际上，分支限界算法只是根据初始状态，目标状态和操作符集合 (它产生后续状态)，隐式地构造状态空间图。\n约束函数剪枝\n根据约束条件，状态空间图中的部分状态可能是不合法 的。因此，在状态空间图中以不合法状态为根的分支不包含可行解，故 其分支可以剪枝。 限界函数剪枝\n这种策略一般应用于最优化问题。假设搜索算法当前访 问的状态为𝑆，且存在一个判定函数: 它能判定以𝑺为根的分支不包含最 优解，因此该分支可以剪除而无需搜索 约束函数剪枝 可以剪除状态空间图中的不可行解\n限界函数剪枝 用于剪除状态空间图中的可行但是非最优的解\n1 BFS 分支限界算法 图搜索视角 遍历整棵完全二叉树 添加剪枝策略，尽量限制搜索无效的分支 枚举视角 全局判定 [𝑥1,𝑥2,⋯,𝑥n] 局部预判 [𝑥1,?, ?, ⋯] [𝑥1,𝑥2,?, ⋯] 分支限界算法设计通常包含以下 2 个主要步骤:\n针对所给问题，定义问题的状态空间图 以广度优先方式搜索状态空间图，并在搜索过程中用剪枝策略避免无效搜索 function BFS(problem,queue) node = Make-Node(Initial-State[problem]); queue ← Insert(node, queue); do while(1) if queue == Empty return failure node ← Remove-First(queue) visit(node); if State[node] == Goal return Solution(node) while(sonNode = Next(problem,node)!=NULL){ if(constraint(sonNode) \u0026amp;\u0026amp; bound(sonNode)){ Insert(queue,sonNode); } } 启发式搜索 # 最佳优先搜索 # 最佳优先搜索\n挖掘每一个状态描述估计其“启发值”，评估状态逼近目标状态的优势\n设计评估函数 f(N)，估计状态 N 的启发值 (一般为实数)，既有 f(N) \u0026gt;= 0 一般的， f(N) 估计结点的成本， f(N) 越小，结点 N 更有利于逼近目标状态\n最佳优先搜索则按照结点的评估值 f(N) 进行升序排列，优先扩展评估值比较小的结点如果多个结点的启发值 f(N) 相同，则这些结点随机排列\n“最佳”不代表当前搜索路径是最优的\n“最佳优先搜索”不一定能产生最优路径\n评估函数设计\n评估函数 f(N) 的两种常见设计策略: 经过结点 N 的路径的成本 f(N) = g(N) + h(N), 要求: g(N) 表示从初始状态到状态 N 的成本 h(N) 表示从状态 N 到目标状态的成本估计 从状态 N 到目标状态的成本 f(N) = h(N) → 贪心策略 理论上评估函数可以是任何值域为正数的函数 f(N)，但是不见得所有 函数对于搜索算法有帮助。 BestFirstSearch() { Open = [起始结点]; Closed = []; while (Open表非空) { 从Open中取得一个结点X, 并从OPEN表中删除.if (X是目标结点) { 求得路径PATH; } for (每一个X的合法子结点Y) { if (Y不在OPEN表和CLOSED表中) 求Y的估价值 f(Y); 并将Y插入OPEN表中; // 还没有排序 else if( Y在OPEN表中 ) if (Y的估价值小于OPEN表的估价值) 更新OPEN表中的估价值; else { // Y在CLOSED表中 if (Y的估价值小于CLOSED表的估价值) 更新CLOSED表中的估价值; 从CLOSED表中移出结点, 并放入OPEN表中; } // end for 将X结点插入CLOSED表中; 按照估价值将OPEN表中的结点排序; } // end while } //end func OPEN 表用来存放活结点表，一 般用优先队列实现; CLOSE 表保存已扩展结点，它 用于求解最优路径，用线性表 实现; 如果问题不需要求解最优路径， 而只需要最优值时，CLOSE 表可以省略。 启发式搜索\n选择下一个扩展结点的策略总是选择评估函数 𝑓(∙) 值最 小的状态结点作为新扩展结点。\n$$f (n) = g(n) + h(n)$$\nBFS 与分支限界法 如果𝑔(𝑛) 表示结点𝑛在解空间树中的深度, h(𝑛) = 0 DFS 与回溯法 如果𝑔(𝑛) = 0，h(𝑛) 的定义满足:m 是 n 的儿子结点，则 h(𝑚) \u0026lt; h(𝑛) A* 算法 满足 h(𝑛) ≤ h∗(𝑛) ，其中 h∗(𝑛) 表示结点𝑛到目标结点的最佳路径成本 A* 算法 # 启发式搜索选择下一个扩展结点的策略总是选择评估函数 𝑓(∙) 值最小的状态结 点作为新扩展结点。\n$$f (n) = g(n) + h(n)$$\n如果𝒈(𝒏) 表示从初始状态到状态 N 的成本，𝒉(𝒏) 表示从状态 N 到目标状态的成本估计，𝒉∗(𝑵) 是从状态结点 N 到目标状态的最优路径成本，满足: $$𝟎 ≤ 𝒉(𝑵) ≤ 𝒉∗(𝑵)，𝒘(𝑁,𝑁’) ≥𝜖\u0026gt; 0$$ 其中𝑤(𝑁, 𝑁’) 表示任何两个状态之间的路径成本，要求大于 0。则最佳优先搜索得到 的解总是最优解，对应搜索算法称之为 A* 算法。 如果 N 是目标状态 G，则定义𝐻(𝐺) = 0。\nA 算法的最优性证明*\n【可采纳性定理】如果问题生成的状态空间图 G 和 h(𝑛) 满足稳定条件，即: 1 图中的每个结点的后继结点是有限的; 2 图中的弧的代价都大于某个正数𝜺 ; 3 对图中的所有结点𝑛，满足 h(𝑛) ≤ h∗(𝑛) ，即估计成本不会超过实际成本。 并且状态空间图中存在一条从开始状态结点𝑠到目标状态结点𝑔的有限代价的路径， 那么 A算法总是在𝒔到𝒈的最佳路径上停止搜索，也称之为 A算法是可采纳的。 证明思路 Step1: 如果问题存在可行解，则 A* 算法终止且返回可行解 Step2: 当 A* 算法扩展到目标状态 g 时，则其扩展路径对应最优解 对抗搜索 # 小结 # 搜索算法的基本原理\n问题表示的状态空间图 状态表示 操作集合 路径/路径耗散函数 在状态空间图中搜索从初 始状态到目标状态的路径/ 最优路径。 常用的搜索策略\n基于枚举的通用搜索 深度优先搜索 广度优先搜索 基于“枚举 + 优化”的通用搜索 回溯算法 分支限界法 基于规则的启发式搜索 最佳优先搜索 A* 算法 e.g.s # 传教士问题 # 在河的左岸有三个传教士、一条船和三个野人，传教士们想用这条船将所有的成员都运 过河去，但是受到以下条件的限制: 1 教士和野人都会划船，但船一次最多只能装运两个; 2 在任何岸边野人数目都不得超过传教士，否则传教士会遭遇危险:被野人攻击甚至吃掉。 此外，假定野人会服从任何一种过河安排，试设计出一个确保全部成员安全过河的计划。 状态表示 确定问题的状态表示，以及每一个状态变量的值域。 渡河问题包括三类对象: 传教士，野人和渡船，得三元组𝑺 =(𝒎,𝒄,𝒃)，其中: m 为左岸传教士数，有𝑚 ={0,1,2,3}; 对应右岸的传教士数为 3-𝑚。 c 为左岸的野人数，有𝑐 ={0,1,2,3}; 对应右岸野人数为 3-𝑐。 b 为左岸渡船数，有𝑏 = {0, 1}，右岸的船数为 1 − 𝑏。 初始状态只有一个，即𝑆0 =(3,3,1)，表示全部成员在河的左岸; 目标状态也只一 个，即 𝑆𝑔 =(0,0,0)，表示全部成员从河左岸渡河完毕。 操作符集合 把船从左岸划向右岸定义为𝐿𝑖𝑗操作，第一下标𝑖表示船载的传教士数, 第二下标𝑗表示船载 的野人数。 从右岸将船划回左岸称之为𝑅𝑖𝑗操作，下标的定义同前。 ➢ 则共有 10 种操作，操作集为 F={L01，L10，L11，L02，L20，R01，R10，R11，R02，R20} 状态表示: 𝑺 = (𝒎, 𝒄, 𝒃) 初始状态𝑆0 =(3,3,1)，目标状态𝑆𝑔 =(0,0,0) 操作符集合 F = {L01，L10，L11，L02，L20，R01，R10，R11，R02，R20} 8 数码问题 # 把左图的 8 数码排列通过空格的 上下左右移动，转换为右图的 8 数码排列\n状态表示 数字格与空格组成的排列 操作符集合 空格向上、下、左和右移动 路径耗散函数 每一次移动代价为 1，路径耗散等于移 动次数 背包问题 # 【例-1】对于 𝑛 = 3 的0-1背包问题，其中背包容量𝑐 = 30，每个物品的重 量和价值分别为:𝑤 =\u0026lt; 16,15,15 \u0026gt;, 𝑝 =\u0026lt; 45,25,25 \u0026gt;。 旅行商问题 # 【例-2】某商人要到若干城市去推销商品，已知各城市之间的旅行费用，他要 选定一条从驻地出发，经过每个城市一遍，最后回到驻地的路线，使总的费用 最少。试构造下图对应问题实例的最优旅行方案。 装载问题 # 问题描述:有n个集装箱要装上2艘载重量分别为C1和C2的轮船，其中集装箱 i 的重量为Wi， 且 ∑ Wi ≤C1+C2。请设计算法确定是否有一个合理的装载方案可将这些集装箱上这2艘轮 船。 输入:多组测试数据。每组测试数据包括两行:第一行输入集装箱数目n(n\u0026lt;1000)， 以及两艘轮船的载重C1和C2;第二行输入n个整数，表示每个集装箱的重量。 输出:如果存在合理装载方案，输出第一艘轮船的最大装载重量;否则，输出“No”。 把原问题简化为一艘轮船的装载问题。容易证明下述 结论: 如果一个给定装载问题实例有解，则采用下面 的策略可得到最优装载方案: (1) 首先将第一艘轮船尽可能装满; (2) 将剩余的集装箱装上第二艘轮船。\n#define MaxBox 1000 int globalWeight[MaxBox], globalNum, globalC1; // 输入参数 int globalX[MaxBox], globalAns; // 保存状态X和最优值的全局变量 void loadingDFS(int t) { if (t == globalNum) { // 边界条件，判定一个n维-1向量是否是可行解 int // sumWeight1=0; for (int i = 0; i \u0026lt; globalNum; i++) { sumWeight1 += globalX[i] * globalWeight[i]; } // 计算装载量 if ((sumWeight1 \u0026lt;= globalC1) \u0026amp;\u0026amp; sumWeight1 \u0026gt; globalAns) { globalAns = sumWeight1; } return; } // end of if globalX[t] = 1; loadingDFS(t+1); //扩展左子树 globalX[t] = 0; loadingDFS(t+1); //扩展右子树 } DFS- 回溯算法 # 约束函数剪枝 # 限界函数剪枝 # #define MaxBox 1000 int globalWeight[MaxBox], globalNum, globalC1; int globalX[MaxBox]; int globalWt, globalBd, globalMaxWt; void loadingBacktrack(int t) { if (t == globalNum) { globalMaxWt = globalWt; return; } // end of if globalBd -= globalWeight[t]; if (globalWt + globalWeight[t] \u0026lt;= globalC1) { globalX[t] = 1; globalWt += globalWeight[t]; loadingBacktrack(t + 1); globalWt -= globalWeight[t]; } if (globalWt + globalBd \u0026gt; globalMaxWt) { globalX[t] = 0; loadingBacktrack(t + 1); } globalBd += globalWeight[t]; } BFS- 分支限界算法 # 约束函数剪枝 # 限界函数剪枝 # A* 算法 # "},{"id":18,"href":"/others/about_me/","title":"About Me","section":"Others","content":" About Me # "},{"id":19,"href":"/others/projects/","title":"Projects","section":"Others","content":" Projects # "}]