<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>O5-IO系统 | Caesar's Paperbox</title><meta name=keywords content="Learning,Notes,OS"><meta name=description content="Intro 除了提供抽象（例如，进程、地址空间和文件）以外，操作系统还要控制计算机的所有 I/O(输入输出) 设备。操作系统必须向设备发送命令，捕捉中断，并处理设备的各种错误。
它还应该在设备和系统的其他部分之间提供简单且易于使用的接口。如果有可能，这个接口对于所有设备都应该是相同的，这就是所谓的设备无关性。
I/O 部分的代码是整个操作系统的重要组成部分。操作系统如何管理 I/O 是本章的主题。
5.输入输出(I/O)管理 （1）I/O 管理概述 1）I/O 控制方式 2）I/O 软件层次结构 （2）I/O 核心子系统 1）I/O 调度概念 2）高速缓存与缓冲区 3）设备分配与回收 4）假脱机技术(SPOOLing) I/O 硬件原理 不同的人对于 IO 硬件的理解是不同的。对于电子工程师而言，I/O 硬件就是芯片、导线、电源、电机和其他组成硬件的物理部件。
对程序员而言，则只注意 I/O 硬件提供给软件的接口，如硬件能够接收的命令、它能够实现的功能以及它能够报告的错误。
I/O 设备 IO 设备可以大致分为两类：块设备（Block device）和字符设备（character device）
块设备 把信息存储在固定大小的块中，每个块有自己的地址 所有的传输都是以一个或多个完整的（连续的）块为单位 块设备的基本特征就是每个块都能独立于其他块而读写。 硬盘、蓝光光盘和 USB 盘是最常见的设备 主要概念中的 I/O 系统分类方式：
计算机系统中的 I/O 设备按使用特性可分为以下类型： 人机交互类外部设备：用于同计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。 存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。 网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。网络通信设备在使用和管理上与前两类设备也有很大不同。 IO 设备还可以按以下方式分类：
按传输速度分类
低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。 中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、 激光打印机等。 高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、 光盘机等。 按信息交换的单位分类
块设备：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块。 字符设备：用于数据输入/输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入/输出时常釆用中断驱动方式。 设备控制器 I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。
电子部件称作设备控制器(device controller)或适配器(adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入(PCI)扩展槽中的印刷电路板的形式出现。"><meta name=author content="CaesarYang"><link rel=canonical href=/post/tech/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/o5-io%E7%B3%BB%E7%BB%9F/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.d0947ecfa67e4e172f8a6c5415fa13349ff99ea5ebe6949dcdd38ab29bb25783.css integrity="sha256-0JR+z6Z+ThcvimxUFfoTNJ/5nqXr5pSdzdOKspuyV4M=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="O5-IO系统"><meta property="og:description" content="Intro 除了提供抽象（例如，进程、地址空间和文件）以外，操作系统还要控制计算机的所有 I/O(输入输出) 设备。操作系统必须向设备发送命令，捕捉中断，并处理设备的各种错误。
它还应该在设备和系统的其他部分之间提供简单且易于使用的接口。如果有可能，这个接口对于所有设备都应该是相同的，这就是所谓的设备无关性。
I/O 部分的代码是整个操作系统的重要组成部分。操作系统如何管理 I/O 是本章的主题。
5.输入输出(I/O)管理 （1）I/O 管理概述 1）I/O 控制方式 2）I/O 软件层次结构 （2）I/O 核心子系统 1）I/O 调度概念 2）高速缓存与缓冲区 3）设备分配与回收 4）假脱机技术(SPOOLing) I/O 硬件原理 不同的人对于 IO 硬件的理解是不同的。对于电子工程师而言，I/O 硬件就是芯片、导线、电源、电机和其他组成硬件的物理部件。
对程序员而言，则只注意 I/O 硬件提供给软件的接口，如硬件能够接收的命令、它能够实现的功能以及它能够报告的错误。
I/O 设备 IO 设备可以大致分为两类：块设备（Block device）和字符设备（character device）
块设备 把信息存储在固定大小的块中，每个块有自己的地址 所有的传输都是以一个或多个完整的（连续的）块为单位 块设备的基本特征就是每个块都能独立于其他块而读写。 硬盘、蓝光光盘和 USB 盘是最常见的设备 主要概念中的 I/O 系统分类方式：
计算机系统中的 I/O 设备按使用特性可分为以下类型： 人机交互类外部设备：用于同计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。 存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。 网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。网络通信设备在使用和管理上与前两类设备也有很大不同。 IO 设备还可以按以下方式分类：
按传输速度分类
低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。 中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、 激光打印机等。 高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、 光盘机等。 按信息交换的单位分类
块设备：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块。 字符设备：用于数据输入/输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入/输出时常釆用中断驱动方式。 设备控制器 I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。
电子部件称作设备控制器(device controller)或适配器(adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入(PCI)扩展槽中的印刷电路板的形式出现。"><meta property="og:type" content="article"><meta property="og:url" content="/post/tech/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/o5-io%E7%B3%BB%E7%BB%9F/"><meta property="og:image" content="/avatar.jpeg"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-05-06T11:40:58+08:00"><meta property="article:modified_time" content="2022-05-06T11:40:58+08:00"><meta property="og:site_name" content="Caesars Paperbox"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/avatar.jpeg"><meta name=twitter:title content="O5-IO系统"><meta name=twitter:description content="Intro 除了提供抽象（例如，进程、地址空间和文件）以外，操作系统还要控制计算机的所有 I/O(输入输出) 设备。操作系统必须向设备发送命令，捕捉中断，并处理设备的各种错误。
它还应该在设备和系统的其他部分之间提供简单且易于使用的接口。如果有可能，这个接口对于所有设备都应该是相同的，这就是所谓的设备无关性。
I/O 部分的代码是整个操作系统的重要组成部分。操作系统如何管理 I/O 是本章的主题。
5.输入输出(I/O)管理 （1）I/O 管理概述 1）I/O 控制方式 2）I/O 软件层次结构 （2）I/O 核心子系统 1）I/O 调度概念 2）高速缓存与缓冲区 3）设备分配与回收 4）假脱机技术(SPOOLing) I/O 硬件原理 不同的人对于 IO 硬件的理解是不同的。对于电子工程师而言，I/O 硬件就是芯片、导线、电源、电机和其他组成硬件的物理部件。
对程序员而言，则只注意 I/O 硬件提供给软件的接口，如硬件能够接收的命令、它能够实现的功能以及它能够报告的错误。
I/O 设备 IO 设备可以大致分为两类：块设备（Block device）和字符设备（character device）
块设备 把信息存储在固定大小的块中，每个块有自己的地址 所有的传输都是以一个或多个完整的（连续的）块为单位 块设备的基本特征就是每个块都能独立于其他块而读写。 硬盘、蓝光光盘和 USB 盘是最常见的设备 主要概念中的 I/O 系统分类方式：
计算机系统中的 I/O 设备按使用特性可分为以下类型： 人机交互类外部设备：用于同计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。 存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。 网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。网络通信设备在使用和管理上与前两类设备也有很大不同。 IO 设备还可以按以下方式分类：
按传输速度分类
低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。 中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、 激光打印机等。 高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、 光盘机等。 按信息交换的单位分类
块设备：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块。 字符设备：用于数据输入/输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入/输出时常釆用中断驱动方式。 设备控制器 I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。
电子部件称作设备控制器(device controller)或适配器(adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入(PCI)扩展槽中的印刷电路板的形式出现。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Articles","item":"/post/"},{"@type":"ListItem","position":3,"name":"Tech","item":"/post/tech/"},{"@type":"ListItem","position":5,"name":"O5-IO系统","item":"/post/tech/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/o5-io%E7%B3%BB%E7%BB%9F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"O5-IO系统","name":"O5-IO系统","description":"Intro 除了提供抽象（例如，进程、地址空间和文件）以外，操作系统还要控制计算机的所有 I/O(输入输出) 设备。操作系统必须向设备发送命令，捕捉中断，并处理设备的各种错误。\n它还应该在设备和系统的其他部分之间提供简单且易于使用的接口。如果有可能，这个接口对于所有设备都应该是相同的，这就是所谓的设备无关性。\nI/O 部分的代码是整个操作系统的重要组成部分。操作系统如何管理 I/O 是本章的主题。\n5.输入输出(I/O)管理 （1）I/O 管理概述 1）I/O 控制方式 2）I/O 软件层次结构 （2）I/O 核心子系统 1）I/O 调度概念 2）高速缓存与缓冲区 3）设备分配与回收 4）假脱机技术(SPOOLing) I/O 硬件原理 不同的人对于 IO 硬件的理解是不同的。对于电子工程师而言，I/O 硬件就是芯片、导线、电源、电机和其他组成硬件的物理部件。\n对程序员而言，则只注意 I/O 硬件提供给软件的接口，如硬件能够接收的命令、它能够实现的功能以及它能够报告的错误。\nI/O 设备 IO 设备可以大致分为两类：块设备（Block device）和字符设备（character device）\n块设备 把信息存储在固定大小的块中，每个块有自己的地址 所有的传输都是以一个或多个完整的（连续的）块为单位 块设备的基本特征就是每个块都能独立于其他块而读写。 硬盘、蓝光光盘和 USB 盘是最常见的设备 主要概念中的 I/O 系统分类方式：\n计算机系统中的 I/O 设备按使用特性可分为以下类型： 人机交互类外部设备：用于同计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。 存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。 网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。网络通信设备在使用和管理上与前两类设备也有很大不同。 IO 设备还可以按以下方式分类：\n按传输速度分类\n低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。 中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、 激光打印机等。 高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、 光盘机等。 按信息交换的单位分类\n块设备：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块。 字符设备：用于数据输入/输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入/输出时常釆用中断驱动方式。 设备控制器 I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。\n电子部件称作设备控制器(device controller)或适配器(adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入(PCI)扩展槽中的印刷电路板的形式出现。","keywords":["Learning","Notes","OS"],"articleBody":"Intro 除了提供抽象（例如，进程、地址空间和文件）以外，操作系统还要控制计算机的所有 I/O(输入输出) 设备。操作系统必须向设备发送命令，捕捉中断，并处理设备的各种错误。\n它还应该在设备和系统的其他部分之间提供简单且易于使用的接口。如果有可能，这个接口对于所有设备都应该是相同的，这就是所谓的设备无关性。\nI/O 部分的代码是整个操作系统的重要组成部分。操作系统如何管理 I/O 是本章的主题。\n5.输入输出(I/O)管理 （1）I/O 管理概述 1）I/O 控制方式 2）I/O 软件层次结构 （2）I/O 核心子系统 1）I/O 调度概念 2）高速缓存与缓冲区 3）设备分配与回收 4）假脱机技术(SPOOLing) I/O 硬件原理 不同的人对于 IO 硬件的理解是不同的。对于电子工程师而言，I/O 硬件就是芯片、导线、电源、电机和其他组成硬件的物理部件。\n对程序员而言，则只注意 I/O 硬件提供给软件的接口，如硬件能够接收的命令、它能够实现的功能以及它能够报告的错误。\nI/O 设备 IO 设备可以大致分为两类：块设备（Block device）和字符设备（character device）\n块设备 把信息存储在固定大小的块中，每个块有自己的地址 所有的传输都是以一个或多个完整的（连续的）块为单位 块设备的基本特征就是每个块都能独立于其他块而读写。 硬盘、蓝光光盘和 USB 盘是最常见的设备 主要概念中的 I/O 系统分类方式：\n计算机系统中的 I/O 设备按使用特性可分为以下类型： 人机交互类外部设备：用于同计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。 存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。 网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。网络通信设备在使用和管理上与前两类设备也有很大不同。 IO 设备还可以按以下方式分类：\n按传输速度分类\n低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。 中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、 激光打印机等。 高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、 光盘机等。 按信息交换的单位分类\n块设备：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块。 字符设备：用于数据输入/输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入/输出时常釆用中断驱动方式。 设备控制器 I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。\n电子部件称作设备控制器(device controller)或适配器(adapter)。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入(PCI)扩展槽中的印刷电路板的形式出现。\n机械部件则是设备本身。\n设备控制器通过寄存器与 CPU 通信，在某些计算机上，这些寄存器占用内存地址的一部分，称为内存映像 I/O；另一些计算机则釆用 I/O 专用地址，寄存器独立编址。操作系统通过向控制器寄存器写命令字来执行 I/O 功能。控制器收到一条命令后，CPU 可以转向进行其他工作，而让设备控制器自行完成具体的 I/O 操作。当命令执行完毕后，控制器发出一个中断信号，操作系统重新获得 CPU 的控制权并检查执行结果，此时，CPU 仍旧是从控制器寄存器中读取信息来获得执行结果和设备的状态信息。\n控制器的任务\n把串行的位流转换为字节块，并进行必要的错误矫正工作 字节块通常首先在控制器内部的一个缓冲区中按位进行组装，然后再对校验和进行校验并证明字节块没有错误后，再将其复制到主存中 设备控制器的功能\n接收和识别 CPU 或通道发来的命令，如磁盘控制器能接收读、写、查找等命令。 实现数据交换，包括设备和控制器之间的数据传输；通过数据总线或通道，控制器和主存之间的数据传输。 发现和记录设备及自身的状态信息，供 CPU 处理使用。 设备地址识别。 为实现上述功能，设备控制器必须包含以下组成部分：\n设备控制器与 CPU 的接口。 该接口有三类信号线：数据线、地址线和控制线。数据线通常与两类寄存器相连接：数据寄存器（存放从设备送来的输入数据或从 CPU 送来的输出数据）和控制/状态寄存器（存放从 CPU 送来的控制信息或设备的状态信息)。 设备控制器与设备的接口。设备控制器连接设备需要相应数量的接口，一个接口连接一台设备。每个接口中都存在数据、控制和状态三种类型的信号。 I/O 控制逻辑。用于实现对设备的控制。它通过一组控制线与 CPU 交互，对从 CPU 收到的 I/O 命令进行译码。CPU 启动设备时，将启动命令发送给控制器，同时通过地:址线把地址发送给控制器，由控制器的 I/O 逻辑对地址进行译码，并相应地对所选设备进行控制。 内存映射 I/O 每个控制器有几个寄存器用来与 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。\n除了这些控制寄存器以外,许多设备还有一个操作系统可以读写的数据缓冲区。\n可供程序或 OS 写入数据 Q：CPU 如何与设备的控制寄存器和数据缓冲区进行通信？\n第一种方法：单独的 IO 和内存空间。 每个控制寄存器被分配一个 IO 端口号。所有 IO 端口形成 IO 端口空间，并且受到保护使得普通的用户程序不能对其进行访问（只用 OS 可以访问） 在这一种方法中，内存地址空间和 IO 地址空间是不同的 第二种方法：内存映射 I/O 将所有控制寄存器映射到内存空间中。每个控制寄存器被分配唯一的一个内存地址，并且不会有内存被分配这一地址。 大多数系统中，分配给控制寄存器的地址位于或者靠近地址空间的顶端 第三种方法：混合方式。这一方案具有内存映射 IO 的数据缓冲区，而控制寄存器则有单独的 IO 端口。x86 采用这一体系结构 工作实例：\n在各种情形下，当 CPU 想要读入一个字的时候，不论是从内存中读入还是从/O 端口中读入，它都要将需要的地址放到总线的地址线上，然后在总线的一条控制线上置起一个 READ 信号。还要用到第二条信号线来表明需要的是 I/O 空间还是内存空间。如果是内存空间，内存将响应请求。如果是 I/O 空间，I/O 设备将响应请求。如果只有内存空间（如图 5-2b 所示的情形），那么每个内存模块和每个 I/O 设备都会将地址线和它所服务的地址范围进行比较，如果地址落在这一范围之内， 它就会响应请求。因为绝对不会有地址既分配给内存又分配给 I/O 设备，所以不会存在歧义和冲突。\n内存映射 I/O 的优点： 设备驱动程序代码简便且一致 设备控制器只是内存中的变量，在 C 语言中可以和任何其他变量一起寻址。 因此，对于内存映射 IO，IO 设备驱动程序完全可以用 C 语言编写。 如果不使用内存映射 IO，需要用到某些汇编代码 不需要特殊的保护机制来阻止用户进程执行 I/O 操作 操作系统必须要做的全部事情只是避免把包含控制寄存器的那部分地址空间放入任何用户的虚拟地址空间之中。 更为有利的是，如果每个设备在地址空间的不同页面上拥有自己的控制寄存器，操作系统只要简单地通过在其页表中包含期望的页面就可以让用户控制特定的设备而不是其他设备。 这样的方案可以使不同的设备驱动程序放置在不同的地址空间中，不但可以减小内核的大小，而且可以防止驱动程序之间相互干扰。 可以引用内存的每一条指令也可以引用控制寄存器 缺点： 硬件必须能够针对每个页面有选择地禁用高速缓存，为硬件和 OS 同时增加了复杂性 在内存映射的机器上具有单独的内存总线的麻烦是 I/O 设备没有办法查看内存地址,因为内存地址旁路到内存总线上,所以没有办法响应。 直接存储器存取-DMA 无论一个 CPU 是否具有内存映射 I/O,它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这样做浪费 CPU 的时间，所以经常用到一种称为直接存储器存取(Direct Memory Access,DMA) 的不同方案。\n只有硬件具有 DMA 控制器时操作系统才能使用 DMA, 而大多数系统都有 DMA 控制器。\n有时 DMA 控制器集成到磁盘控制器和其他控制器之中，但是这样的设计要求每个设备有一个单独的 DMA 控制器。 更加普遍的是，只有一个 DMA 控制器可利用（例如，在主板上)，由它调控到多个设备的数据传送，而这些数据传送经常是同时发生的。 无论 DMA 控制器在物理上处于什么地方,它都能够独立于 CPU 而访问系统总线。\n没有使用 DMA 情况的工作原理：\n首先,控制器从磁盘驱动器串行地、一位一位地读一个块(一个或多个扇区),直到将整块信息放入控制器的内部缓冲区中。 接着,它计算校验和,以保证没有读错误发生。 然后控制器产生一个中断。——转到 OS 内部运行的开始 当操作系统开始运行时,它重复地从控制器的缓冲区中一次一个字节或一个字地读取该块的信息,并将其存入内存中。 使用 DMA 控制器的工作过程：\n首先,CPU 通过设置 DMA 控制器的寄存器对它进行编程,所以 DMA 控制器知道将什么数据传送到什么地方(图 5-4 中的第 1 步 ) 。 DMA 控制器还要向磁盘控制器发出一个命令,通知它从磁盘读数据到其内部的缓冲区中,并且对校验和进行枪验。 如果磁盘控制器的缓冲区中的数据是有效的,那么 DMA 就可以开始了。 DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送(第 2 步)。 这一读请求看起来与任何其他读请求是一样的、并且磁盘控制器井不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。 一般情况下,要写的内存地址在总线的地址线上,所以当磁盘控制器从其内部缓冲区中读取下一个字的时候,它知道将该字写到什么地方。 写到内存是另一个标淮总线周期(第 3 步)。 当写操作完成时,磁盘控制器在总线上发出一个应答信号到 DMA 控制器(第 4 步)。 于是,DMA 控制器步增要使用的内存地址,井且步减字节计数。 如果字节计数仍然大于 0 ,则重复第 2 步到第 4 步,直到字节计数到达 0。 此时,DMA 控制器将中断 CPU 以便让 CPU 知道传送现在已经完成了。 当操作系统开始工作时,用不着将磁盘块复制到内存中,因为它已经在内存中了。 Q：为什么控制器从磁盘读取字节后不立即将其存储在主存中？为什么需要一个内部缓冲区？\n1:通过内部缓冲，磁盘控制器可以在开始传送前计算校验和 2:一旦磁盘传送开始工作，从磁盘读出的数据就是以固定速率到达的，而不论控制器是否做好准备接收数据。 如果控制器直接将其写入内存，则它必须要为传送的每个字取得系统总线的控制权。 此时，若由于其他设备使用总线而导致总线忙，则控制器只能等待。 而如果设计内部缓冲区，则控制器的设计可以简化，因为对 DMA 到内存的传送没有严格的时间要求 更多细节内容\n周期窃取 cycle stealing\nDMA 控制器请求传送一个字并且得到这个字。如果 CPU 也想使用总线,它必须等待。 这一机制称为周期窃取( cycle stealing ) , 因为设备控制器偶尔偷偷溜入并且从 CPU 偷走一个临时的总线周期,从而轻微地延迟 CPU。 突发模式 burst mode\n在块模式中，DMA 控制器通知涉笔获得总线，发起一连串的传送，然后释放总线 它比周期窃取效率更高，因为获得总线占用了时间，并且一次总线获得的代价能够传送多个字 突发模式的缺点是，如果正在进行的是长时间传送，有可能将 CPU 和其他设备阻塞相当长的周期 中断 在硬件层面，中断的工作如下所述：当一个 I/O 设备完成交给它的工作时，它就产生一个中断（假设操作系统已经开放中断），它是通过在分配给它的一条总线信号线上置起信号而产生中断的。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么。\n中断处理方式详细内容梳理：\n如果没有其他中断悬而未决，中断控制器将立刻对中断进行处理。\n如果有另一个中断正在处理中， 或者另一个设备在总线上具有更高优先级的一条中断请求线上同时发出中断请求，该设备将暂时不被理睬。 在这种情况下，该设备将继续在总线上置起中断信号，直到得到 CPU 的服务。 为了处理中断，中断控制器在地址线上放置一个数字表明哪个设备需要关注，并且置起一个中断 CPU 的信号。\n中断信号导致 CPU 停止当前正在做的工作并且开始做其他的事情。地址线上的数字被用做指向一个称为中断向量(interrupt vector) 的表格的索引，以便读取一个新的程序计数器。这一程序计数器指向相应的中断服务过程的开始。\n一般情况下，陷阱和中断从这一点上看使用相同的机制，并且常常共享相同的中断向量。中断向量的位置可以硬布线到机器中，也可以在内存中的任何地方通过一个 CPU 寄存器(由操作系统装载)指向其起点。 中断服务过程开始运行后，它立刻通过将一个确定的值写到中断控制器的某个 I/O 端口来对中断做出应答。\n这一应答告诉中断控制器可以自由地发出另一个中断。通过让 CPU 延迟这一应答直到它准备好处理下一个中断，就可以避免与多个几乎同时发生的中断相牵涉的竞争状态。 中断时上下文等关键寄存器信息的保存：\n一种选择是将其放入内部寄存器中，在需要时操作系统可以读出这些内部寄存器。这一方法的问题是，中断控制器之后无法得到应答，直到所有可能的相关信息被读出，以免第二个中断重写内部寄存器保存状态。这一策略在中断被禁止时将导致长时间的死机，并且可能丢失中断和丢失数据。 因此，大多数 CPU 在堆栈中保存信息。然而，这种方法也有问题。首先，使用谁的堆栈？如果使用当前堆栈，则它很可能是用户进程的堆栈。堆栈指针甚至可能不是合法的，这样当硬件试图在它所指的地址处写某些字时，将导致致命错误。此外，它可能指向一个页面的末端。若干次内存写之后，页面边界可能被超出并且产生一个页面故障。在硬件中断处理期间如果发生页面故障将引起更大的问题：在何处保存状态以处理页面故障？ 精确中断\n将机器留在一个明确状态的中断 四个重要特征： 1)PC(程序计数器)保存在一个已知的地方。 2)PC 所指向的指令之前的所有指令已经完全执行。 3)PC 所指向的指令之后的所有指令都没有执行。 4)PC 所指向的指令的执行状态是已知的。 I/O 软件原理 I/O 软件的目标 在设计 I/O 软件时一个关键的概念是设备独立性(device independence)。 它的意思是应该能够编写出这样的程序：它可以访问任意/O 设备而无需事先指定设备。\n例如，读取一个文件作为输入的程序应该能够在硬盘、DVD 或者 USB 盘上读取文件，无需为每一种不同的设备修改程序。\n设备独立性 统一命名 用这种方法,所有文件和设备都采用相同的方式一路径名进行寻址。 错误处理 一般来说，错误应该尽可能地在接近硬件的层面得到处理。当控制器发现了一个读错误时，如果它能够处理那么就应该自己设法纠正这一错误。 如果控制器处理不了，那么设备驱动程序应当予以处理，可能只需重读一次这块数据就正确了。很多错误是偶然性的 只有在低层软件处理不了的情况下，才将错误上交高层处理。在许多情况下，错误恢复可以在低层透明地得到解决，而高层软件甚至不知道存在这一错误。 同步和异步传输 同步即阻塞 异步即中断驱动 缓冲 buffering 数据离开一个设备之后通常并不能直接存放到其最终的目的地。 缓冲涉及到大量的工作，并且经常对 I/O 性能有重大影响 I/O 控制方式 三种最主要的 I/O 控制方式：\n程序直接控制 I/O I/O 的最简单形式是让 CPU 做全部工作，这一方法称为程序控制 I/O(programmed I/O)\n操作系统的主要操作：\n首先，数据被复制到内核空间。然后，操作系统进入一个密闭的循环，一次输出一个字符。 输出一个字符之后，CPU 要不断地查询设备以了解它是否就绪准备接收另一个字符。这一行为经常称为轮询(polling)或忙等待(busy waiting)。 程序控制 I/O 的缺点\n直到全部 I/O 完成之前要占用 CPU 的全部时间。 如果“打印一个字符的时间非常短（因为打印机所做的全部事情就是将新的字符复制到一个内部缓冲区中），那么忙等待还是不错的。此外，在嵌入式系统中，CPU 没有其他事情要做，忙等待也是合理的。 然而，在更加复杂的系统中，CPU 有其他工作要做，忙等待将是低效的，需要更好的 IO 方法。 程序直接控制方式虽然简单易于实现，但是其缺点也是显而易见的，由于 cpu 和 I/O 设备只能串行工作，导致 CPU 的利用率相当低。\n中断驱动方式 I/O 这种允许 CPU 在等待打印机变为就绪的同时做某些其他事情的方式就是使用中断。\n中断驱动方式的思想：\n允许 I/O 设备主动打断 CPU 的运行并请求服务，从而“解放”CPU，使得其向 I/O 控制器发送读命令后可以继续做其他有用的工作。 从 I/O 控制器的角度来看：\nI/O 控制器从 CPU 接收一个读命令，然后从外围设备读数据。 一旦数据读入到该 I/O 控制器的数据寄存器，便通过控制线给 CPU 发出一个中断信号，表示数据已准备好，然后等待 CPU 请求该数据。 I/O 控制器收到 CPU 发出的取数据请求后，将数据放到数据总线上，传到 CPU 的寄存器中。 至此，本次 I/O 操作完成，I/O 控制器又可开始下一次 I/O 操作。 从 CPU 的角度来看：\nCPU 发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），转去执行其他程序。 在每个指令周期的末尾，CPU 检查中断。 当有来自 I/O 控制器的中断时，CPU 保存当前正在运行程序的上下文，转去执行中断处理程序处理该中断。这时，CPU 从 I/O 控制器读一个字的数据传送到寄存器，并存入主存。 接着， CPU 恢复发出 I/O 命令的程序（或其他程序）的上下文，然后继续运行。 DMA 方式 I/O 在中断驱动方式中，I/O 设备与内存之间的数据交换必须要经过 CPU 中的寄存器，所以速度还是受限，而 DMA（直接存储器存取）方式的基本思想是在 I/O 设备和内存之间开辟直接的数据交换通路，彻底“解放” CPU。\nDMA 方式的特点是： 基本单位是数据块。 所传送的数据，是从设备直接送入内存的，或者相反。 仅在传送一个或多个数据块的开始和结束时，才需 CPU 干预，整块数据的传送是在 DMA 控制器的控制下完成的。 DMA 控制器的组成：\n为了实现在主机与控制器之间成块数据的直接交换，必须在 DMA 控制器中设置如下四类寄存器： 命令/状态寄存器(CR)：用于接收从 CPU 发来的 I/O 命令或有关控制信息，或设备的状态。 内存地址寄存器(MAR)：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。 数据寄存器(DR)：用于暂存从设备到内存，或从内存到设备的数据。 数据计数器(DC)：存放本次 CPU 要读或写的字（节）数。 DMA 的工作过程：\nCPU 读写数据时，它给 I/O 控制器发出一条命令，启动 DMA 控制器，然后继续其他工作。 之后 CPU 就把控制操作委托给 DMA 控制器，由该控制器负责处理。DMA 控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要 CPU 参与。 当传送完成后，DMA 控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要 CPU 的参与。 DMA 方式的最大优点和意义：\nDMA 控制方式与中断驱动方式的主要区别是中断驱动方式在每个数据需要传输时中断 CPU，而 DMA 控制方式则是在所要求传送的一批数据全部传送结束时才中断 CPU；\n此外，中断驱动方式数据传送是在中断处理时由CPU 控制完成的，而 DMA 控制方式则是在DMA 控制器的控制下完成的\nDMA 重大的成功在于将中断的次数从打印每个字符一次减少到打印每个缓冲区一次。\n如果有许多字符并且中断十分缓慢，那么采用 DMA 可能是重要的改进。 另一方面，DMA 比 CPU 慢很多，如果 DMA 控制器不能以全速驱动设备，或者 CPU 在等待 DMA 中断的同时没有其他事情要做，那么采用中断驱动 IO 甚至是程序控制 IO 也许更好\n通道控制方式 I/O 通道是指专门负责输入/输出的处理机。\nI/O 通道方式是 DMA 方式的发展，它可以进一步减少 CPU 的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。同时，又可以实现 CPU、通道和 I/O 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。\n通道控制实例\n当 CPU 要完成一组相关的读（或写）操作及有关控制时，只需向 I/O 通道发送一条 I/O 指令，以给出其所要执行的通道程序的首地址和要访问的 I/O 设备 通道接到该指令后，通过执行通道程序便可完成 CPU 指定的 I/O 任务，数据传送结束时向 CPU 发中断请求。 通道的特点和优势\nI/O 通道与一般处理机的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与 CPU 共享内存。\nI/O 通道与 DMA 方式的区别：\nDMA 方式需要 CPU 来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。 另外，每个 DMA 控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。 CPU 只需发出 I/O 指令，通道完成相应的 I/O 操作，并在操作结束时向 CPU 发出中断信号；同时一个通道还能控制多台外设。\n但是通道价格较高，从经济角度出发不宜过多使用。\nI/O 软件层次 I/O 软件涉及的面非常广，往下与硬件有着密切的联系，往上又与用户直接交互，它与进程管理、存储器管理、文件管理等都存在着一定的联系，即它们都可能需要 I/O 软件来实现 I/O 操作。\n为了使复杂的 I/O 软件具有清晰的结构，良好的可移植性和适应性，在 I/O 软件中普遍釆用了层次式结构，将系统输入/输出功能组织成一系列的层次，每一层都利用其下层提供的服务，完成输入/输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。在层次式结构的 I/O 软件中，只要层次间的接口不变，对某一层次中的软件的修改都不会引起其下层或高层代码的变更，仅最底层才涉及硬件的具体特性。\nI/O 软件系统层次 用户级 IO 软件 与设备无关的操作系统软件/设备独立性软件 设备驱动程序 中断处理程序 硬件 用户层 I/O 软件 实现与用户交互的接口，用户可直接调用在用户层提供的、与 I/O 操作有关的库函数，对设备进行操作。\n一般而言，大部分的 I/O 软件都在操作系统内部，但仍有一小部分在用户层，包括与用户程序链接在一起的库函数，以及完全运行于内核之外的一些程序。用户层软件必须通过一组系统调用来获取操作系统服务。\n系统调用（包括 I/O 系统调用）通常由库过程实现。\n并非所有的用户层 I/O 软件都是由库过程组成的。另一个重要的类别是[[假脱机系统]]。\n假脱机(spooling)是多道程序设计系统中处理独占 I/O 设备的一种方法。考虑一种典型的假脱机设备：打印机。 尽管在技术上可以十分容易地让任何用户进程打开表示该打印机的字符特殊文件，但是假如一个进程打开它，然后很长时间不使用，则其他进程都无法打印。 另一种方法是守护进程 daemon 以及假脱机目录\n一个进程要打印一个文件时，首先生成要打印的整个文件，并且将其放在假脱机目录下。由守护进程打印该目录下的文件，该进程是允许使用打印机特殊文件的唯一进程。 通过保护特殊文件来防止用户直接使用，可以解决某些进程不必要地长期空占打印机的问题。 设备独立性软件 用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护、以友设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。\n设备独立性也称设备无关性，使得应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了逻辑设备和物理设备这两个概念。\n在应用程序中，使用逻辑设备名来请求使用某类设备；而在系统实际执行时，必须将逻辑设备名映射成物理设备名使用。 使用逻辑设备名的好处是：\n增加设备分配的灵活性； 易于实现 I/O 重定向，所谓 I/O 重定向，是指用于 I/O 操作的设备可以更换（即重定向），而不必改变应用程序。 为了实现设备独立性，必须再在驱动程序之上设置一层设备独立性软件。总的来说，设备独立性软件的主要功能可分以为以下两个方面：\n执行所有设备的公有操作。 包括：对设备的分配与回收；将逻辑设备名映射为物理设备名；对设备进行保护，禁止用户直接访问设备；缓冲管理；差错控制；提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异。 向用户层（或文件层）提供统一接口。 无论何种设备，它们向用户所提供的接口应该是相同的。例如，对各种设备的读/写操作，在应用程序中都统一使用 read/write 命令等。 设备驱动程序 与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动 I/O 设备工作的驱动程序。\n通常，每一类设备配置一个设备驱动程序，它是 I/O 进程与设备控制器之间的通信程序，常以进程形式存在。 设备驱动程序向上层用户程序提供一组标准接口，设备具体的差别被设备驱动程序所封装，用于接收上层软件发来的抽象 I/O 要求，如 read 和 write 命令，转换为具体要求后，发送给设备控制器，控制 I/O 设备工作；它也将由设备控制器发来的信号传送给上层软件。从而为 I/O 内核子系统隐藏设备控制器之间的差异。 设备寄存器的数量和命令的性质在不同设备之间有着根本性的不同。例如，鼠标驱动程序必须从鼠标接收信息，以识别鼠标移动了多远的距离以及当前哪一个键被按下。相反，磁盘驱动程序可能必须要了解扇区、磁道、柱面、磁头、磁盘臂移动、电机驱动器、磁头定位时间以及所有其他保证磁盘正常工作的机制。\n设备驱动程序 device driver\n每个连接到计算机上的 IO 设备都需要某些特定的代码来对其进行控制——即设备驱动程序 每一个操作系统都需要自己的驱动程序，所以设备制造商通常要为若干流行的操作系统提供驱动程序。 每个设备驱动程序通常处理一种类型的设备,或者至多处理一类紧密相关的设备。 为了访问设备的硬件（意味着访问设备控制器的寄存器），设备驱动程序通常必须是操作系统内核的一部分，至少对目前的体系结构是如此。\n驱动程序的分类\n块设备——最通用的类别\n包含多个可以独立寻址的数据块 字符设备\n字符设备例如键盘和打印机则生成或接收字符流 驱动程序不允许进行系统调用，但是它们经常需要与内核的其余部分进行交互。对某些内核过程的调用通常是允许的。 例如，通常需要调用内核过程来分配和释放硬接线的内存页面作为缓冲区。还可能需要其他有用的调用来管理 MMU、定时器、DMA 控制器、中断控制器等。\n中断处理程序 用于保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回到被中断进程。\n将发生中断的驱动程序阻塞起来，直到 IO 操作完成并产生一个中断。\n驱动程序可以阻塞自己\n中断处理层的主要任务有：\n进行进程上下文的切换 对处理中断信号源进行测试 读取设备状态和修改进程状态等。 由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，故应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。\n中断发生时的情况分析\n当中断发生时，中断处理程序要完成全部工作，以实现对中断的处理 然后，它可以启动中断的驱动程序接触阻塞 可能其只是在一个信号量上执行操作 可能是对管程中的条件变量执行操作 中断的最终结果是使先前被阻塞的驱动程序现在能够继续运行。 中断时中断处理程序的详细任务\n1)保存没有被中断硬件保存的所有寄存器（包括 PSW)。 2)为中断服务过程设置上下文，可能包括设置 TLB、MMU 和页表。 3)为中断服务过程设置堆栈。 4)应答中断控制器，如果不存在集中的中断控制器，则再次开放中断。 5)将寄存器从它们被保存的地方（可能是某个堆栈）复制到进程表中。 6)运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息。 7)选择下一次运行哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行。 8)为下一次要运行的进程设置 MMU 上下文，也许还需要设置某个 TLB。 9)装入新进程的寄存器，包括其 PSW。 10)开始运行新进程。 硬件设备 I/O 设备通常包括一个机械部件和一个电子部件。为了达到设计的模块性和通用性，一般将其分开：电子部件称为设备控制器（或适配器），在个人计算机中，通常是一块插入主板扩充槽的印刷电路板；机械部件则是设备本身。\n详情见上文硬件部分的[[#设备控制器]]\n磁盘的组织与管理 磁盘结构 磁盘(Disk)是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为磁头 的导体线圈从磁盘中存取数据。\n在读/写操作期间，磁头固定，磁盘在下面高速旋转。 磁盘的盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽, 一个盘面有上千个磁道。磁道又划分为几百个扇区，每个扇区固定存储大小（通常为 512B), 一个扇区称为一个盘块。相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。 注意，由于扇区按固定圆心角度划分，所以密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。\n磁盘安装在一个磁盘驱动器中，它由磁头臂、用于旋转磁盘的主轴和用于数据输入/输 出的电子设备组成。 多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同且一起移动。 所有盘片上相对位置相同 的磁道组成柱面。按照这种物理结构组织，扇区就是磁盘可寻址的最小存储单位，磁盘地址 用“柱面号 • 盘面号 • 扇区号（或块号）”表示。 磁盘按不同方式可以分为若干类型： 磁头相对于盘片的径向方向固定的称为固定头磁盘，每个磁道一个磁头； 磁头可移动的称为活动头磁盘，磁头臂可以来回伸缩定位磁道。 磁盘永久固定在磁盘驱动器内的称为固定盘磁盘； 可移动和替换的称为可换盘磁盘。 磁盘调度算法 一次磁盘读写操作的时间由寻找（寻道）时间、延迟时间和传输时间决定\n一次磁盘读写操作需要的时间\n寻道时间： 启动磁头臂消耗的时间：s。 移动磁头消耗的时间：假设磁头匀速移动，每跨越一个磁道消耗时间为 m，共跨越 n 条磁道。 磁盘调度算法\nFCFS 先来先服务 算法思想：根据进程请求访问磁盘的先后顺序进行调度。 假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。 按照先来先服务算法规则，按照请求到达的顺序，磁头需要一次移动到55、58、39、18、90、160、150、38、184号磁道。 磁头共移动了 45 + 3 + 19 + 21 + 72 + 70 + 10 + 112 + 146 = 498个磁道。响应一个请求平均需要移动498 / 9 = 55.3个磁道（平均寻找长度）。 优缺点分析： 优点：公平；如果请求访问的磁道比较集中的话，算法性能还算可以。 缺点：如果大量进程竞争使用磁盘，请求访问的磁道很分散，FCFS 在性能上很差，寻道时间长。 SSTF 最短寻道时间 算法思想：优先处理的磁道是与当前磁头最近的磁道。可以保证每次寻道时间最短，但是不能保证总的寻道时间最短。（其实是贪心算法的思想，只是选择眼前最优，但是总体未必最优）。 假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。 磁头总共移动了（100 -18）+ （184 -18） = 248个磁道。响应一个请求平均需要移动248 / 9 = 27.5个磁道（平均寻找长度）。 最大的缺点：可能产生饥饿现象。 这里产生饥饿的原因是磁头在一小块区域来回移动。 SCAN 电梯调度算法 SSTF 算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。 为了防止这个问题，可以规定：磁头只有移动到请求最外侧磁道或最内侧磁道才可以反向移动，如果在磁头移动的方向上已经没有请求，就可以立即改变磁头移动，不必移动到最内/外侧的磁道。 这就是扫描算法的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。 假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的访问55、58、39、18、90、160、150、38、184号磁道。 磁头共移动了（184 - 100）+ （184 -18） = 250个磁道。响应一个请求平均需要移动 250 / 9 = 27.5个磁道（平均寻找长度）。 优缺点分析： 优点：性能较好，寻道时间较短，不会产生饥饿现象。 缺点：SCAN 算法对于各个位置磁道的响应频率不平均。（假设此时磁头正在往右移动，且刚处理过 90 号磁道，那么下次处理 90 号磁道的请求就需要等待低头移动很长一段距离；而响应了 184 号磁道的请求之后，很快又可以再次响应 184 号磁道请求了。） C-SCAN 循环扫描算法 SCAN 算法对各个位置磁道的响应频率不平均，而 C-SCAN 算法就是为了解决这个问题。 规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至最靠边缘的并且需要访问的磁道上而不处理任何请求。 通俗理解就是 SCAN 算在改变磁头方向时不处理磁盘访问请求而是直接移动到另一端最靠边的磁盘访问请求的磁道上。 假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的访问55、58、39、18、90、160、150、38、184号磁道。 磁头共移动了（184 -100）+ （184 - 18）+（90 - 18）=322个磁道。响应一个请求平均需要移动322 / 9 = 35.8个磁道（平均寻找长度）。 优缺点分析 优点：相比于 SCAN 算法，对于各个位置磁道响应频率很平均。 缺点：相比于 SCAN 算法，平均寻道时间更长。 磁盘管理 磁盘初始化\n一个新的磁盘只是一个含有磁性记录材料的空白盘。在磁盘能存储数据之前，它必须分成扇区以便磁盘控制器能进行读和写操作，这个过程称为低级格式化（物理分区）。低级格式化为磁盘的每个扇区釆用特别的数据结构。每个扇区的数据结构通常由头、数据区域（通常为 512B 大小）和尾部组成。头部和尾部包含了一些磁盘控制器所使用的信息。 为了使用磁盘存储文件，操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为由一个或多个柱面组成的分区（即我们熟悉的 C 盘、D 盘等形式的分区）；第二步对物理分区进行逻辑格式化（创建文件系统)，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。 引导块\n计算机启动时需要运行一个初始化程序（自举程序），它初始化 CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，该自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，从而开始操作系统的运行。 自举程序通常保存在 ROM 中，为了避免改变自举代码需要改变 ROM 硬件的问题，故只在 ROM 中保留很小的自举装入程序，将完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位。拥有启动分区的磁盘称为启动磁盘或者系统磁盘。 坏块\n由于磁盘有移动部件且容错能力弱，所以容易导致一个或多个扇区损坏。部分磁盘甚至从出厂时就有坏扇区。根据所使用的磁盘和控制器，对这些块有多种处理方式。 对于简单磁盘，如电子集成驱动器（IDE)。坏扇区可手工处理，如 MS-DOS 的 Format 命令执行逻辑格式化时便会扫描磁盘以检查坏扇区。坏扇区在 FAT 表上会标明，因此程序不会使用。 对于复杂的磁盘，如小型计算机系统接口（SCSI)，其控制器维护一个磁盘坏块链表。该链表在出厂前进行低级格式化时就初始化了，并在磁盘的整个使用过程中不断更新。低级格式化将一些块保留作为备用，对操作系统透明。控制器可以用备用块来逻辑地替代坏块，这种方案称为扇区备用。 I/O 子系统 由于 I/O 设备种类繁多，功能和传输速率差异巨大，需要多种方法来进行设备控制。这些方法共同组成了操作系统内核的 I/O 子系统\n它将内核的其他方面从繁重的 I/O 设备管理中解放出来。I/O 核心子系统提供的服务主要有 I/O 调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等。 I/O 调度 I/O 调度就是确定一个好的顺序来执行这些 I/O 请求。 应用程序所发布的系统调用的顺序不一定总是最佳选择，所以需要 I/O 调度来改善系统整体性能，使进程之间公平地共享设备访问，减少 I/O 完成所需要的平均等待时间。 操作系统开发人员通过为每个设备维护一个请求队列来实现调度。 当一个应用程序执行阻塞 I/O 系统调用时，该请求就加到相应设备的队列上。I/O 调度会重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间。 I/O 子系统还可以使用主存或磁盘上的存储空间的技术，如缓冲、高速缓冲、假脱机等，来改善计算机效率。\n高速缓存 操作系统中使用磁盘高速缓存技术来提高磁盘的 I/O 速度，对高速缓存复制的访问要比原始数据访问更为高效。 例如，正在运行的进程的指令既存储在磁盘上，也存储在物理内存上，也被复制到 CPU 的二级和一级高速缓存中。 不过，磁盘高速缓存技术不同于通常意义下的介于 CPU 与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。\n高速缓存在内存中分为两种形式： 一种是在内存中开辟一个单独的存储空间作为磁速缓存，大小固定； 另一种是把未利用的内存空间作为一个缓沖池，供请求分页系统和磁盘 I/O 时共享。 缓冲区 Buffer 在设备管理子系统中，引入缓冲区的目的主要有：\n缓和 CPU 与 I/O 设备间速度不匹配的矛盾。 减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。 解决基本数据单元大小（即数据粒度）不匹配的问题。 提高 CPU 和 I/O 设备之间的并行性。 其实现方法有：\n釆用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不釆用硬件缓冲器 釆用缓冲区（位于内存区域）。 单缓冲 在设备和处理机之间设置一个缓冲区。设备和处理机交换数据时，先把被交换数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据。\n如图所示，在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为 T，操作系统将该缓冲区中的数据传送到用户区的时间为 M，而 CPU 对这一块数据处理的时间为 C。由于 T 和 C 是可以并行的，当 T\u003eC 时，系统对每一块数据的处理时间为 M+T，反之则为 M+C，故可把系统对每一块数据的处理时间表示为 Max(C, T)+M。\n双缓冲 根据单缓冲的特点，CPU 在传送时间 M 内处于空闲状态，由此引入双缓冲。\nI/O 设备输入数据时先装填到缓冲区 1，在缓冲区 1 填满后才开始装填缓冲区 2，与此同时处理机可以从缓冲区 1 中取出数据放入用户进程处理，当缓冲区 1 中的数据处理完后，若缓冲区 2 已填满，则处理机又从缓冲区 2 中取出数据放入用户进程处理，而 I/O 设备又可以装填缓冲区 1。 双缓冲机制提高了处理机和输入设备的并行操作的程度。 如图 5-6 所示，系统处理一块数据的时间可以粗略地认为是 MAC(C, T)。如果 CT，则可使 CPU 不必等待设备输入。对于字符设备，若釆用行输入方式，则釆用双缓冲可使用户在输入完第一行之后，在 CPU 执行第一行中的命令的同时，用户可继续向第二缓冲区输入下一行数据。而单缓冲情况下则必须等待一行数据被提取完毕才可输入下一行的数据。\n如果两台机器之间通信仅配置了单缓冲，如图 5-7(a)所示。那么，它们在任一时刻都只能实现单方向的数据传输。例如，只允许把数据从 A 机传送到 B 机，或者从 B 机传送到 A 机，而绝不允许双方同时向对方发送数据。为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用做发送缓冲区，另一个用做接收缓冲区，如图 5-7(b)所示。\n循环缓冲 包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。\n循环缓冲用于输入/输出时，还需要有两个指针 in 和 out。\n对输入而言，首先要从设备接收数据到缓冲区中，in 指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out 指针指向可以提取数据的第一个满缓冲区。 输出则正好相反。 缓冲的另一种常用形式是循环缓冲区(circular buffer)。\n它由一个内存区域和两个指针组成。一个指针指向下一个空闲的字，新的数据可以放置到此处。另一个指针指向缓冲区中数据的第一个字，该字尚未被取走。 在许多情况下，当添加新的数据时（例如刚刚从网络到来），硬件将推进第一个指针，而操作系统在取走并处理数据时推进第二个指针。两个指针都是环绕的，当它们到达顶部时将回到底部。 类似于[[3 数据链路层#Sliding Window Protocol|数据链路层的滑动窗口协议]] 缓冲池 由多个系统公用的缓冲区组成\n缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列（输入队列）和装满输出数据的缓沖队列（输出队列）。 还应具有四种缓冲区：用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、 用于收容输出数据的工作缓冲区及用于提取输出数据的工作缓冲区，如图 5-8 所示。 四种主要缓冲区的使用\n当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。 当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。 当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。 当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。 高速缓存与缓冲区的对比：\n设备分配与回收 设备分配是指根据用户的 I/O 请求分配所需的设备。\n分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。 从设备的特性来看，釆用下述三种使用方式的设备分别称为独占设备、共享设备和虚拟设备三类。 独占式使用设备。指在申请设备时，如果设备空闲，就将其独占，不再允许其他进程申请使用，一直等到该设备被释放才允许其他进程申请使用。例如，打印机，在使用它打印时，只能独占式使用，否则在同一张纸上交替打印不同任务的内容，无法正常阅读。 分时式共享使用设备。独占式使用设备时，设备利用率很低，当设备没有独占使用的要求时，可以通过分时共享使用，提高利用率。例如，对磁盘设备的 I/O 操作，各进程的每次 I/O 操作请求可以通过分时来交替进行。 以 SPOOLing 方式使用外部设备。SPOOLing 技术是在批处理操作系统时代引入的，即假脱机 I/O 技术。这种技术用于对设备的操作，实质上就是对 I/O 操作进行批处理。 设备分配的数据结构 设备分配依据的主要数据结构有设备控制表(DCT)、控制器控制表(COCT)、通道控制表(CHCT)和系统设备表(SDT)，各数据结构功能如下：\n设备控制表 DCT：系统为每一个设备配置一张 DCT 它用于记录设备的特性以及与 I/O 控制器连接的情况。 DCT 包括设备标识符、设备类型、设备状态、指向控制器控制表 COCT 的指针等。其中，设备状态指示设备是忙还是空闲，设备队列指针指向等待使用该设备的进程组成的等待队列，控制表指针指向与该设备相连接的设备控制器。 控制器控制表 COCT：每个控制器都配有一张 COCT 它反映设备控制器的使用状态以及和通道的连接情况等。 通道控制表 CHCT：每个通道配有一张 CHCT 系统设备表 SDT：整个系统只有一张 SDT 它记录已连接到系统中的所有物理设备的情况，每个物理设备占一个表目。 由于在多道程序系统中，进程数多于资源数，会引起资源的竞争。因此，要有一套合理的分配原则，主要考虑的因素有： I/O 设备的固有属性 I/O 设备的分配算法 设备分配的安全性 设备独立性。 设备分配策略 设备分配原则：\n设备分配应根据设备特性、用户要求和系统配置情况。分配的总原则既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。 设备分配方式：设备分配方式有静态分配和动态分配两种。\n静态分配主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器（和通道)。一旦分配后，这些设备、控制器（和通道）就一直为该作业所占用，直到该作业被撤销。静态分配方式不会出现死锁，但设备的使用效率低。因此，静态分配方式弁不符合分配的总原则。 动态分配是在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需要的设备、I/O 控制器，一旦用完之后，便立即释放。动态分配方式有利于提高设备的利用率，但如果分配算法使用不当，则有可能造成进程死锁。 设备分配算法：常用的动态设备分配算法有先请求先分配、优先级高者优先等。\n对于独占设备，既可以釆用动态分配方式也可以静态分配方式，往往釆用静态分配方式，即在作业执行前，将作业所要用的这一类设备分配给它。 共享设备可被多个进程所共享，一般釆用动态分配方式，但在每个 I/O 传输的单位时间内只被一个进程所占有，通常釆用先请求先分配和优先级高者先分的分配算法。 设备分配安全性 设备分配的安全性是指设备分配中应防止发生进程死锁。\n安全分配方式：每当进程发出 I/O 请求后便进入阻塞状态，直到其 I/O 操作完成时才被唤醒。这样，一旦进程已经获得某种设备后便阻塞，不能再请求任何资源，而且在它阻塞时也不保持任何资源。i 点是设备分配安全；缺点是 CPU 和 I/O 设备是串行工作的（对同一进程而言)。\n不安全分配方式：进程在发出 I/O 请求后继续运行，需要时又发出第二个、第三个 I/O 请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。优点是一个进程可同时操作多个设备，从而使进程推进迅速；缺点是这种设备分配有可能产生死锁。\n逻辑设备名到物理设备名的映射 为了提高设备分配的灵活性和设备的利用率、方便实现 I/O 重定向，因此引入了设备独立性。设备独立性是指应用程序独立于具体使用的物理设备。\n为了实现设备独立性，在应用程序中使用逻辑设备名来请求使用某类设备，在系统中设置一张逻辑设备表(Logical Unit Table, LUT)，用于将逻辑设备名映射为物理设备名。\nLUT 表项包括逻辑设备名、物理设备名和设备驱动程序入口地址；当进程用逻辑设备名来请求分配设备时，系统为它分配相应的物理设备，并在 LUT 中建立一个表项，以后进程再利用逻辑设备名请求 I/0 操作时，系统通过查找 LUT 来寻找相应的物理设备和驱动程序。 在系统中可釆取两种方式建立逻辑设备表：\n在整个系统中只设置一张 LUT。这样，所有进程的设备分配情况都记录在这张表中，故不允许有相同的逻辑设备名，主要适用于单用户系统中。 为每个用户设置一张 LUT。当用户登录时，系统便为该用户建立一个进程，同时也为之建立一张 LUT，并将该表放入进程的 PCB 中。 SPOOLing 技术 为了缓和 CPU 的高速性与 I/O 设备低速性之间的矛盾而引入了脱机输入/输出技术。该技术是利用专门的外围控制机，将低速 I/O 设备上的数据传送到高速磁盘上；或者相反。\nSPOOLing 的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，是操作系统中釆 用的一项将独占设备改造成共享设备的技术。\n输入井和输出井 在磁盘上开辟出的两个存储区域。\n输入井模拟脱机输入时的磁盘，用于收容 I/O 设备输入的数据。 输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。 输入缓冲区和输出缓冲区 在内存中开辟的两个缓冲区。\n输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。 输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。 输入进程和输出进程 输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。 当 CPU 需要输入数据时，直接将数据从输入井读入内存。 输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出并，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备。 SPOOLing 技术实例\n共享打印机是使用 SPOOLing 技术的一个实例，这项技术已被广泛地用于多用户系统和 局域网络中。当用户进程请求打印输出时，SPOOLing 系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程，而只为它做两件事： 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中。 输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。 SPOOLing 系统的主要特点有：提高了 I/O 的速度；将独占设备改造为共享设备；实现了虚拟设备功能。\n小结 层次 I/O 功能 用户进程 产生 I/O 请求；对 I/O 进行格式化；假脱机 与设备无关的软件 命名、保护、分块、缓冲、分配 设备驱动程序 设置设备寄存器；检查状态 中断处理程序 当 I/O 完成时唤醒驱动程序 硬件 执行 I/O 操作 I/O 请求由上至下，而 I/O 应答由下至上。这非常类似于[[1 引言#OSI 参考模型|OSI 参考模型]]的整个栈层次构成 当一个用户程序试图从一个文件中读一个块时，操作系统被调用以实现这一请求。\n与设备无关的软件在缓冲区高速缓存中查找有无要读的块。如果需要的块不在其中， 则调用设备驱动程序，向硬件发出一个请求，让它从磁盘中获取该块。然后，进程被阻塞直到磁盘操作完成并且数据在调用者的缓冲区中安全可用。\n当磁盘操作完成时，硬件产生一个中断。中断处理程序就会运行，它要查明发生了什么事情，也就是说此刻需要关注哪个设备。然后，中断处理程序从设备提取状态信息，唤醒休眠的进程以结束此次 I/O 请求，并且让用户进程继续运行。\n操作系统输入/输出(I/O)管理_C 语言中文网\n","wordCount":"1307","inLanguage":"en","datePublished":"2022-05-06T11:40:58+08:00","dateModified":"2022-05-06T11:40:58+08:00","author":{"@type":"Person","name":"CaesarYang"},"mainEntityOfPage":{"@type":"WebPage","@id":"/post/tech/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/o5-io%E7%B3%BB%E7%BB%9F/"},"publisher":{"@type":"Organization","name":"Caesar's Paperbox","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Caesar's Paperbox (Alt + H)"><img src=/avatar.jpeg alt aria-label=logo height=35>Caesar's Paperbox</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=archives title=Archives><span>Archives</span></a></li><li><a href=post/life title=Life><span>Life</span></a></li><li><a href=post/reading title=Reading><span>Reading</span></a></li><li><a href=post/tech title=Tech><span>Tech</span></a></li><li><a href=http://storage.cyang.site/resume/%E6%9D%A8%E4%B8%9A%E5%8D%BF%E7%AE%80%E5%8E%86_resume_202210.pdf title="Resume 简历"><span>Resume 简历</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/post/>Articles</a>&nbsp;»&nbsp;<a href=/post/tech/>Tech</a></div><h1 class=post-title>O5-IO系统</h1><div class=post-meta><span title='2022-05-06 11:40:58 +0800 CST'>May 6, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1307 words&nbsp;·&nbsp;CaesarYang&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/tech/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%ac%94%e8%ae%b0/O5%20IO%e7%b3%bb%e7%bb%9f.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intro aria-label=Intro>Intro</a></li><li><a href=#io-%e7%a1%ac%e4%bb%b6%e5%8e%9f%e7%90%86 aria-label="I/O 硬件原理">I/O 硬件原理</a><ul><li><a href=#io-%e8%ae%be%e5%a4%87 aria-label="I/O 设备">I/O 设备</a></li><li><a href=#%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%99%a8 aria-label=设备控制器>设备控制器</a></li><li><a href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84-io aria-label="内存映射 I/O">内存映射 I/O</a></li><li><a href=#%e7%9b%b4%e6%8e%a5%e5%ad%98%e5%82%a8%e5%99%a8%e5%ad%98%e5%8f%96-dma aria-label=直接存储器存取-DMA>直接存储器存取-DMA</a></li><li><a href=#%e4%b8%ad%e6%96%ad aria-label=中断>中断</a></li></ul></li><li><a href=#io-%e8%bd%af%e4%bb%b6%e5%8e%9f%e7%90%86 aria-label="I/O 软件原理">I/O 软件原理</a><ul><li><a href=#io-%e8%bd%af%e4%bb%b6%e7%9a%84%e7%9b%ae%e6%a0%87 aria-label="I/O 软件的目标">I/O 软件的目标</a></li><li><a href=#io-%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f aria-label="I/O 控制方式">I/O 控制方式</a><ul><li><a href=#%e7%a8%8b%e5%ba%8f%e7%9b%b4%e6%8e%a5%e6%8e%a7%e5%88%b6-io aria-label="程序直接控制 I/O">程序直接控制 I/O</a></li><li><a href=#%e4%b8%ad%e6%96%ad%e9%a9%b1%e5%8a%a8%e6%96%b9%e5%bc%8f-io aria-label="中断驱动方式 I/O">中断驱动方式 I/O</a></li><li><a href=#dma-%e6%96%b9%e5%bc%8f-io aria-label="DMA 方式 I/O">DMA 方式 I/O</a></li><li><a href=#%e9%80%9a%e9%81%93%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f aria-label=通道控制方式>通道控制方式</a></li></ul></li><li><a href=#io-%e8%bd%af%e4%bb%b6%e5%b1%82%e6%ac%a1 aria-label="I/O 软件层次">I/O 软件层次</a><ul><li><a href=#%e7%94%a8%e6%88%b7%e5%b1%82-io-%e8%bd%af%e4%bb%b6 aria-label="用户层 I/O 软件">用户层 I/O 软件</a></li><li><a href=#%e8%ae%be%e5%a4%87%e7%8b%ac%e7%ab%8b%e6%80%a7%e8%bd%af%e4%bb%b6 aria-label=设备独立性软件>设备独立性软件</a></li><li><a href=#%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f aria-label=设备驱动程序>设备驱动程序</a></li><li><a href=#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f aria-label=中断处理程序>中断处理程序</a></li><li><a href=#%e7%a1%ac%e4%bb%b6%e8%ae%be%e5%a4%87 aria-label=硬件设备>硬件设备</a></li></ul></li></ul></li><li><a href=#%e7%a3%81%e7%9b%98%e7%9a%84%e7%bb%84%e7%bb%87%e4%b8%8e%e7%ae%a1%e7%90%86 aria-label=磁盘的组织与管理>磁盘的组织与管理</a><ul><li><a href=#%e7%a3%81%e7%9b%98%e7%bb%93%e6%9e%84 aria-label=磁盘结构>磁盘结构</a></li><li><a href=#%e7%a3%81%e7%9b%98%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label=磁盘调度算法>磁盘调度算法</a><ul><li><a href=#fcfs-%e5%85%88%e6%9d%a5%e5%85%88%e6%9c%8d%e5%8a%a1 aria-label="FCFS 先来先服务">FCFS 先来先服务</a></li><li><a href=#sstf-%e6%9c%80%e7%9f%ad%e5%af%bb%e9%81%93%e6%97%b6%e9%97%b4 aria-label="SSTF 最短寻道时间">SSTF 最短寻道时间</a></li><li><a href=#scan-%e7%94%b5%e6%a2%af%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label="SCAN 电梯调度算法">SCAN 电梯调度算法</a></li><li><a href=#c-scan-%e5%be%aa%e7%8e%af%e6%89%ab%e6%8f%8f%e7%ae%97%e6%b3%95 aria-label="C-SCAN 循环扫描算法">C-SCAN 循环扫描算法</a></li></ul></li><li><a href=#%e7%a3%81%e7%9b%98%e7%ae%a1%e7%90%86 aria-label=磁盘管理>磁盘管理</a></li></ul></li><li><a href=#io-%e5%ad%90%e7%b3%bb%e7%bb%9f aria-label="I/O 子系统">I/O 子系统</a><ul><li><a href=#io-%e8%b0%83%e5%ba%a6 aria-label="I/O 调度">I/O 调度</a></li><li><a href=#%e9%ab%98%e9%80%9f%e7%bc%93%e5%ad%98 aria-label=高速缓存>高速缓存</a></li><li><a href=#%e7%bc%93%e5%86%b2%e5%8c%ba-buffer aria-label="缓冲区 Buffer">缓冲区 Buffer</a><ul><li><a href=#%e5%8d%95%e7%bc%93%e5%86%b2 aria-label=单缓冲>单缓冲</a></li><li><a href=#%e5%8f%8c%e7%bc%93%e5%86%b2 aria-label=双缓冲>双缓冲</a></li><li><a href=#%e5%be%aa%e7%8e%af%e7%bc%93%e5%86%b2 aria-label=循环缓冲>循环缓冲</a></li><li><a href=#%e7%bc%93%e5%86%b2%e6%b1%a0 aria-label=缓冲池>缓冲池</a></li></ul></li><li><a href=#%e8%ae%be%e5%a4%87%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6 aria-label=设备分配与回收>设备分配与回收</a><ul><li><a href=#%e8%ae%be%e5%a4%87%e5%88%86%e9%85%8d%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=设备分配的数据结构>设备分配的数据结构</a></li><li><a href=#%e8%ae%be%e5%a4%87%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5 aria-label=设备分配策略>设备分配策略</a></li><li><a href=#%e8%ae%be%e5%a4%87%e5%88%86%e9%85%8d%e5%ae%89%e5%85%a8%e6%80%a7 aria-label=设备分配安全性>设备分配安全性</a></li><li><a href=#%e9%80%bb%e8%be%91%e8%ae%be%e5%a4%87%e5%90%8d%e5%88%b0%e7%89%a9%e7%90%86%e8%ae%be%e5%a4%87%e5%90%8d%e7%9a%84%e6%98%a0%e5%b0%84 aria-label=逻辑设备名到物理设备名的映射>逻辑设备名到物理设备名的映射</a></li></ul></li><li><a href=#spooling-%e6%8a%80%e6%9c%af aria-label="SPOOLing 技术">SPOOLing 技术</a><ul><li><a href=#%e8%be%93%e5%85%a5%e4%ba%95%e5%92%8c%e8%be%93%e5%87%ba%e4%ba%95 aria-label=输入井和输出井>输入井和输出井</a></li><li><a href=#%e8%be%93%e5%85%a5%e7%bc%93%e5%86%b2%e5%8c%ba%e5%92%8c%e8%be%93%e5%87%ba%e7%bc%93%e5%86%b2%e5%8c%ba aria-label=输入缓冲区和输出缓冲区>输入缓冲区和输出缓冲区</a></li><li><a href=#%e8%be%93%e5%85%a5%e8%bf%9b%e7%a8%8b%e5%92%8c%e8%be%93%e5%87%ba%e8%bf%9b%e7%a8%8b aria-label=输入进程和输出进程>输入进程和输出进程</a></li></ul></li></ul></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h1><p>除了提供抽象（例如，进程、地址空间和文件）以外，操作系统还要控制计算机的所有 I/O(输入输出) 设备。操作系统必须向设备发送命令，捕捉中断，并处理设备的各种错误。</p><p>它还应该在设备和系统的其他部分之间提供简单且易于使用的接口。如果有可能，这个接口对于所有设备都应该是相同的，这就是所谓的设备无关性。</p><p><strong>I/O 部分的代码是整个操作系统的重要组成部分。操作系统如何管理 I/O 是本章的主题。</strong></p><hr><ul><li><strong>5.输入输出(I/O)管理</strong><ul><li><strong>（1）I/O 管理概述</strong><ul><li>1）I/O 控制方式</li><li>2）I/O 软件层次结构</li></ul></li><li><strong>（2）I/O 核心子系统</strong><ul><li>1）I/O 调度概念</li><li>2）高速缓存与缓冲区</li><li>3）设备分配与回收</li><li>4）假脱机技术(SPOOLing)</li></ul></li></ul></li></ul><h1 id=io-硬件原理>I/O 硬件原理<a hidden class=anchor aria-hidden=true href=#io-硬件原理>#</a></h1><p>不同的人对于 IO 硬件的理解是不同的。对于电子工程师而言，I/O 硬件就是芯片、导线、电源、电机和其他组成硬件的物理部件。</p><p>对程序员而言，则只注意 I/O 硬件提供给软件的接口，如硬件能够接收的命令、它能够实现的功能以及它能够报告的错误。</p><h2 id=io-设备>I/O 设备<a hidden class=anchor aria-hidden=true href=#io-设备>#</a></h2><p>IO 设备可以大致分为两类：<strong>块设备（Block device</strong>）和<strong>字符设备（character device）</strong></p><ul><li>块设备<ul><li>把信息存储在固定大小的块中，每个块有自己的地址</li><li>所有的传输都是以一个或多个完整的（连续的）块为单位</li><li>块设备的基本特征就是每个块都能独立于其他块而读写。</li><li>硬盘、蓝光光盘和 USB 盘是最常见的设备</li></ul></li></ul><p>主要概念中的 I/O 系统分类方式：</p><ul><li><strong>计算机系统中的 I/O 设备按使用特性可分为以下类型：</strong><ul><li><ol><li>人机交互类外部设备：用于同计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。</li></ol></li><li><ol start=2><li>存储设备：用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。</li></ol></li><li><ol start=3><li>网络通信设备：用于与远程设备通信的设备，如各种网络接口、调制解调器等。其速度介于前两类设备之间。网络通信设备在使用和管理上与前两类设备也有很大不同。</li></ol></li></ul></li></ul><p>IO 设备还可以按以下方式分类：</p><ul><li><p><strong>按传输速度分类</strong></p><ul><li>低速设备：传输速率仅为每秒几个到数百个字节的一类设备，如键盘、鼠标等。</li><li>中速设备：传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、 激光打印机等。</li><li>高速设备：传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、 光盘机等。</li></ul></li><li><p><strong>按信息交换的单位分类</strong></p><ul><li><strong>块设备</strong>：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块。</li><li><strong>字符设备</strong>：用于数据输入/输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入/输出时常釆用中断驱动方式。</li></ul></li></ul><h2 id=设备控制器>设备控制器<a hidden class=anchor aria-hidden=true href=#设备控制器>#</a></h2><p>I/O 设备一般由机械部件和电子部件两部分组成。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。</p><p>电子部件称作设备<strong>控制器(device controller)或适配器(adapter)</strong>。在个人计算机上，它经常以主板上的芯片的形式出现，或者以插入(PCI)扩展槽中的印刷电路板的形式出现。</p><p>机械部件则是设备本身。</p><blockquote><p>设备控制器通过寄存器与 CPU 通信，在某些计算机上，这些寄存器占用内存地址的一部分，称为内存映像 I/O；另一些计算机则釆用 I/O 专用地址，寄存器独立编址。操作系统通过向控制器寄存器写命令字来执行 I/O 功能。控制器收到一条命令后，CPU 可以转向进行其他工作，而让设备控制器自行完成具体的 I/O 操作。当命令执行完毕后，控制器发出一个中断信号，操作系统重新获得 CPU 的控制权并检查执行结果，此时，CPU 仍旧是从控制器寄存器中读取信息来获得执行结果和设备的状态信息。</p></blockquote><ul><li><p><strong>控制器的任务</strong></p><ul><li>把串行的位流转换为字节块，并进行必要的错误矫正工作</li><li>字节块通常首先在控制器内部的一个缓冲区中按位进行组装，然后再对校验和进行校验并证明字节块没有错误后，再将其复制到主存中</li></ul></li><li><p><strong>设备控制器的功能</strong></p><ul><li>接收和识别 CPU 或通道发来的命令，如磁盘控制器能接收读、写、查找等命令。</li><li>实现数据交换，包括设备和控制器之间的数据传输；通过数据总线或通道，控制器和主存之间的数据传输。</li><li>发现和记录设备及自身的状态信息，供 CPU 处理使用。</li><li>设备地址识别。</li></ul></li><li><p><strong>为实现上述功能，设备控制器必须包含以下组成部分：</strong></p><ul><li><strong>设备控制器与 CPU 的接口。</strong> 该接口有三类信号线：数据线、地址线和控制线。数据线通常与两类寄存器相连接：数据寄存器（存放从设备送来的输入数据或从 CPU 送来的输出数据）和控制/状态寄存器（存放从 CPU 送来的控制信息或设备的状态信息)。</li><li><strong>设备控制器与设备的接口</strong>。设备控制器连接设备需要相应数量的接口，一个接口连接一台设备。每个接口中都存在数据、控制和状态三种类型的信号。</li><li><strong>I/O 控制逻辑</strong>。用于实现对设备的控制。它通过一组控制线与 CPU 交互，对从 CPU 收到的 I/O 命令进行译码。CPU 启动设备时，将启动命令发送给控制器，同时通过地:址线把地址发送给控制器，由控制器的 I/O 逻辑对地址进行译码，并相应地对所选设备进行控制。</li></ul></li></ul><p><img loading=lazy src=http://c.biancheng.net/cpp/uploads/allimg/140702/1-140F2154455533.jpg alt></p><h2 id=内存映射-io>内存映射 I/O<a hidden class=anchor aria-hidden=true href=#内存映射-io>#</a></h2><p>每个控制器有几个寄存器用来与 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。</p><ul><li><p>除了这些控制寄存器以外,许多设备还有一个操作系统可以读写的数据缓冲区。</p><ul><li>可供程序或 OS 写入数据</li></ul></li><li><p><em>Q：CPU 如何与设备的控制寄存器和数据缓冲区进行通信？</em></p><ul><li>第一种方法：<strong>单独的 IO 和内存空间。</strong><ul><li>每个控制寄存器被分配一个 IO 端口号。所有 IO 端口形成 IO 端口空间，并且受到保护使得普通的用户程序不能对其进行访问（只用 OS 可以访问）</li><li>在这一种方法中，内存地址空间和 IO 地址空间是不同的</li></ul></li><li>第二种方法：<strong>内存映射 I/O</strong><ul><li>将所有控制寄存器映射到内存空间中。每个控制寄存器被分配唯一的一个内存地址，并且不会有内存被分配这一地址。</li><li>大多数系统中，分配给控制寄存器的地址位于或者靠近地址空间的顶端</li></ul></li><li>第三种方法：<strong>混合方式</strong>。这一方案具有内存映射 IO 的数据缓冲区，而控制寄存器则有单独的 IO 端口。x86 采用这一体系结构</li></ul></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207201507709.png alt></p><p><strong>工作实例：</strong></p><blockquote><p>在各种情形下，当 CPU 想要读入一个字的时候，不论是从内存中读入还是从/O 端口中读入，它都要将需要的地址放到总线的地址线上，然后在总线的一条控制线上置起一个 READ 信号。还要用到第二条信号线来表明需要的是 I/O 空间还是内存空间。如果是内存空间，内存将响应请求。如果是 I/O 空间，I/O 设备将响应请求。如果只有内存空间（如图 5-2b 所示的情形），那么每个内存模块和每个 I/O 设备都会将地址线和它所服务的地址范围进行比较，如果地址落在这一范围之内， 它就会响应请求。因为绝对不会有地址既分配给内存又分配给 I/O 设备，所以不会存在歧义和冲突。</p></blockquote><ul><li><strong>内存映射 I/O 的优点：</strong><ul><li><strong>设备驱动程序代码简便且一致</strong><ul><li>设备控制器只是内存中的变量，在 C 语言中可以和任何其他变量一起寻址。</li><li>因此，对于内存映射 IO，IO 设备驱动程序完全可以用 C 语言编写。</li><li>如果不使用内存映射 IO，需要用到某些汇编代码</li></ul></li><li><strong>不需要特殊的保护机制来阻止用户进程执行 I/O 操作</strong><ul><li>操作系统必须要做的全部事情只是避免把包含控制寄存器的那部分地址空间放入任何用户的虚拟地址空间之中。</li><li>更为有利的是，如果每个设备在地址空间的不同页面上拥有自己的控制寄存器，操作系统只要简单地通过在其页表中包含期望的页面就可以让用户控制特定的设备而不是其他设备。</li><li>这样的方案可以使不同的设备驱动程序放置在不同的地址空间中，不但可以减小内核的大小，而且可以防止驱动程序之间相互干扰。</li></ul></li><li><strong>可以引用内存的每一条指令也可以引用控制寄存器</strong></li></ul></li><li><strong>缺点：</strong><ul><li>硬件必须能够针对每个页面有选择地禁用高速缓存，为硬件和 OS 同时增加了复杂性</li><li>在内存映射的机器上具有单独的内存总线的麻烦是 I/O 设备没有办法查看内存地址,因为内存地址旁路到内存总线上,所以没有办法响应。</li></ul></li></ul><h2 id=直接存储器存取-dma>直接存储器存取-DMA<a hidden class=anchor aria-hidden=true href=#直接存储器存取-dma>#</a></h2><p><strong>无论一个 CPU 是否具有内存映射 I/O,它都需要寻址设备控制器以便与它们交换数据</strong>。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这样做浪费 CPU 的时间，所以经常用到一种称为<strong>直接存储器存取(Direct Memory Access,DMA)</strong> 的不同方案。</p><ul><li><p><strong>只有硬件具有 DMA 控制器时操作系统才能使用 DMA</strong>, 而大多数系统都有 DMA 控制器。</p><ul><li>有时 DMA 控制器集成到磁盘控制器和其他控制器之中，但是这样的设计要求每个设备有一个单独的 DMA 控制器。</li><li>更加普遍的是，只有一个 DMA 控制器可利用（例如，在主板上)，由它调控到多个设备的数据传送，而这些数据传送经常是同时发生的。</li></ul></li><li><p>无论 DMA 控制器在物理上处于什么地方,它都能够独立于 CPU 而访问系统总线。</p></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207201529214.png alt></p><ul><li><p><strong>没有使用 DMA 情况的工作原理：</strong></p><ul><li>首先,控制器从磁盘驱动器串行地、一位一位地读一个块(一个或多个扇区),直到将整块信息放入控制器的内部缓冲区中。</li><li>接着,它计算校验和,以保证没有读错误发生。</li><li>然后控制器产生一个中断。——转到 OS 内部运行的开始</li><li>当操作系统开始运行时,它重复地从控制器的缓冲区中一次一个字节或一个字地读取该块的信息,并将其存入内存中。</li></ul></li><li><p><strong>使用 DMA 控制器的工作过程：</strong></p><ul><li>首先,CPU 通过设置 DMA 控制器的寄存器对它进行编程,所以 DMA 控制器知道将什么数据传送到什么地方(图 5-4 中的第 1 步 ) 。</li><li>DMA 控制器还要向磁盘控制器发出一个命令,通知它从磁盘读数据到其内部的缓冲区中,并且对校验和进行枪验。</li><li>如果磁盘控制器的缓冲区中的数据是有效的,那么 DMA 就可以开始了。</li><li>DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送(第 2 步)。<ul><li>这一读请求看起来与任何其他读请求是一样的、并且磁盘控制器井不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。</li><li>一般情况下,要写的内存地址在总线的地址线上,所以当磁盘控制器从其内部缓冲区中读取下一个字的时候,它知道将该字写到什么地方。</li></ul></li><li>写到内存是另一个标淮总线周期(第 3 步)。</li><li>当写操作完成时,磁盘控制器在总线上发出一个应答信号到 DMA 控制器(第 4 步)。<ul><li>于是,DMA 控制器步增要使用的内存地址,井且步减字节计数。</li><li>如果字节计数仍然大于 0 ,则重复第 2 步到第 4 步,直到字节计数到达 0。</li></ul></li><li>此时,DMA 控制器将中断 CPU 以便让 CPU 知道传送现在已经完成了。</li><li>当操作系统开始工作时,用不着将磁盘块复制到内存中,因为它已经在内存中了。</li></ul></li><li><p><em>Q：为什么控制器从磁盘读取字节后不立即将其存储在主存中？为什么需要一个内部缓冲区？</em></p><ul><li>1:通过内部缓冲，磁盘控制器可以在开始传送前计算校验和</li><li>2:一旦磁盘传送开始工作，从磁盘读出的数据就是以固定速率到达的，而不论控制器是否做好准备接收数据。<ul><li>如果控制器直接将其写入内存，则它必须要为传送的每个字取得系统总线的控制权。</li><li>此时，若由于其他设备使用总线而导致总线忙，则控制器只能等待。</li><li>而如果设计内部缓冲区，则控制器的设计可以简化，因为对 DMA 到内存的传送没有严格的时间要求</li></ul></li></ul></li></ul><p>更多细节内容</p><ul><li><p><strong>周期窃取 cycle stealing</strong></p><ul><li>DMA 控制器请求传送一个字并且得到这个字。如果 CPU 也想使用总线,它必须等待。</li><li>这一机制称为周期窃取( cycle stealing ) , 因为设备控制器偶尔偷偷溜入并且从 CPU 偷走一个临时的总线周期,从而轻微地延迟 CPU。</li></ul></li><li><p><strong>突发模式 burst mode</strong></p><ul><li>在块模式中，DMA 控制器通知涉笔获得总线，发起一连串的传送，然后释放总线</li><li>它比周期窃取效率更高，因为获得总线占用了时间，并且一次总线获得的代价能够传送多个字</li><li>突发模式的缺点是，如果正在进行的是长时间传送，有可能将 CPU 和其他设备阻塞相当长的周期</li></ul></li></ul><h2 id=中断>中断<a hidden class=anchor aria-hidden=true href=#中断>#</a></h2><p>在硬件层面，中断的工作如下所述：当一个 I/O 设备完成交给它的工作时，它就产生一个中断（假设操作系统已经开放中断），它是通过在分配给它的一条总线信号线上置起信号而产生中断的。该信号被主板上的中断控制器芯片检测到，由中断控制器芯片决定做什么。</p><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207201549663.png alt></p><p><strong>中断处理方式详细内容梳理：</strong></p><ul><li><p><strong>如果没有其他中断悬而未决，中断控制器将立刻对中断进行处理。</strong></p><ul><li>如果有另一个中断正在处理中， 或者另一个设备在总线上具有更高优先级的一条中断请求线上同时发出中断请求，该设备将暂时不被理睬。</li><li>在这种情况下，该设备将继续在总线上置起中断信号，直到得到 CPU 的服务。</li></ul></li><li><p>为了处理中断，中断控制器在地址线上放置一个数字表明哪个设备需要关注，并且置起一个中断 CPU 的信号。</p></li><li><p>中断信号导致 CPU 停止当前正在做的工作并且开始做其他的事情。地址线上的数字被用做指向一个称为<strong>中断向量(interrupt vector)</strong> 的表格的索引，以便读取一个新的程序计数器。这一程序计数器指向相应的中断服务过程的开始。</p><ul><li>一般情况下，陷阱和中断从这一点上看使用相同的机制，并且常常共享相同的中断向量。中断向量的位置可以硬布线到机器中，也可以在内存中的任何地方通过一个 CPU 寄存器(由操作系统装载)指向其起点。</li></ul></li><li><p>中断服务过程开始运行后，它立刻通过将一个确定的值写到中断控制器的某个 I/O 端口来对中断做出应答。</p><ul><li>这一应答告诉中断控制器可以自由地发出另一个中断。通过让 CPU 延迟这一应答直到它准备好处理下一个中断，就可以避免与多个几乎同时发生的中断相牵涉的竞争状态。</li></ul></li><li><p><strong>中断时上下文等关键寄存器信息的保存：</strong></p><ul><li>一种选择是将其放入内部寄存器中，在需要时操作系统可以读出这些内部寄存器。这一方法的问题是，中断控制器之后无法得到应答，直到所有可能的相关信息被读出，以免第二个中断重写内部寄存器保存状态。这一策略在中断被禁止时将导致长时间的死机，并且可能丢失中断和丢失数据。</li><li>因此，大多数 CPU 在堆栈中保存信息。然而，这种方法也有问题。首先，使用谁的堆栈？如果使用当前堆栈，则它很可能是用户进程的堆栈。堆栈指针甚至可能不是合法的，这样当硬件试图在它所指的地址处写某些字时，将导致致命错误。此外，它可能指向一个页面的末端。若干次内存写之后，页面边界可能被超出并且产生一个页面故障。在硬件中断处理期间如果发生页面故障将引起更大的问题：在何处保存状态以处理页面故障？</li></ul></li><li><p><strong>精确中断</strong></p><ul><li>将机器留在一个明确状态的中断</li><li>四个重要特征：<ul><li>1)PC(程序计数器)保存在一个已知的地方。</li><li>2)PC 所指向的指令之前的所有指令已经完全执行。</li><li>3)PC 所指向的指令之后的所有指令都没有执行。</li><li>4)PC 所指向的指令的执行状态是已知的。</li></ul></li></ul></li></ul><h1 id=io-软件原理>I/O 软件原理<a hidden class=anchor aria-hidden=true href=#io-软件原理>#</a></h1><h2 id=io-软件的目标>I/O 软件的目标<a hidden class=anchor aria-hidden=true href=#io-软件的目标>#</a></h2><p>在设计 I/O 软件时一个关键的概念是<strong>设备独立性(device independence)。</strong> 它的意思是应该能够编写出这样的程序：它可以访问任意/O 设备而无需事先指定设备。</p><p>例如，读取一个文件作为输入的程序应该能够在硬盘、DVD 或者 USB 盘上读取文件，无需为每一种不同的设备修改程序。</p><ul><li><strong>设备独立性</strong></li><li><strong>统一命名</strong><ul><li>用这种方法,所有文件和设备都采用相同的方式一路径名进行寻址。</li></ul></li><li><strong>错误处理</strong><ul><li>一般来说，错误应该尽可能地在接近硬件的层面得到处理。当控制器发现了一个读错误时，如果它能够处理那么就应该自己设法纠正这一错误。</li><li>如果控制器处理不了，那么设备驱动程序应当予以处理，可能只需重读一次这块数据就正确了。很多错误是偶然性的</li><li>只有在低层软件处理不了的情况下，才将错误上交高层处理。在许多情况下，错误恢复可以在低层透明地得到解决，而高层软件甚至不知道存在这一错误。</li></ul></li><li><strong>同步和异步传输</strong><ul><li>同步即阻塞</li><li>异步即中断驱动</li></ul></li><li><strong>缓冲 buffering</strong><ul><li>数据离开一个设备之后通常并不能直接存放到其最终的目的地。</li><li>缓冲涉及到大量的工作，并且经常对 I/O 性能有重大影响</li></ul></li></ul><h2 id=io-控制方式>I/O 控制方式<a hidden class=anchor aria-hidden=true href=#io-控制方式>#</a></h2><p>三种最主要的 I/O 控制方式：</p><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221703629.png alt></p><h3 id=程序直接控制-io>程序直接控制 I/O<a hidden class=anchor aria-hidden=true href=#程序直接控制-io>#</a></h3><p>I/O 的最简单形式是让 CPU 做全部工作，这一方法称为<strong>程序控制 I/O(programmed I/O)</strong></p><ul><li><p>操作系统的主要操作：</p><ul><li>首先，数据被复制到内核空间。然后，操作系统进入一个密闭的循环，一次输出一个字符。</li><li>输出一个字符之后，CPU 要不断地查询设备以了解它是否就绪准备接收另一个字符。这一行为经常称为<strong>轮询(polling)或忙等待(busy waiting)</strong>。</li></ul></li><li><p>程序控制 I/O 的缺点</p><ul><li>直到全部 I/O 完成之前要占用 CPU 的全部时间。</li><li>如果“打印一个字符的时间非常短（因为打印机所做的全部事情就是将新的字符复制到一个内部缓冲区中），那么忙等待还是不错的。此外，在嵌入式系统中，CPU 没有其他事情要做，忙等待也是合理的。</li><li>然而，在更加复杂的系统中，CPU 有其他工作要做，忙等待将是低效的，需要更好的 IO 方法。</li></ul></li></ul><p><strong>程序直接控制方式虽然简单易于实现，但是其缺点也是显而易见的，由于 cpu 和 I/O 设备只能串行工作，导致 CPU 的利用率相当低。</strong></p><h3 id=中断驱动方式-io>中断驱动方式 I/O<a hidden class=anchor aria-hidden=true href=#中断驱动方式-io>#</a></h3><p><strong>这种允许 CPU 在等待打印机变为就绪的同时做某些其他事情的方式就是使用中断。</strong></p><ul><li><p>中断驱动方式的思想：</p><ul><li><strong>允许 I/O 设备主动打断 CPU 的运行并请求服务，从而“解放”CPU，使得其向 I/O 控制器发送读命令后可以继续做其他有用的工作。</strong></li></ul></li><li><p><strong>从 I/O 控制器的角度来看：</strong></p><ul><li>I/O 控制器从 CPU 接收一个读命令，然后从外围设备读数据。</li><li>一旦数据读入到该 I/O 控制器的数据寄存器，便通过控制线给 CPU 发出一个中断信号，表示数据已准备好，然后等待 CPU 请求该数据。</li><li>I/O 控制器收到 CPU 发出的取数据请求后，将数据放到数据总线上，传到 CPU 的寄存器中。</li><li>至此，本次 I/O 操作完成，I/O 控制器又可开始下一次 I/O 操作。</li></ul></li><li><p><strong>从 CPU 的角度来看：</strong></p><ul><li>CPU 发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），转去执行其他程序。</li><li>在每个指令周期的末尾，CPU 检查中断。</li><li>当有来自 I/O 控制器的中断时，CPU 保存当前正在运行程序的上下文，转去执行中断处理程序处理该中断。这时，CPU 从 I/O 控制器读一个字的数据传送到寄存器，并存入主存。</li><li>接着， CPU 恢复发出 I/O 命令的程序（或其他程序）的上下文，然后继续运行。</li></ul></li></ul><h3 id=dma-方式-io>DMA 方式 I/O<a hidden class=anchor aria-hidden=true href=#dma-方式-io>#</a></h3><p>在中断驱动方式中，I/O 设备与内存之间的数据交换必须要经过 CPU 中的寄存器，所以速度还是受限，而 DMA（直接存储器存取）方式的基本思想是在 I/O 设备和内存之间开辟直接的数据交换通路，彻底“解放” CPU。</p><ul><li>DMA 方式的特点是：<ul><li>基本单位是数据块。</li><li>所传送的数据，是从设备直接送入内存的，或者相反。</li><li>仅在传送一个或多个数据块的开始和结束时，才需 CPU 干预，整块数据的传送是在 DMA 控制器的控制下完成的。</li></ul></li></ul><p>DMA 控制器的组成：</p><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221703905.png alt></p><ul><li><strong>为了实现在主机与控制器之间成块数据的直接交换，必须在 DMA 控制器中设置如下四类寄存器：</strong><ol><li>命令/状态寄存器(CR)：用于接收从 CPU 发来的 I/O 命令或有关控制信息，或设备的状态。</li><li>内存地址寄存器(MAR)：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li><li>数据寄存器(DR)：用于暂存从设备到内存，或从内存到设备的数据。</li><li>数据计数器(DC)：存放本次 CPU 要读或写的字（节）数。</li></ol></li></ul><p><strong>DMA 的工作过程：</strong></p><ul><li>CPU 读写数据时，它给 I/O 控制器发出一条命令，启动 DMA 控制器，然后继续其他工作。</li><li>之后 CPU 就把控制操作委托给 DMA 控制器，由该控制器负责处理。DMA 控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要 CPU 参与。</li><li>当传送完成后，DMA 控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要 CPU 的参与。</li></ul><p><strong>DMA 方式的最大优点和意义：</strong></p><ul><li><p>DMA 控制方式与中断驱动方式的主要区别是中断驱动方式在<strong>每个数据</strong>需要传输时中断 CPU，而 DMA 控制方式则是在所要求传送的<strong>一批数据</strong>全部传送结束时才中断 CPU；</p></li><li><p>此外，中断驱动方式数据传送是在中断处理时由<strong>CPU 控制完成</strong>的，而 DMA 控制方式则是在<strong>DMA 控制器</strong>的控制下完成的</p></li><li><p>DMA 重大的成功在于将中断的次数从打印每个字符一次减少到打印每个缓冲区一次。</p><ul><li>如果有许多字符并且中断十分缓慢，那么采用 DMA 可能是重要的改进。</li></ul></li><li><p>另一方面，DMA 比 CPU 慢很多，如果 DMA 控制器不能以全速驱动设备，或者 CPU 在等待 DMA 中断的同时没有其他事情要做，那么采用中断驱动 IO 甚至是程序控制 IO 也许更好</p></li></ul><h3 id=通道控制方式>通道控制方式<a hidden class=anchor aria-hidden=true href=#通道控制方式>#</a></h3><p><strong>I/O 通道是指专门负责输入/输出的处理机。</strong></p><p><strong>I/O 通道方式是 DMA 方式的发展，它可以进一步减少 CPU 的干预</strong>，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。同时，<strong>又可以实现 CPU、通道和 I/O 设备三者的并行操作</strong>，从而更有效地提高整个系统的资源利用率。</p><p><strong>通道控制实例</strong></p><ul><li>当 CPU 要完成一组相关的读（或写）操作及有关控制时，只需向 I/O 通道发送一条 I/O 指令，以给出其所要执行的通道程序的首地址和要访问的 I/O 设备<ul><li>通道接到该指令后，通过执行通道程序便可完成 CPU 指定的 I/O 任务，数据传送结束时向 CPU 发中断请求。</li></ul></li></ul><p><strong>通道的特点和优势</strong></p><ul><li><p>I/O 通道与一般处理机的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说<strong>通道与 CPU 共享内存</strong>。</p></li><li><p>I/O 通道与 DMA 方式的区别：</p><ul><li>DMA 方式需要 CPU 来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。</li><li>另外，每个 DMA 控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。</li></ul></li><li><p>CPU 只需发出 I/O 指令，通道完成相应的 I/O 操作，并在操作结束时向 CPU 发出中断信号；同时一个通道还能控制多台外设。</p></li><li><p>但是通道价格较高，从经济角度出发不宜过多使用。</p></li></ul><h2 id=io-软件层次>I/O 软件层次<a hidden class=anchor aria-hidden=true href=#io-软件层次>#</a></h2><p>I/O 软件涉及的面非常广，往下与硬件有着密切的联系，往上又与用户直接交互，它与进程管理、存储器管理、文件管理等都存在着一定的联系，即它们都可能需要 I/O 软件来实现 I/O 操作。</p><p>为了使复杂的 I/O 软件具有清晰的结构，良好的可移植性和适应性，在 I/O 软件中普遍釆用了层次式结构，将系统输入/输出功能组织成一系列的层次，每一层都利用其下层提供的服务，完成输入/输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。在层次式结构的 I/O 软件中，只要层次间的接口不变，对某一层次中的软件的修改都不会引起其下层或高层代码的变更，仅最底层才涉及硬件的具体特性。</p><table><thead><tr><th>I/O 软件系统层次</th></tr></thead><tbody><tr><td>用户级 IO 软件</td></tr><tr><td>与设备无关的操作系统软件/设备独立性软件</td></tr><tr><td>设备驱动程序</td></tr><tr><td>中断处理程序</td></tr><tr><td>硬件</td></tr></tbody></table><h3 id=用户层-io-软件>用户层 I/O 软件<a hidden class=anchor aria-hidden=true href=#用户层-io-软件>#</a></h3><p><strong>实现与用户交互的接口，用户可直接调用在用户层提供的、与 I/O 操作有关的库函数，对设备进行操作。</strong></p><ul><li><p>一般而言，大部分的 I/O 软件都在操作系统内部，但仍有一小部分在用户层，包括与用户程序链接在一起的库函数，以及完全运行于内核之外的一些程序。用户层软件必须通过一组系统调用来获取操作系统服务。</p></li><li><p>系统调用（包括 I/O 系统调用）通常由库过程实现。</p></li><li><p>并非所有的用户层 I/O 软件都是由库过程组成的。<strong>另一个重要的类别是[[假脱机系统]]。</strong></p><ul><li>假脱机(spooling)是多道程序设计系统中处理独占 I/O 设备的一种方法。考虑一种典型的假脱机设备：打印机。</li><li>尽管在技术上可以十分容易地让任何用户进程打开表示该打印机的字符特殊文件，但是假如一个进程打开它，然后很长时间不使用，则其他进程都无法打印。</li></ul></li><li><p>另一种方法是<strong>守护进程 daemon 以及假脱机目录</strong></p><ul><li>一个进程要打印一个文件时，首先生成要打印的整个文件，并且将其放在假脱机目录下。由守护进程打印该目录下的文件，该进程是允许使用打印机特殊文件的唯一进程。</li><li>通过保护特殊文件来防止用户直接使用，可以解决某些进程不必要地长期空占打印机的问题。</li></ul></li></ul><h3 id=设备独立性软件>设备独立性软件<a hidden class=anchor aria-hidden=true href=#设备独立性软件>#</a></h3><p><strong>用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护、以友设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。</strong></p><ul><li><p>设备独立性也称设备无关性，使得应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了<strong>逻辑设备和物理设备</strong>这两个概念。</p><ul><li>在应用程序中，使用逻辑设备名来请求使用某类设备；而在系统实际执行时，必须将逻辑设备名映射成物理设备名使用。</li></ul></li><li><p>使用逻辑设备名的好处是：</p><ul><li>增加设备分配的灵活性；</li><li>易于实现 I/O 重定向，所谓 I/O 重定向，是指用于 I/O 操作的设备可以更换（即重定向），而不必改变应用程序。</li></ul></li></ul><p>为了实现设备独立性，必须再在驱动程序之上设置一层设备独立性软件。总的来说，设备独立性软件的主要功能可分以为以下两个方面：</p><ul><li><strong>执行所有设备的公有操作</strong>。<ul><li>包括：对设备的分配与回收；将逻辑设备名映射为物理设备名；对设备进行保护，禁止用户直接访问设备；缓冲管理；差错控制；提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异。</li></ul></li><li><strong>向用户层（或文件层）提供统一接口</strong>。<ul><li>无论何种设备，它们向用户所提供的接口应该是相同的。例如，对各种设备的读/写操作，在应用程序中都统一使用 read/write 命令等。</li></ul></li></ul><h3 id=设备驱动程序>设备驱动程序<a hidden class=anchor aria-hidden=true href=#设备驱动程序>#</a></h3><p><strong>与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动 I/O 设备工作的驱动程序。</strong></p><ul><li>通常，每一类设备配置一个设备驱动程序，它是 I/O 进程与设备控制器之间的通信程序，常以进程形式存在。</li><li>设备驱动程序向上层用户程序提供一组标准接口，设备具体的差别被设备驱动程序所封装，用于接收上层软件发来的抽象 I/O 要求，如 read 和 write 命令，转换为具体要求后，发送给设备控制器，控制 I/O 设备工作；它也将由设备控制器发来的信号传送给上层软件。从而为 I/O 内核子系统隐藏设备控制器之间的差异。</li></ul><blockquote><p>设备寄存器的数量和命令的性质在不同设备之间有着根本性的不同。例如，鼠标驱动程序必须从鼠标接收信息，以识别鼠标移动了多远的距离以及当前哪一个键被按下。相反，磁盘驱动程序可能必须要了解扇区、磁道、柱面、磁头、磁盘臂移动、电机驱动器、磁头定位时间以及所有其他保证磁盘正常工作的机制。</p></blockquote><ul><li><p><strong>设备驱动程序 device driver</strong></p><ul><li><strong>每个连接到计算机上的 IO 设备都需要某些特定的代码来对其进行控制——即设备驱动程序</strong></li><li>每一个操作系统都需要自己的驱动程序，所以设备制造商通常要为若干流行的操作系统提供驱动程序。</li><li>每个设备驱动程序通常处理一种类型的设备,或者至多处理一类紧密相关的设备。</li></ul></li><li><p>为了访问设备的硬件（意味着访问设备控制器的寄存器），设备驱动程序通常必须是操作系统内核的一部分，至少对目前的体系结构是如此。</p></li></ul><p><strong>驱动程序的分类</strong></p><ul><li><p>块设备——最通用的类别</p><ul><li>包含多个可以独立寻址的数据块</li></ul></li><li><p>字符设备</p><ul><li>字符设备例如键盘和打印机则生成或接收字符流</li></ul></li><li><p><strong>驱动程序不允许进行系统调用，但是它们经常需要与内核的其余部分进行交互。对某些内核过程的调用通常是允许的。</strong> 例如，通常需要调用内核过程来分配和释放硬接线的内存页面作为缓冲区。还可能需要其他有用的调用来管理 MMU、定时器、DMA 控制器、中断控制器等。</p></li></ul><h3 id=中断处理程序>中断处理程序<a hidden class=anchor aria-hidden=true href=#中断处理程序>#</a></h3><p><strong>用于保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完并恢复被中断进程的现场后，返回到被中断进程。</strong></p><ul><li><p>将发生中断的驱动程序阻塞起来，直到 IO 操作完成并产生一个中断。</p></li><li><p>驱动程序可以阻塞自己</p></li><li><p><strong>中断处理层的主要任务有：</strong></p><ul><li>进行进程上下文的切换</li><li>对处理中断信号源进行测试</li><li>读取设备状态和修改进程状态等。</li></ul></li><li><p>由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，故应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。</p></li><li><p><strong>中断发生时的情况分析</strong></p><ul><li>当中断发生时，中断处理程序要完成全部工作，以实现对中断的处理</li><li>然后，它可以启动中断的驱动程序接触阻塞<ul><li>可能其只是在一个信号量上执行操作</li><li>可能是对管程中的条件变量执行操作</li></ul></li><li>中断的最终结果是使先前被阻塞的驱动程序现在能够继续运行。</li></ul></li><li><p>中断时中断处理程序的详细任务</p><ul><li>1)保存没有被中断硬件保存的所有寄存器（包括 PSW)。</li><li>2)为中断服务过程设置上下文，可能包括设置 TLB、MMU 和页表。</li><li>3)为中断服务过程设置堆栈。</li><li>4)应答中断控制器，如果不存在集中的中断控制器，则再次开放中断。</li><li>5)将寄存器从它们被保存的地方（可能是某个堆栈）复制到进程表中。</li><li>6)运行中断服务过程，从发出中断的设备控制器的寄存器中提取信息。</li><li>7)选择下一次运行哪个进程，如果中断导致某个被阻塞的高优先级进程变为就绪，则可能选择它现在就运行。</li><li>8)为下一次要运行的进程设置 MMU 上下文，也许还需要设置某个 TLB。</li><li>9)装入新进程的寄存器，包括其 PSW。</li><li>10)开始运行新进程。</li></ul></li></ul><h3 id=硬件设备>硬件设备<a hidden class=anchor aria-hidden=true href=#硬件设备>#</a></h3><p>I/O 设备通常包括一个机械部件和一个电子部件。为了达到设计的模块性和通用性，一般将其分开：电子部件称为设备控制器（或适配器），在个人计算机中，通常是一块插入主板扩充槽的印刷电路板；机械部件则是设备本身。</p><p>详情见上文硬件部分的[[#设备控制器]]</p><h1 id=磁盘的组织与管理>磁盘的组织与管理<a hidden class=anchor aria-hidden=true href=#磁盘的组织与管理>#</a></h1><h2 id=磁盘结构>磁盘结构<a hidden class=anchor aria-hidden=true href=#磁盘结构>#</a></h2><p><strong>磁盘(Disk)是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为磁头 的导体线圈从磁盘中存取数据。</strong></p><ul><li>在读/写操作期间，磁头固定，磁盘在下面高速旋转。</li><li>磁盘的盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽, 一个盘面有上千个磁道。磁道又划分为几百个扇区，每个扇区固定存储大小（通常为 512B), 一个扇区称为一个盘块。相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。</li></ul><p>注意，由于扇区按固定圆心角度划分，所以密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。</p><ul><li>磁盘安装在一个磁盘驱动器中，它由磁头臂、用于旋转磁盘的主轴和用于数据输入/输 出的电子设备组成。<ul><li>多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同且一起移动。</li><li>所有盘片上相对位置相同 的磁道组成柱面。按照这种物理结构组织，扇区就是磁盘可寻址的最小存储单位，磁盘地址 用“柱面号 • 盘面号 • 扇区号（或块号）”表示。</li></ul></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207232013804.png alt></p><ul><li>磁盘按不同方式可以分为若干类型：<ul><li>磁头相对于盘片的径向方向固定的称为固定头磁盘，每个磁道一个磁头；</li><li>磁头可移动的称为活动头磁盘，磁头臂可以来回伸缩定位磁道。</li><li>磁盘永久固定在磁盘驱动器内的称为固定盘磁盘；</li><li>可移动和替换的称为可换盘磁盘。</li></ul></li></ul><h2 id=磁盘调度算法>磁盘调度算法<a hidden class=anchor aria-hidden=true href=#磁盘调度算法>#</a></h2><p><strong>一次磁盘读写操作的时间由寻找（寻道）时间、延迟时间和传输时间决定</strong></p><p><strong>一次磁盘读写操作需要的时间</strong></p><ul><li>寻道时间：<ul><li>启动磁头臂消耗的时间：s。</li><li>移动磁头消耗的时间：假设磁头匀速移动，每跨越一个磁道消耗时间为 m，共跨越 n 条磁道。</li></ul></li></ul><p><a href=https://www.jianshu.com/p/3c2b79af130b>磁盘调度算法</a></p><h3 id=fcfs-先来先服务>FCFS 先来先服务<a hidden class=anchor aria-hidden=true href=#fcfs-先来先服务>#</a></h3><ul><li>算法思想：<strong>根据进程请求访问磁盘的先后顺序进行调度。</strong></li></ul><pre tabindex=0><code> 假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。  
  按照先来先服务算法规则，按照请求到达的顺序，磁头需要一次移动到55、58、39、18、90、160、150、38、184号磁道。
  
  磁头共移动了 45 + 3 + 19 + 21 + 72 + 70 + 10 + 112 + 146 = 498个磁道。响应一个请求平均需要移动498 / 9 = 55.3个磁道（平均寻找长度）。
</code></pre><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202208041438792.png alt></p><ul><li>优缺点分析：<ul><li>优点：<strong>公平；如果请求访问的磁道比较集中的话，算法性能还算可以</strong>。</li><li>缺点：<strong>如果大量进程竞争使用磁盘，请求访问的磁道很分散，FCFS 在性能上很差，寻道时间长</strong>。</li></ul></li></ul><h3 id=sstf-最短寻道时间>SSTF 最短寻道时间<a hidden class=anchor aria-hidden=true href=#sstf-最短寻道时间>#</a></h3><ul><li>算法思想：<strong>优先处理的磁道是与当前磁头最近的磁道。可以保证每次寻道时间最短，但是不能保证总的寻道时间最短</strong>。（其实是贪心算法的思想，只是选择眼前最优，但是总体未必最优）。</li></ul><pre tabindex=0><code> 假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。
 
 磁头总共移动了（100 -18）+ （184 -18） = 248个磁道。响应一个请求平均需要移动248 / 9 = 27.5个磁道（平均寻找长度）。
</code></pre><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202208041446459.png alt></p><ul><li>最大的缺点：<strong>可能产生饥饿现象</strong>。<ul><li>这里产生饥饿的原因是<strong>磁头在一小块区域来回移动。</strong></li></ul></li></ul><h3 id=scan-电梯调度算法>SCAN 电梯调度算法<a hidden class=anchor aria-hidden=true href=#scan-电梯调度算法>#</a></h3><ul><li>SSTF 算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</li><li>为了防止这个问题，可以规定：<strong>磁头只有移动到请求最外侧磁道或最内侧磁道才可以反向移动，如果在磁头移动的方向上已经没有请求，就可以立即改变磁头移动，不必移动到最内/外侧的磁道。</strong> 这就是扫描算法的思想。由于磁头移动的方式很像电梯，因此也叫<strong>电梯算法</strong>。</li></ul><pre tabindex=0><code>假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的访问55、58、39、18、90、160、150、38、184号磁道。

  磁头共移动了（184 - 100）+ （184 -18） = 250个磁道。响应一个请求平均需要移动 250 / 9 = 27.5个磁道（平均寻找长度）。
</code></pre><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202208041442136.png alt></p><ul><li><strong>优缺点分析：</strong><ul><li>优点：<strong>性能较好，寻道时间较短，不会产生饥饿现象。</strong></li><li>缺点：<strong>SCAN 算法对于各个位置磁道的响应频率不平均</strong>。（假设此时磁头正在往右移动，且刚处理过 90 号磁道，那么下次处理 90 号磁道的请求就需要等待低头移动很长一段距离；而响应了 184 号磁道的请求之后，很快又可以再次响应 184 号磁道请求了。）</li></ul></li></ul><h3 id=c-scan-循环扫描算法>C-SCAN 循环扫描算法<a hidden class=anchor aria-hidden=true href=#c-scan-循环扫描算法>#</a></h3><ul><li>SCAN 算法对各个位置磁道的响应频率不平均，而 C-SCAN 算法就是为了解决这个问题。</li><li>规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<strong>返回时直接快速移动至最靠边缘的并且需要访问的磁道上而不处理任何请求。</strong></li><li>通俗理解就是 SCAN 算在改变磁头方向时不处理磁盘访问请求而是直接移动到另一端最靠边的磁盘访问请求的磁道上。</li></ul><pre tabindex=0><code>假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的访问55、58、39、18、90、160、150、38、184号磁道。

磁头共移动了（184 -100）+ （184 - 18）+（90 - 18）=322个磁道。响应一个请求平均需要移动322 / 9 = 35.8个磁道（平均寻找长度）。
</code></pre><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202208041444055.png alt></p><ul><li><strong>优缺点分析</strong><ul><li>优点：<strong>相比于 SCAN 算法，对于各个位置磁道响应频率很平均。</strong></li><li>缺点：<strong>相比于 SCAN 算法，平均寻道时间更长。</strong></li></ul></li></ul><h2 id=磁盘管理>磁盘管理<a hidden class=anchor aria-hidden=true href=#磁盘管理>#</a></h2><p><strong>磁盘初始化</strong></p><ul><li>一个新的磁盘只是一个含有磁性记录材料的空白盘。在磁盘能存储数据之前，它必须分成扇区以便磁盘控制器能进行读和写操作，这个过程称为低级格式化（物理分区）。低级格式化为磁盘的每个扇区釆用特别的数据结构。每个扇区的数据结构通常由头、数据区域（通常为 512B 大小）和尾部组成。头部和尾部包含了一些磁盘控制器所使用的信息。</li><li>为了使用磁盘存储文件，操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为由一个或多个柱面组成的分区（即我们熟悉的 C 盘、D 盘等形式的分区）；第二步对物理分区进行逻辑格式化（创建文件系统)，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。</li></ul><p><strong>引导块</strong></p><ul><li>计算机启动时需要运行一个初始化程序（自举程序），它初始化 CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，该自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，从而开始操作系统的运行。</li><li>自举程序通常保存在 ROM 中，为了避免改变自举代码需要改变 ROM 硬件的问题，故只在 ROM 中保留很小的自举装入程序，将完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位。拥有启动分区的磁盘称为启动磁盘或者系统磁盘。</li></ul><p><strong>坏块</strong></p><ul><li>由于磁盘有移动部件且容错能力弱，所以容易导致一个或多个扇区损坏。部分磁盘甚至从出厂时就有坏扇区。根据所使用的磁盘和控制器，对这些块有多种处理方式。</li><li>对于简单磁盘，如电子集成驱动器（IDE)。坏扇区可手工处理，如 MS-DOS 的 Format 命令执行逻辑格式化时便会扫描磁盘以检查坏扇区。坏扇区在 FAT 表上会标明，因此程序不会使用。</li><li>对于复杂的磁盘，如小型计算机系统接口（SCSI)，其控制器维护一个磁盘坏块链表。该链表在出厂前进行低级格式化时就初始化了，并在磁盘的整个使用过程中不断更新。低级格式化将一些块保留作为备用，对操作系统透明。控制器可以用备用块来逻辑地替代坏块，这种方案称为扇区备用。</li></ul><h1 id=io-子系统>I/O 子系统<a hidden class=anchor aria-hidden=true href=#io-子系统>#</a></h1><p><strong>由于 I/O 设备种类繁多，功能和传输速率差异巨大，需要多种方法来进行设备控制。这些方法共同组成了操作系统内核的 I/O 子系统</strong></p><ul><li>它将内核的其他方面从繁重的 I/O 设备管理中解放出来。I/O 核心子系统提供的服务主要有 I/O 调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等。</li></ul><h2 id=io-调度>I/O 调度<a hidden class=anchor aria-hidden=true href=#io-调度>#</a></h2><ul><li><strong>I/O 调度就是确定一个好的顺序来执行这些 I/O 请求。</strong><ul><li>应用程序所发布的系统调用的顺序不一定总是最佳选择，所以需要 I/O 调度来改善系统整体性能，使进程之间公平地共享设备访问，减少 I/O 完成所需要的平均等待时间。</li></ul></li><li><strong>操作系统开发人员通过为每个设备维护一个请求队列来实现调度。</strong><ul><li>当一个应用程序执行阻塞 I/O 系统调用时，该请求就加到相应设备的队列上。I/O 调度会重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间。</li></ul></li></ul><p>I/O 子系统还可以使用主存或磁盘上的存储空间的技术，如缓冲、高速缓冲、假脱机等，来改善计算机效率。</p><h2 id=高速缓存>高速缓存<a hidden class=anchor aria-hidden=true href=#高速缓存>#</a></h2><ul><li>操作系统中使用磁盘高速缓存技术来提高磁盘的 I/O 速度，对高速缓存复制的访问要比原始数据访问更为高效。<ul><li>例如，正在运行的进程的指令既存储在磁盘上，也存储在物理内存上，也被复制到 CPU 的二级和一级高速缓存中。</li></ul></li></ul><p>不过，磁盘高速缓存技术不同于通常意义下的介于 CPU 与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。<strong>因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</strong></p><ul><li>高速缓存在内存中分为两种形式：<ul><li>一种是在内存中开辟一个单独的存储空间作为磁速缓存，大小固定；</li><li>另一种是把未利用的内存空间作为一个缓沖池，供请求分页系统和磁盘 I/O 时共享。</li></ul></li></ul><h2 id=缓冲区-buffer>缓冲区 Buffer<a hidden class=anchor aria-hidden=true href=#缓冲区-buffer>#</a></h2><ul><li><p>在设备管理子系统中，引入缓冲区的目的主要有：</p><ul><li>缓和 CPU 与 I/O 设备间速度不匹配的矛盾。</li><li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。</li><li>解决基本数据单元大小（即数据粒度）不匹配的问题。</li><li>提高 CPU 和 I/O 设备之间的并行性。</li></ul></li><li><p>其实现方法有：</p><ul><li>釆用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不釆用硬件缓冲器</li><li>釆用缓冲区（位于内存区域）。</li></ul></li></ul><h3 id=单缓冲>单缓冲<a hidden class=anchor aria-hidden=true href=#单缓冲>#</a></h3><p><strong>在设备和处理机之间设置一个缓冲区。设备和处理机交换数据时，先把被交换数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据。</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221703592.png alt></p><blockquote><p>如图所示，在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为 T，操作系统将该缓冲区中的数据传送到用户区的时间为 M，而 CPU 对这一块数据处理的时间为 C。由于 T 和 C 是可以并行的，当 T>C 时，系统对每一块数据的处理时间为 M+T，反之则为 M+C，故可把系统对每一块数据的处理时间表示为 Max(C, T)+M。</p></blockquote><h3 id=双缓冲>双缓冲<a hidden class=anchor aria-hidden=true href=#双缓冲>#</a></h3><p><strong>根据单缓冲的特点，CPU 在传送时间 M 内处于空闲状态，由此引入双缓冲。</strong></p><ul><li>I/O 设备输入数据时先装填到缓冲区 1，在缓冲区 1 填满后才开始装填缓冲区 2，与此同时处理机可以从缓冲区 1 中取出数据放入用户进程处理，当缓冲区 1 中的数据处理完后，若缓冲区 2 已填满，则处理机又从缓冲区 2 中取出数据放入用户进程处理，而 I/O 设备又可以装填缓冲区 1。</li><li><strong>双缓冲机制提高了处理机和输入设备的并行操作的程度。</strong></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221704701.png alt></p><blockquote><p>如图 5-6 所示，系统处理一块数据的时间可以粗略地认为是 MAC(C, T)。如果 C&lt;T，可使块设备连续输入（图中所示情况)；如果 C>T，则可使 CPU 不必等待设备输入。对于字符设备，若釆用行输入方式，则釆用双缓冲可使用户在输入完第一行之后，在 CPU 执行第一行中的命令的同时，用户可继续向第二缓冲区输入下一行数据。而单缓冲情况下则必须等待一行数据被提取完毕才可输入下一行的数据。</p></blockquote><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221704077.png alt></p><blockquote><p>如果两台机器之间通信仅配置了单缓冲，如图 5-7(a)所示。那么，它们在任一时刻都只能实现单方向的数据传输。例如，只允许把数据从 A 机传送到 B 机，或者从 B 机传送到 A 机，而绝不允许双方同时向对方发送数据。为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用做发送缓冲区，另一个用做接收缓冲区，如图 5-7(b)所示。</p></blockquote><h3 id=循环缓冲>循环缓冲<a hidden class=anchor aria-hidden=true href=#循环缓冲>#</a></h3><p><strong>包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。</strong></p><ul><li><p>循环缓冲用于输入/输出时，还需要有两个指针 in 和 out。</p><ul><li>对输入而言，首先要从设备接收数据到缓冲区中，in 指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out 指针指向可以提取数据的第一个满缓冲区。</li><li>输出则正好相反。</li></ul></li><li><p>缓冲的另一种常用形式是循环缓冲区(circular buffer)。</p><ul><li>它由一个内存区域和两个指针组成。一个指针指向下一个空闲的字，新的数据可以放置到此处。另一个指针指向缓冲区中数据的第一个字，该字尚未被取走。</li><li>在许多情况下，当添加新的数据时（例如刚刚从网络到来），硬件将推进第一个指针，而操作系统在取走并处理数据时推进第二个指针。两个指针都是环绕的，当它们到达顶部时将回到底部。</li><li>类似于[[3 数据链路层#Sliding Window Protocol|数据链路层的滑动窗口协议]]</li></ul></li></ul><h3 id=缓冲池>缓冲池<a hidden class=anchor aria-hidden=true href=#缓冲池>#</a></h3><p><strong>由多个系统公用的缓冲区组成</strong></p><ul><li>缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列（输入队列）和装满输出数据的缓沖队列（输出队列）。</li><li>还应具有四种缓冲区：用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、 用于收容输出数据的工作缓冲区及用于提取输出数据的工作缓冲区，如图 5-8 所示。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221704052.png alt></p><p><strong>四种主要缓冲区的使用</strong></p><ul><li>当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。</li><li>当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。</li><li>当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。</li><li>当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。</li></ul><hr><p><strong>高速缓存与缓冲区的对比：</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221646243.png alt></p><h2 id=设备分配与回收>设备分配与回收<a hidden class=anchor aria-hidden=true href=#设备分配与回收>#</a></h2><p>设备分配是指根据用户的 I/O 请求分配所需的设备。</p><ul><li>分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。</li><li>从设备的特性来看，釆用下述三种使用方式的设备分别称为独占设备、共享设备和虚拟设备三类。<ol><li>独占式使用设备。指在申请设备时，如果设备空闲，就将其独占，不再允许其他进程申请使用，一直等到该设备被释放才允许其他进程申请使用。例如，打印机，在使用它打印时，只能独占式使用，否则在同一张纸上交替打印不同任务的内容，无法正常阅读。</li><li>分时式共享使用设备。独占式使用设备时，设备利用率很低，当设备没有独占使用的要求时，可以通过分时共享使用，提高利用率。例如，对磁盘设备的 I/O 操作，各进程的每次 I/O 操作请求可以通过分时来交替进行。</li><li>以 SPOOLing 方式使用外部设备。SPOOLing 技术是在批处理操作系统时代引入的，即假脱机 I/O 技术。这种技术用于对设备的操作，实质上就是对 I/O 操作进行批处理。</li></ol></li></ul><h3 id=设备分配的数据结构>设备分配的数据结构<a hidden class=anchor aria-hidden=true href=#设备分配的数据结构>#</a></h3><p>设备分配依据的主要数据结构有设备控制表(DCT)、控制器控制表(COCT)、通道控制表(CHCT)和系统设备表(SDT)，各数据结构功能如下：</p><ul><li><strong>设备控制表 DCT</strong>：系统为每一个设备配置一张 DCT<ul><li>它用于记录设备的特性以及与 I/O 控制器连接的情况。</li><li>DCT 包括设备标识符、设备类型、设备状态、指向控制器控制表 COCT 的指针等。其中，设备状态指示设备是忙还是空闲，设备队列指针指向等待使用该设备的进程组成的等待队列，控制表指针指向与该设备相连接的设备控制器。</li></ul></li><li><strong>控制器控制表 COCT</strong>：每个控制器都配有一张 COCT<ul><li>它反映设备控制器的使用状态以及和通道的连接情况等。</li></ul></li><li><strong>通道控制表 CHCT</strong>：每个通道配有一张 CHCT</li><li><strong>系统设备表 SDT</strong>：整个系统只有一张 SDT<ul><li>它记录已连接到系统中的所有物理设备的情况，每个物理设备占一个表目。</li></ul></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221705278.png alt></p><ul><li>由于在多道程序系统中，进程数多于资源数，会引起资源的竞争。因此，要有一套合理的分配原则，主要考虑的因素有：<ul><li>I/O 设备的固有属性</li><li>I/O 设备的分配算法</li><li>设备分配的安全性</li><li>设备独立性。</li></ul></li></ul><h3 id=设备分配策略>设备分配策略<a hidden class=anchor aria-hidden=true href=#设备分配策略>#</a></h3><p><strong>设备分配原则：</strong></p><ul><li>设备分配应根据设备特性、用户要求和系统配置情况。分配的总原则既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。</li></ul><p><strong>设备分配方式：设备分配方式有静态分配和动态分配两种。</strong></p><ul><li>静态分配主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器（和通道)。一旦分配后，这些设备、控制器（和通道）就一直为该作业所占用，直到该作业被撤销。静态分配方式不会出现死锁，但设备的使用效率低。因此，静态分配方式弁不符合分配的总原则。</li><li>动态分配是在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需要的设备、I/O 控制器，一旦用完之后，便立即释放。动态分配方式有利于提高设备的利用率，但如果分配算法使用不当，则有可能造成进程死锁。</li></ul><p><strong>设备分配算法：常用的动态设备分配算法有先请求先分配、优先级高者优先等。</strong></p><ul><li>对于独占设备，既可以釆用动态分配方式也可以静态分配方式，往往釆用静态分配方式，即在作业执行前，将作业所要用的这一类设备分配给它。</li><li>共享设备可被多个进程所共享，一般釆用动态分配方式，但在每个 I/O 传输的单位时间内只被一个进程所占有，通常釆用先请求先分配和优先级高者先分的分配算法。</li></ul><h3 id=设备分配安全性>设备分配安全性<a hidden class=anchor aria-hidden=true href=#设备分配安全性>#</a></h3><p><strong>设备分配的安全性是指设备分配中应防止发生进程死锁。</strong></p><ol><li><p>安全分配方式：<strong>每当进程发出 I/O 请求后便进入阻塞状态，直到其 I/O 操作完成时才被唤醒</strong>。这样，一旦进程已经获得某种设备后便阻塞，不能再请求任何资源，而且在它阻塞时也不保持任何资源。i 点是设备分配安全；缺点是 CPU 和 I/O 设备是串行工作的（对同一进程而言)。</p></li><li><p>不安全分配方式：<strong>进程在发出 I/O 请求后继续运行，需要时又发出第二个、第三个 I/O 请求等</strong>。仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。优点是一个进程可同时操作多个设备，从而使进程推进迅速；缺点是这种设备分配有可能产生死锁。</p></li></ol><h3 id=逻辑设备名到物理设备名的映射>逻辑设备名到物理设备名的映射<a hidden class=anchor aria-hidden=true href=#逻辑设备名到物理设备名的映射>#</a></h3><p><strong>为了提高设备分配的灵活性和设备的利用率、方便实现 I/O 重定向，因此引入了设备独立性。设备独立性是指应用程序独立于具体使用的物理设备。</strong></p><ul><li><p>为了实现设备独立性，在应用程序中使用逻辑设备名来请求使用某类设备，在系统中设置一张逻辑设备表(Logical Unit Table, LUT)，用于将逻辑设备名映射为物理设备名。</p><ul><li>LUT 表项包括逻辑设备名、物理设备名和设备驱动程序入口地址；当进程用逻辑设备名来请求分配设备时，系统为它分配相应的物理设备，并在 LUT 中建立一个表项，以后进程再利用逻辑设备名请求 I/0 操作时，系统通过查找 LUT 来寻找相应的物理设备和驱动程序。</li></ul></li><li><p>在系统中可釆取两种方式建立逻辑设备表：</p><ul><li>在整个系统中只设置一张 LUT。这样，所有进程的设备分配情况都记录在这张表中，故不允许有相同的逻辑设备名，主要适用于单用户系统中。</li><li>为每个用户设置一张 LUT。当用户登录时，系统便为该用户建立一个进程，同时也为之建立一张 LUT，并将该表放入进程的 PCB 中。</li></ul></li></ul><h2 id=spooling-技术>SPOOLing 技术<a hidden class=anchor aria-hidden=true href=#spooling-技术>#</a></h2><p>为了缓和 CPU 的高速性与 I/O 设备低速性之间的矛盾而引入了脱机输入/输出技术。该技术是利用专门的外围控制机，将低速 I/O 设备上的数据传送到高速磁盘上；或者相反。</p><p><strong>SPOOLing 的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，是操作系统中釆 用的一项将独占设备改造成共享设备的技术。</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207221705888.png alt></p><h3 id=输入井和输出井>输入井和输出井<a hidden class=anchor aria-hidden=true href=#输入井和输出井>#</a></h3><p>在<strong>磁盘上</strong>开辟出的两个存储区域。</p><ul><li>输入井模拟脱机输入时的磁盘，用于收容 I/O 设备输入的数据。</li><li>输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。</li></ul><h3 id=输入缓冲区和输出缓冲区>输入缓冲区和输出缓冲区<a hidden class=anchor aria-hidden=true href=#输入缓冲区和输出缓冲区>#</a></h3><p>在<strong>内存中</strong>开辟的两个缓冲区。</p><ul><li>输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。</li><li>输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。</li></ul><h3 id=输入进程和输出进程>输入进程和输出进程<a hidden class=anchor aria-hidden=true href=#输入进程和输出进程>#</a></h3><ul><li>输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。<ul><li>当 CPU 需要输入数据时，直接将数据从输入井读入内存。</li></ul></li><li>输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出并，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备。</li></ul><p><strong>SPOOLing 技术实例</strong></p><ul><li>共享打印机是使用 SPOOLing 技术的一个实例，这项技术已被广泛地用于多用户系统和 局域网络中。当用户进程请求打印输出时，SPOOLing 系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程，而只为它做两件事：<ul><li>由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中。</li><li>输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。</li></ul></li></ul><p><em><strong>SPOOLing 系统的主要特点有：提高了 I/O 的速度；将独占设备改造为共享设备；实现了虚拟设备功能。</strong></em></p><h1 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h1><table><thead><tr><th>层次</th><th>I/O 功能</th></tr></thead><tbody><tr><td>用户进程</td><td>产生 I/O 请求；对 I/O 进行格式化；假脱机</td></tr><tr><td>与设备无关的软件</td><td>命名、保护、分块、缓冲、分配</td></tr><tr><td>设备驱动程序</td><td>设置设备寄存器；检查状态</td></tr><tr><td>中断处理程序</td><td>当 I/O 完成时唤醒驱动程序</td></tr><tr><td>硬件</td><td>执行 I/O 操作</td></tr></tbody></table><ul><li>I/O 请求由上至下，而 I/O 应答由下至上。这非常类似于[[1 引言#OSI 参考模型|OSI 参考模型]]的整个栈层次构成</li></ul><blockquote><p>当一个用户程序试图从一个文件中读一个块时，操作系统被调用以实现这一请求。</p><p>与设备无关的软件在缓冲区高速缓存中查找有无要读的块。如果需要的块不在其中， 则调用设备驱动程序，向硬件发出一个请求，让它从磁盘中获取该块。然后，进程被阻塞直到磁盘操作完成并且数据在调用者的缓冲区中安全可用。</p></blockquote><blockquote><p>当磁盘操作完成时，硬件产生一个中断。中断处理程序就会运行，它要查明发生了什么事情，也就是说此刻需要关注哪个设备。然后，中断处理程序从设备提取状态信息，唤醒休眠的进程以结束此次 I/O 请求，并且让用户进程继续运行。</p></blockquote><p><a href=http://c.biancheng.net/cpp/u/xitong_5/>操作系统输入/输出(I/O)管理_C 语言中文网</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/learning/>Learning</a></li><li><a href=/tags/notes/>Notes</a></li><li><a href=/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=/post/reading/readingsum_2022w40/><span class=title>« Prev</span><br><span>WeeklyReadingSum_2022W40</span></a>
<a class=next href=/post/tech/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/o4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/><span class=title>Next »</span><br><span>O4-文件系统</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share O5-IO系统 on twitter" href="https://twitter.com/intent/tweet/?text=O5-IO%e7%b3%bb%e7%bb%9f&url=%2fpost%2ftech%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%25AC%2594%25E8%25AE%25B0%2fo5-io%25E7%25B3%25BB%25E7%25BB%259F%2f&hashtags=Learning%2cNotes%2cOS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share O5-IO系统 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fpost%2ftech%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%25AC%2594%25E8%25AE%25B0%2fo5-io%25E7%25B3%25BB%25E7%25BB%259F%2f&title=O5-IO%e7%b3%bb%e7%bb%9f&summary=O5-IO%e7%b3%bb%e7%bb%9f&source=%2fpost%2ftech%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%25AC%2594%25E8%25AE%25B0%2fo5-io%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share O5-IO系统 on reddit" href="https://reddit.com/submit?url=%2fpost%2ftech%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%25AC%2594%25E8%25AE%25B0%2fo5-io%25E7%25B3%25BB%25E7%25BB%259F%2f&title=O5-IO%e7%b3%bb%e7%bb%9f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share O5-IO系统 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fpost%2ftech%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%25AC%2594%25E8%25AE%25B0%2fo5-io%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share O5-IO系统 on whatsapp" href="https://api.whatsapp.com/send?text=O5-IO%e7%b3%bb%e7%bb%9f%20-%20%2fpost%2ftech%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%25AC%2594%25E8%25AE%25B0%2fo5-io%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share O5-IO系统 on telegram" href="https://telegram.me/share/url?text=O5-IO%e7%b3%bb%e7%bb%9f&url=%2fpost%2ftech%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E7%25AC%2594%25E8%25AE%25B0%2fo5-io%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href>Caesar's Paperbox</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>