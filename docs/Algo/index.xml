<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>📦 Caesar&#39;s Paperbox</title>
    <link>https://caesaryangs.github.io/docs/Algo/</link>
    <description>Recent content on 📦 Caesar&#39;s Paperbox</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://caesaryangs.github.io/docs/Algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/0-Asymptopic-Analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/0-Asymptopic-Analysis/</guid>
      <description>算法复杂度 ─ 直观定义&#xA;算法复杂度是算法运行所需要的计算机资源的量，需要时间资源的量称为时 间复杂性，需要的空间资源的量称为 空间复杂性&#xA;时间复杂度和空间复杂度是只依赖于算法求解的问题规模和算法输入的函数 𝑁、𝐼 分别表示算法求解的问题规模和算法输入，则算法的时间复杂度𝑇和空 间复杂度𝑆可以分别表示为: 𝑇 = 𝑇(𝑁, 𝐼) 𝑆 = 𝑆(𝑁, 𝐼) 算法复杂度分析 ─ 指令抽象&#xA;T(N, I) 表示特定算法在一台抽象的计算机上运行所需要的时间&#xA;K 个元运算，O1, O2, &amp;hellip;, Ok, 运行一次所需时间为 t1, t2, &amp;hellip;, tk; 统计 Oi 的调用次数为 ei，ei = ei(N, I); 因此，T(N, I) = ∑tiei(N, I)。 归纳逻辑: 从个别到一般 T(N) 的表达式比较复杂，需合理的简化!&#xA;对于算法 A 的复杂度函数𝑇(𝑁)，如果存在𝑇′(𝑁) ，使得当𝑁 → ∞时有 (𝑇𝑁 −𝑇′(𝑁))⁄𝑇(𝑁)→0，那么就称𝑇′(𝑁) 为算法 A 当𝑁→∞的渐近复杂性&#xA;𝑇′(𝑁) 是𝑇(𝑁) 略去低阶项所留下的主项，表达简单 如果两个算法的渐近复杂性的阶不相同，那么只要确定出各自的阶就可以判断哪一个算法效率高 阶跟𝑇′(𝑁) 中的常数因子没有关系，𝑇′(𝑁) 可进一步简化，省略常数因子 时间复杂度的记号包括:O Ω Θ</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/1-E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/1-E/</guid>
      <description>Theory&amp;amp;Thinkings # 为什么要用枚举？ 解准确且全面 实现简单，通过循环或递归实现 执行效率提升空间通常较大 具体方法：&#xA;枚举对象 枚举过程 验证解 不是所有问题都有巧妙的解决方案，没有想到就要进一步做优化，对于枚举来说：压缩枚举空间。&#xA;枚举算法&#xA;也称之为穷举算法，就是按照问题本身的性质，一 一列举出该问题所有可能的解， 并在列举的过程中，逐一检验每个可能解是否是问题的真正解。若是则采纳这个解; 否则抛弃它。&#xA;不能遗漏，否则可能导致结果不正确 不要重复，否则可能导致效率比较低 枚举算法设计步骤&#xA;确定枚举对象 枚举对象也可以理解为是问题解的表达形式，一般需要 用若干参数 (p1, p2, &amp;hellip;&amp;hellip;, pk) 来描述 参数之间需要相互独立，而且参数数目越少，问题解搜索空间的维度也相应地小 每个参数的取值范围越小，问题解的搜索空间也越小 优化模型 针对问题特征，优化对象模型 逐一列举可能解 根据枚举对象的参数构造循环 (也可以递归)，一一 列举其表达式的每一种取值情况。 优化过程 针对对象特征，优化列举和验证过程 逐一验证可能解 根据问题解的要求，一一验证枚举对象表达式的每一 个取值，如果满足条件，则采纳它; 否则，抛弃之。 e.g.s # 数组配对 # 给你一个长度为n的数组A和一个正整数k，问从数组中任选两个数使其和是k的倍数，有多少种选法？对于数组 a1=1 , a2=2 , a3=2 而言： (a1,a2) 和 (a2,a1)被认为是同一种选法； (a1,a2) 和 (a1,a3)被认为是不同的选法。 朴素方法 枚举对象：𝑂𝑏𝑗(𝑎𝑖,𝑎𝑗),1≤ 𝑖 &amp;lt; 𝑗≤ 𝑛 逐一列举 逐一验证 存在问题：时间复杂度较高：𝑂(𝑛2) 如果问题规模较大，求解问题需要的时间也呈指数级别增长 尝试改进：如何减少问题空间？如何更加有效的枚举？ 利用桶思路，将原问题之间用 mod 运算降低到一个非常低的解空间中再进行枚举 枚举对象：𝑂𝑏𝑗(𝑎𝑖,𝑎𝑗),1≤ 𝑖 &amp;lt; 𝑗≤ 𝑛 逐一列举： 预处理： (𝑎𝑖 + 𝑎𝑗)%𝑘 = 0 逐一验证：(𝑎𝑖%𝑘 + 𝑎𝑗%𝑘)%𝑘 = 0 求解细节： 会变成两个单独数字的配对问题，存在两种情况 两个数字在同一桶内：组合数公式 两数字不在同一桶内：直接相乘，相当于组合公式 void work() { LL ans = 0; for (int i = 0; i &amp;lt; k; i++) { int j = (k - i) % k; if (j &amp;lt; i) break; // 避免重复 else if (j == i) // 0或者k/2 ans += 1LL * b[i] * (b[i] - 1) / 2; else ans += 1LL * b[i] * b[j]; } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; } 绳子切割问题 # 有N条绳子，它们的长度分别为𝐿_𝑖 (≤1000)。如果从它们中切割出 K 条长度相同的绳子，这K条绳子每条最长能有多长？答案保留到小数点后2位。 枚举法的典型应用</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/2-Divide-and-Conquer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/2-Divide-and-Conquer/</guid>
      <description>分治算法最重要的就是如何确定好划分方式，以及划分的构造&#xA;Theory&amp;amp;Thinkings # 分而治之 # 分解为性质相同的子问题，应该只是规模不同&#xA;如果性质不同怎么办？ 进行预处理，转化为性质相同的子问题 归并排序&#xA;分治的分：不同的划分方法&#xA;黑盒划分：归并排序，逆序对 白盒划分：快速排序 平衡子问题&#xA;减而治之&#xA;当分出的子问题是完全相同时，避免重复递归调用 直到某个子问题不用递归求解 直接舍弃或者使用 减是精髓 快速排序中的划分 partition非常重要&#xA;快速归并排序 #enlighten&#xA;思考方法：先把题目降维，然后进行处理&#xA;递归三要素：&#xA;递归终止条件：递归需要一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递归，防止无限递归 终止处理办法：在递归的临界点对应一种简单的情景，这种情景下，应当直接给出问题的解决方案 递归处理方法：递归问题必须可以分解为若干个规模较小、与原问题 形式相同 的子问题，这些子问题可以用 相同的思路 来解决，并且合并得到原问题答案。 递归与循环&#xA;递归也是一种特殊的迭代，但是在迭代前不知道还要迭代多少次 递归函数一定有参数，且参数会在迭代的过程中步步逼近某个值 递归函数中一定有处理终点，而这个点就是递归出口 递归 有去有回（回到之前的栈帧上） 也就是递归这两个字的含义 循环 有去无回 分治算法基本思想&#xA;分 — 将大规模的原问题分割成 k 个更小规模的 子问题，如果子问题的规模仍然不 够小，则再划分为 k 个“子 子”问题，如此递归地进行下去，直到子问题规模足够 小 (基础问题)，很容易求出其解为止。 治 — 求解规模足够小的基础问题。 合 — 将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上 逐步求出原来问题的解。 分治策略算法细分为三个阶段: Divide 、 Conquer 、 Combine 。 Divide 阶 段是把原问题分割成小问题， Conquer 阶段是递归处理流程， Combine 阶段 是运用小问题的答案合成出原问题的解答。</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/3-DP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/3-DP/</guid>
      <description>Theory&amp;amp;Thinkings # 重叠子问题&#xA;状态表示与递推方程 状态转移：状态转移方程&#xA;状态无后效性： 最优性原理：&#xA;找桥梁&#xA;找这个大的最优化问题如何由很多子问题组合而成&#xA;由易至难，自底向上&#xA;T：矩阵连乘积 最优子结构性质 用最外层的循环实现由易至难&#xA;最优子结构：问题的最优解包含其子问题的最优解 隐含了问题最优解和子问题最优解之间的一种递推关系 重叠子问题：对于每个子问题只会计算一次 动态规划算法设计步骤：&#xA;分析最优解性质，刻画最优子结构性质 确定状态表示和状态递推方程，递归地定义最优值 确定状态转移顺序，自底向上计算最优值 根据计算最优值时得到的信息，自顶向下构造最优解 循环变量一定是问题难易程度的量化指标&#xA;真实求解过程中的 DP 解决问题思路：&#xA;明确 dp 数组下标的含义 定义 base case 确定状态转移方程 DP 算法最重要的是状态（阶段）的寻找，状态转移方程和推理方式的确定&#xA;动态规划 (dynamic programming) 是运筹学的一个 分支，是求解决策过程 (decision process) 最优化的 数学方法。20 世纪 50 年代初美国数学家 R.E.Bellman 等 人在研究多阶段决策过程 (multistep decision process) 的优化问题时，提出了著名的最优化原理 (principle of optimality)，把多阶段过程转化为一 系列单阶段问题，利用各阶段之间的关系，逐个求解， 创立了解决这类过程优化问题的新方法—动态规划。&#xA;基本概念&#xA;状态和状态表示: 表示每个阶段开始时，问题或系统所处的客观状况。状态既是该 阶段的某个起点，又是前一个阶段的某个终点。通常一个阶段有若干个状态，每个状态用多元组𝑆(𝑝1, 𝑝2, &amp;hellip; , 𝑝𝑘) 表示，值域表示状态值，或者对应子问题的答案。 状态转移: 在动态规划的多阶段决策过程中，决策序列对应状态序列，每一次决策 对应一次状态转移，状态转移用递推方程来描述，称之为状态转移方程。 状态无后效性: 如果某个阶段状态给定后，则该阶段以后过程的发展不受该阶段以前 各阶段状态的影响。 最优性原理: 求解问题的一个最优策略序列的子策略序列总是最优的，则称该问题满足最优性原理。 构建原问题最优解与子问题最优解之间的关系</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/4-Greedy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/4-Greedy/</guid>
      <description>Method # 基本思想 # 贪心算法基本思想&#xA;贪心算法是一个分阶段决策过程，在每个局部阶段，贪心法都做出一个当前 最优的局部决策，并期望通过每次所做的局部最优决策产生一个全局最优解。&#xA;贪心算法类似于分治算法和动态规划，也是一种基于子问题思想的策略。&#xA;贪心算法求解步骤&#xA;分解，将原问题求解过程划分为连续的若干个决策阶段 决策，在每一个阶段依据贪心策略进行贪心决策，得到局部的最优解，并缩小待求解问题的规模 合并，将各个阶段的局部解合并为原问题的一个全局最优解 Greedy(C) { // C是问题的输入集合即候选集合 S = {}; // 初始解集合为空集 while (not Solution(S)) { // 集合S没有构成问题的一个可行解 x = Select(C); // 在候选集合C中做贪心决策 S = S + {x}; C = C - {Collection(x)}; // 减去一个与x关联的集合，缩小问题规模 } return S; } 候选集合 C 是构造问题的解 (包括最优解) 的对象集合 解集合 S 表示问题的解，它随着贪心选择的进行不断扩展，直到构成一个满足问题的完整解 选择函数 Select 是贪心策略的实现过程，这是贪心法的关键，它指出哪个候 选对象最有希望构成问题的最优解，选择函数通常和目标函数有关 正确性证明 # 数学归纳法&#xA;证明目标 ∀ 𝒏 𝒑(𝒏) 为真 / / n 的论域为正整数集合 证明框架 基础步骤: p(1) 为真 归纳步骤: 证明∀k(p(k) →p(k+1)) //对任意正整数 k, 给出 p(k)├ P(k+1) 的论证步骤 结论: 对任意正整数 n，p(n) 成立 交换论证法</description>
    </item>
    <item>
      <title></title>
      <link>https://caesaryangs.github.io/docs/Algo/5-Search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://caesaryangs.github.io/docs/Algo/5-Search/</guid>
      <description>Intro # 问题求解与搜索算法 # 问题求解涉及到两个方面:&#xA;问题的表示，比如枚举对象、状态表示 求解的方法，比如自顶向下的递归，自底向上的动态规划 搜索算法是一种通用的问题求解方法: 首先把问题表示 转换为一个状态空间图，然后设计特定的图遍历方法在状态空间中搜索问题的答案。&#xA;为了提高搜索的效率，在遍历状态空间时需要添加优化技术，比如剪枝策略用于尽可能避免无效搜索，启发式信息用来加速朝目标状态逼近的速度。&#xA;状态空间图 # 一个问题用搜索算法求解时，往往需要把问题描述为状态空间图，包括以下要素&#xA;状态 (State): 是为描述某类不同事物间的差别而引入的一组最少变量的有序集合，其矢量 形式为: 1 2 n ，其中每个分量 i 称为状态分量。 操作符 (运算符): 是指把一个状态转换为另外一个状态的操作或者运算。操作符可以是规划、数学运算和问题场景中行为等。 状态图: 如果把状态定义为图的结点，操作符定义为图的边，一个问题的全部可能状态则可 以表示为一个图，即状态图。 路径: 通过操作符序列连接起来的状态图中的一个状态序列。 路径耗散函数: 定义在路径上的一个数值函数，它反映了一条路径的性能度量或者求解问题 的代价。在求解最优化问题时，路径耗散函数往往与优化目标相关联。 状态空间图可以形式化地定义为一个四元组 (S，A，G，F)&#xA;S 表示问题的初始状态，它是搜索的起点。 A 是采取的操作符集合，初始状态和操作符隐含地定义了问题的状态图。 G 表示目标测试，它判断给定的状态是否为目标状态。它可以是表示目标状态的一个状态集合，也可以是一个判定函数。 F 代表路径耗散函数，它的定义需要具体问题具体分析。 搜索就是在状态空间图中从初始状态出发，执行特定的操作，试探地寻找目标状态的过 程。当然，也可以从目标结点到初始结点反向进行。状态空间图中从初始状态到目标状 态的路径则代表问题的解。解的优劣由路径耗散函数量度，最优解就是路径耗散函数值 最小的路径。&#xA;搜索算法类型 # 基于枚举的通用搜索 # DFS # 深度优先搜索 (Depth First Search, DFS) 是一种通用的图和树的遍历方法，给 定图𝐺 = (𝑉, 𝐸)，深度优先搜索的基本思想为:&#xA;初始化 任选一个结点𝑣作为源结点，DFS 访问源结点𝑣，并将其标记为已访问过 能进则进，不进则退 递归遍历 扩展结点𝑣，即访问𝑣的下一个未访问邻接结点𝑤; 递归处理以𝑤为根的所有子结点; 退回到结点𝑣，继续扩展𝑣的其它未曾访问的邻接结点，直到𝑣的所有子结点均已访问过为止。 循环处理 若图𝐺中仍然存在未访问的结点，则另选一个未访问的结点作为新的源 结点重复上述过程，直到图中所有结点均被访问过为止。 基于栈的 DFS 算法框架:</description>
    </item>
  </channel>
</rss>
